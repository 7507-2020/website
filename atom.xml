<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Taobao FED | 淘宝前端团队]]></title>
  <subtitle><![CDATA[淘宝前端团队（FED）]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://taobaofed.org/"/>
  <updated>2019-03-19T09:18:13.000Z</updated>
  <id>http://taobaofed.org/</id>
  
  <author>
    <name><![CDATA[Taobao FED]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Web端H.265播放器研发解密]]></title>
    <link href="http://taobaofed.org/blog/2019/03/18/web-player-h265/"/>
    <id>http://taobaofed.org/blog/2019/03/18/web-player-h265/</id>
    <published>2019-03-18T08:59:39.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1lEw2MwHqK1RjSZFgXXa7JXXa-900-500.png" alt="Web端H.265播放器研发解密"></p>
<p>音视频编解码对于前端工程师是一个比较少涉足的领域，涉及到流媒体技术中的文本、图形、图像、音频和视频多种理论知识的学习，才能够应用到具体实践中，我们自研web播放器并支持h.265解码，在码率优化的大背景下（保持画质不变情况下，应用图像增强、roi区域检测、智能场景分类和h265编解码等多种技术能力，将码流降低50%。达到减少带宽成本，提升视频服务QoE的目的），真正做到了h265解码播放的全域覆盖。本文主要分享了我们基于WebAssembly实现H.265格式的解封装、解码和播放。</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p><strong>H.265</strong>又称HEVC(全称<strong>High Efficiency Video Coding</strong>，高效率视频编码)，是ITU-T H.264/MPEG-4 AVC标准的继任者。相比H.264，H.265拥有更高的压缩率，也就意味着同样<strong>码率</strong>（又称比特率是指每秒传送的比特(bit)数。单位为bps(Bit Per Second)，比特率越高，每秒传送数据就越多，画质就越清晰），H.265的画质会更清晰，更高的压缩率就能使用更低的存储和传输成本。</p>
<ul>
<li><strong>带宽成本</strong>：在有限带宽下H.265能传输更高质量的网络视频，理论上，H.265最高只需H.264编码的一半带宽即可传输相同质量视频。更低的带宽可以更好的降低存储及传输成本，并为未来基于短视频及直播领域更多更复杂好玩的互动玩法做铺垫。</li>
<li><strong>转码成本</strong>：但是当前主流浏览器均不支持H.265原生视频播放，因此通常视频生产端需要针对浏览器做一次H.264视频的转码来适配浏览器端如PC场景的播放，而增加了<strong>转码成本</strong>。如在淘宝直播中，假设以每天5万场直播计算，每场直播转码成本20元，一天就是100万的转码成本。<br>为此，我们团队对浏览器端H.265视频播放的可行性及兼容性进行了一次探索，为移动端及PC端全量H.265做准备，也对浏览器端视音频处理、WebAssembly实践进行一次深入的尝试。</li>
</ul>
<h2 id="H-264-vs-H-265"><a href="#H-264-vs-H-265" class="headerlink" title="H.264 vs H.265"></a>H.264 vs H.265</h2><p>H.264是当下用的最为广泛的视频编码格式，H.265标准围绕着现有的视频编码标准H.264，保留原来的某些技术，同时对一些相关的技术加以改进。新技术使用先进的技术用以改善码流、编码质量、延时和算法复杂度之间的关系，达到最优化设置。H.265和H.264都是基于块的视频编码技术，主要的差别在于<strong>编码单元的大小</strong>以及一些编码算法细节，H.265将图像划分为“编码树单元(coding tree Unit, CTU)”，而不是像H.264那样的16×16的宏块。根据不同的编码设置，编码树单元的尺寸可以被设置为64×64或有限的32×32或16×16。一般来说区块尺寸越大，压缩效率就越好。具体的算法及相关细节这里不具体展开了，还有一些其他的压缩算法如因为H.265专利限制而生的开放编码格式如AV1等，读者可以参考其他相关文章。<br><img src="https://img.alicdn.com/tfs/TB1rDSbJgHqK1RjSZFgXXa7JXXa-1178-442.png" alt="h264vsh265.png"> </p>
<p>如下图，可以看到同样主观画面质量，H.265(500K)仅需H.264(800K)一半左右的带宽码率。<br><img src="https://img.alicdn.com/tfs/TB1yUiiJcbpK1RjSZFyXXX_qFXa-545-509.jpg" alt="h264vsh265.png"> </p>
<h2 id="浏览器现状"><a href="#浏览器现状" class="headerlink" title="浏览器现状"></a>浏览器现状</h2><p>如下图，因为H.265专利及硬解支持情况不完善的原因，主流现代浏览器均不兼容H.265编码的视频播放（Edge新版本以插件方式支持），但是因为Apple对H.265的支持（这里作者认为这可能是一个很重要的标志，因为技术的发展很多时候不光是这个技术本身所决定的，而是很多因素共同作用的结果，<strong>商业</strong>也是其中很重要的一个因素），移动端ios safari在11.0版本以上支持原生播放。<br><img src="https://gw.alicdn.com/tfs/TB1OP1lJhjaK1RjSZFAXXbdLFXa-1256-378.png" alt="h265comp"> </p>
<p>想要在浏览器端播放H.265视频原生的 <code>&lt;video /&gt;</code> 标签没有办法支持，但是因为视频格式本身是<strong>连续图像画面</strong>和<strong>音频</strong>的集合，参考了chromium的源码及video标签内部的实现原理，可以通过 <code>&lt;canvas /&gt; + Web Audio API</code> 的结合来模拟实现一个虚拟的video标签来实现播放器功能。</p>
<h2 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h2><p>因为直播流时效性的缘故，发布了一个播放<a href="https://gw.alicdn.com/bao/uploaded/LB1l2iXISzqK1RjSZFjXXblCFXa.mp4?file=LB1l2iXISzqK1RjSZFjXXblCFXa.mp4" target="_blank" rel="noopener">H.265 mp4视频</a>（该视频地址直接在浏览器中播放只有声音而没有画面）的在线demo，读者可以有一个直观感受。<br>地址：<a href="https://g.alicdn.com/videox/mp4-h265/1.0.2/index.html" target="_blank" rel="noopener">https://g.alicdn.com/videox/mp4-h265/1.0.2/index.html</a><br>效果：<br><img src="https://img.alicdn.com/tfs/TB1uRatJhYaK1RjSZFnXXa80pXa-600-341.gif" alt="demo.gif"></p>
<h1 id="前期调研"><a href="#前期调研" class="headerlink" title="前期调研"></a>前期调研</h1><h1 id="播放器整体架构"><a href="#播放器整体架构" class="headerlink" title="播放器整体架构"></a>播放器整体架构</h1><p>基于传统播放器的架构，我们设计的播放器架构如下：<br><img src="https://img.alicdn.com/tfs/TB15IM4LYrpK1RjSZTEXXcWAVXa-1617-856.png" alt></p>
<h2 id="视音频基础"><a href="#视音频基础" class="headerlink" title="视音频基础"></a>视音频基础</h2><p>因为前端领域对视频领域的涉及场景不多，一个 <code>&lt;video /&gt;</code> 标签就可以满足大部分场景，但是经历了这几年直播和短视频的爆发，视频的需求和功能也变得越来越复杂，开发之前阅读了很多视音频领域相关的书籍和文章，在此先对视音频基础进行一个简单的介绍。</p>
<p>视频中我们通常说的视频的格式，比如 .mp4, .mov, .wmv, .m3u8, .flv 等等被称为 <code>container</code>。在一个视频文件中音频、视频数据是分开存储的，使用的压缩算法也不一样。其中container作为容器主要包含了video数据、audio数据、metadata（用于检索视音频payload格式等信息）。每个格式的封装格式不一样，比如FLV格式的基本单元是Tag，而MP4格式的基本单元是Box，辅助的meta信息用于检索找到对应的原始数据。</p>
<p>而平时听到的H.264, H.265等视频编码标准被称为 <code>codec</code> (COmpress and DECompress )。一个视频格式比如mp4可以使用任何标准化的压缩算法，这些信息都会被包含在一个视频文件的meta信息中来告诉播放器该用什么编解码算法来播放。</p>
<h2 id="客户端播放器"><a href="#客户端播放器" class="headerlink" title="客户端播放器"></a>客户端播放器</h2><p>一个传统的客户端播放器播放一个视频流经过了如下各个环节：</p>
<p>拉取数据 =&gt; 解封装 =&gt; 音视频解码 =&gt; 采样/像素数据发送到设备进行渲染。<br><img src="https://img.alicdn.com/tfs/TB1VaB_JmzqK1RjSZFLXXcn2XXa-1024-768.png" alt="client"></p>
<p>对于流媒体，播放器客户端通过拉流以数据源（音视频流）为中心，进行管道式的传输。在此期间，对视频流的读取，转换，分类，复制等一系列操作处理，以封装的mp4流为例，需要对流进行解封装、解码、渲染等步骤：<br><img src="https://img.alicdn.com/tfs/TB1aridJkvoK1RjSZFDXXXY3pXa-1055-524.png" alt="stream"></p>
<h2 id="浏览器video标签"><a href="#浏览器video标签" class="headerlink" title="浏览器video标签"></a>浏览器video标签</h2><p>在探究的过程中，为了了解主流浏览器不支持H.265视频播放的原因，以及浏览器端实现播放器原理的了解，通过对Chromium浏览器<a href="https://github.com/chromium/chromium/tree/master/media#playback" target="_blank" rel="noopener">官方文档</a>及video标签实现源码的阅读，整理了一个流程图。<br><img src="https://img.alicdn.com/tfs/TB1UxCyJhjaK1RjSZKzXXXVwXXa-1502-1008.png" alt="chromium"></p>
<p>可以看到浏览器内部对视频流播放的实现，在经过了PipelineController等数据传输管道的处理后利用FFmpeg软解或者Gpu硬解之后交给视频设备及音频设备进行同步及渲染。其中H.265的视频因为硬解支持情况不完善，软解可能有性能风险，所以在chrome中被关闭了不支持，在chromium中可以通过参数打开。我们就依照这个思路，利用浏览器提供的接口来实现一个模拟的video标签。</p>
<h1 id="设计过程"><a href="#设计过程" class="headerlink" title="设计过程"></a>设计过程</h1><h2 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h2><p>开发思路按照从简单到复杂的过程，对任务进行拆分，来完成H.265视频点播及直播等各个场景的覆盖，以mp4短视频出发完成播放流程，再覆盖直播场景，考虑如网络抖动、内存控制等复杂因素，再针对直播m3u8等回放文件进行播放并开发视频seek、倍速等功能。</p>
<p>mp4播放=&gt;flv播放=&gt;hls播放=&gt;加入seek、倍速等功能</p>
<h2 id="可行性分析"><a href="#可行性分析" class="headerlink" title="可行性分析"></a>可行性分析</h2><ul>
<li>思路：在最开始进行可行性分析时，参考结合了已有工具videoconverter.js和libde265.js对H.265视频ffmpeg的编译提取了hevc文件及mp3音频文件在浏览器端进行了播放。</li>
<li>demo地址：<a href="https://sparkmorry.github.io/mse-learning/h265/" target="_blank" rel="noopener">https://sparkmorry.github.io/mse-learning/h265/</a></li>
<li>表现：将720P的mp4视频进行视频和音频的分离，通过 <code>&lt;canvas /&gt;</code> 绘制图像，通过 <code>&lt;audio /&gt;</code> 标签播放音频，画面在Macbook Pro上Chrome浏览器下在23fps左右。</li>
<li>问题：<ul>
<li><strong>不能达到解码性能标准</strong>: 720P的视频在Macbook Pro上仅在<strong>23fps</strong>左右，而原视频是<strong>25fps</strong>，不能达到解码性能标准，无法流畅播放。</li>
<li><strong>无法做到音画同步</strong>: 该方案因为直接提取了hevc裸流文件，无法获取视频和音频每帧的pts时间戳，无法做到严格的音画同步。</li>
</ul>
</li>
<li>解决方案：<ul>
<li>性能：因为libde265.js是asm.js，通过对libde265.js开源库的改造，打包WebAssembly测试性能情况</li>
<li>音画同步：参考flv.js、hls.js等开源视频库的方案，根据曾经的实践经历，js在解封装方面的性能能够完成视频流文件解封装，获取每帧视频、音频播放的pts及原始数据交给解码器进行解码再渲染。</li>
</ul>
</li>
<li>方案调整：<br><img src="https://img.alicdn.com/tfs/TB17KKAJiLaK1RjSZFxXXamPFXa-1024-768.jpg" alt="1"></li>
</ul>
<h2 id="MP4点播流播放"><a href="#MP4点播流播放" class="headerlink" title="MP4点播流播放"></a>MP4点播流播放</h2><ul>
<li>思路：根据上一过程调整的解决方案，通过js对mp4流进行解封装，因为音频解码的复杂度不高，也先用js进行解码，仅将视频解码模块用已有的三方模块libde265并替换为wasm解决性能问题，音视频解码模块都自身维护一段缓存区，负责存储解封装模块传过来的packet数据，解决音画同步的问题。</li>
<li>表现：通过开源libde265实现的视频解码模块，针对于720p的视频流，平均解码时间是45ms，不能满足每一帧音频播放时间间隔（40ms）。</li>
<li>问题：视频解码性能仍然不够。</li>
<li>解决方案：<ul>
<li><strong>丢帧</strong>：保证了音频同步，丢掉部分非参考帧，但损失了部分体验。所以提升解码性能和改善播放策略才能有可能满足当前方案的可行性。提升解码性能和改善播放策略。</li>
<li><strong>提升解码性能</strong>：用解码性能更好的ffmpeg替换掉libde265。</li>
<li><strong>改善播放流程</strong>：因为每个requestAnimationFrame循环任务都是同步的，边解码边播放。引入用WebWorker线程。通过改善视频解码模块，解码器内部开启循环解码，当外部的视频播放设备需要播放下一帧时，直接从解码器解码完的帧缓存中读取下一帧数据。实现了worker和主线程并行执行。</li>
</ul>
</li>
<li>方案调整：<ul>
<li>demo地址：<a href="https://static-assets.cyt-rain.cn/h265/index.html" target="_blank" rel="noopener">https://static-assets.cyt-rain.cn/h265/index.html</a></li>
<li>设计流程<br><img src="https://img.alicdn.com/tfs/TB1_emeJkvoK1RjSZFDXXXY3pXa-1024-768.jpg" alt="2"></li>
</ul>
</li>
</ul>
<h2 id="FLV直播流播放"><a href="#FLV直播流播放" class="headerlink" title="FLV直播流播放"></a>FLV直播流播放</h2><ul>
<li>思路：mp4视频流畅播放，但在直播场景（如FLV视频流）中，客户端需要和服务端建立长链接，不断接收流消息，借用FFmpeg本身对流媒体的支持，对视频数据进行解封装及解码。</li>
<li>表现：无法编译FFmpeg网络库，TCP无法建立连接。</li>
<li>问题：<br>无法编译FFmpeg网络库：TCP建立连接创建Socket时报错，Emscripten工具无法编译TCP连接相关配置<br>codec不支持：FLV官方协议不支持H.265。</li>
<li>解决方案：<ul>
<li>无法编译FFmpeg网络库：主线程利用fetch方法进行拉流，放到FFmpeg自定义缓冲区进行解封装及解码。因为直播流长时间播放需要不停的开辟、释放内存空间，采用环形的数据缓冲区。</li>
<li>FLV官方协议不支持H.265：对FFmpeg及编码端对H.265进行扩展，因为FFmpeg内部数据结构嵌套较深，替换js解封装函数直接用FFmpeg的解封装函数。</li>
</ul>
</li>
<li>方案调整：<ul>
<li>设计流程<br><img src="https://img.alicdn.com/tfs/TB1HgiaJb2pK1RjSZFsXXaNlXXa-1024-768.jpg" alt="3"></li>
</ul>
</li>
</ul>
<h1 id="当前方案"><a href="#当前方案" class="headerlink" title="当前方案"></a>当前方案</h1><h2 id="播放流程"><a href="#播放流程" class="headerlink" title="播放流程"></a>播放流程</h2><p><img src="https://img.alicdn.com/tfs/TB1zsS3JhnaK1RjSZFtXXbC2VXa-1024-768.png" alt="current"></p>
<ol>
<li>因为FFmpeg支持多种格式解封装，只需要在在主线程中通过浏览器API（通常是fetch方法）拉取原始流数据并放到缓存中，等初始缓存到一个阈值时开启Worker进行解封装及解码；</li>
<li>在子线程（Worker）中通过主线程fetch方法触发的数据回调接收数据存入环形缓冲区（内存环）中；</li>
<li>子线程将读取到的音频帧输送到主线程中，通过Web Audio API缓存音频数据，根据已解码的视频帧缓存队列循环解码保证缓存中一直缓存10帧rgba图像数据；</li>
<li>主线程中canvas根据音频播放回调的pts消费并渲染视频图像；</li>
<li>循环以上操作直到fetch接口返回流已结束。</li>
</ol>
<h2 id="解码器编译"><a href="#解码器编译" class="headerlink" title="解码器编译"></a>解码器编译</h2><p>通过Emscripten工具可以把C语言编写的FFmpeg库编译成wasm并在浏览器中应用到视音频解码中。<br>我们的视频解码场景和通常的播放器一样，通过依赖FFmpeg的通用接口来实现解封装和解码的工作。先通过emscripten编译ffmpeg库，再通过静态库的方式依赖到解封装和解码入口程序中。<br><img src="https://img.alicdn.com/tfs/TB10qJ.JkvoK1RjSZPfXXXPKFXa-1024-768.png" alt="compile"></p>
<h1 id="测试表现"><a href="#测试表现" class="headerlink" title="测试表现"></a>测试表现</h1><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><h3 id="测试视频"><a href="#测试视频" class="headerlink" title="测试视频"></a>测试视频</h3><p>因为flv直播视频受时效性影响较大，拿720P高清的H.265 mp4视频作为<strong>稳定输入</strong>测试</p>
<ul>
<li>地址：<a href="https://gw.alicdn.com/bao/uploaded/LB1l2iXISzqK1RjSZFjXXblCFXa.mp4?file=LB1l2iXISzqK1RjSZFjXXblCFXa.mp4" target="_blank" rel="noopener">https://gw.alicdn.com/bao/uploaded/LB1l2iXISzqK1RjSZFjXXblCFXa.mp4?file=LB1l2iXISzqK1RjSZFjXXblCFXa.mp4</a></li>
<li>视频参数：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input #0, mov,mp4,m4a,3gp,3g2,mj2, from &apos;https://gw.alicdn.com/bao/uploaded/LB1l2iXISzqK1RjSZFjXXblCFXa.mp4?file=LB1l2iXISzqK1RjSZFjXXblCFXa.mp4&apos;:</span><br><span class="line">  Metadata:</span><br><span class="line">    major_brand     : isom</span><br><span class="line">    minor_version   : 512</span><br><span class="line">    compatible_brands: isomiso2mp41</span><br><span class="line">    encoder         : www.aliyun.com - Media Transcoding</span><br><span class="line">  Duration: 00:01:00.10, start: 0.000000, bitrate: 907 kb/s</span><br><span class="line">    Stream #0:0(und): Video: hevc (Main) (hvc1 / 0x31637668), yuv420p(tv, bt709, progressive), 1280x720, 854 kb/s, 25 fps, 25 tbr, 12800 tbn, 25 tbc (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : VideoHandler</span><br><span class="line">    Stream #0:1(und): Audio: aac (LC) (mp4a / 0x6134706D), 44100 Hz, stereo, fltp, 48 kb/s (default)</span><br><span class="line">    Metadata:</span><br><span class="line">      handler_name    : SoundHandler</span><br></pre></td></tr></table></figure>
<h3 id="测试机器"><a href="#测试机器" class="headerlink" title="测试机器"></a>测试机器</h3><ul>
<li>lenovo ThinkPad T430<ul>
<li>CPU: Intel(R) Core(TM) i5-3230M <a href="mailto:CPU@2.60GHz" target="_blank" rel="noopener">CPU@2.60GHz</a>  x64处理器</li>
<li>内存: 8 GB</li>
<li>系统: windows 10</li>
</ul>
</li>
<li>MacBook Pro (Retina, 15-inch, Mid 2015)<ul>
<li>CPU: 2.2 GHz Intel Core i7</li>
<li>内存: 16 GB</li>
<li>系统: macOS 10.14.2</li>
</ul>
</li>
</ul>
<h3 id="性能情况"><a href="#性能情况" class="headerlink" title="性能情况"></a>性能情况</h3><ul>
<li>MBP下表现</li>
</ul>
<table>
<thead>
<tr>
<th>decoder.wasm大小</th>
<th>decoder.js大小</th>
<th>平均每帧解码时长</th>
<th>内存占用</th>
<th>cpu占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.4M</td>
<td>168K</td>
<td>26.79ms</td>
<td>27M</td>
<td>17～25%</td>
</tr>
</tbody>
</table>
<ul>
<li>针对两个pc笔记本进行了测试，平均每帧解码（包含yuv420转rgba）时长在各个浏览器的表现情况如下：<br><strong><em>注：此处Native（原生）表示针对mac系统原生编译的FFmpeg作为依赖的解码器（相对不考虑具体如x86、arm等计算机架构的WebAssembly的跨平台方案而言）</em></strong>。</li>
</ul>
<table>
<thead>
<tr>
<th>设备</th>
<th>Chrome</th>
<th>Safari</th>
<th>FireFox</th>
<th>Edge</th>
<th>Native</th>
</tr>
</thead>
<tbody>
<tr>
<td>MacOS(i7)</td>
<td>26.79ms</td>
<td>22.19ms</td>
<td>24.77ms</td>
<td>-</td>
<td>5.08ms</td>
</tr>
<tr>
<td>windows(i5)</td>
<td>33.51ms</td>
<td>-</td>
<td>36.74ms</td>
<td>86.72ms</td>
<td>未测试</td>
</tr>
</tbody>
</table>
<p>意味着最高能提供720P高清视频如下帧率视频流畅播放的能力：</p>
<table>
<thead>
<tr>
<th>设备</th>
<th>Chrome</th>
<th>Safari</th>
<th>FireFox</th>
<th>Edge</th>
<th>视频基准</th>
<th>Native</th>
</tr>
</thead>
<tbody>
<tr>
<td>MacOS(i7)</td>
<td>37fps</td>
<td>45fps</td>
<td>40fps</td>
<td>-</td>
<td><strong>25fps</strong></td>
<td>196fps</td>
</tr>
<tr>
<td>windows(i5)</td>
<td>30fps</td>
<td>-</td>
<td>27fps</td>
<td>12fps</td>
<td><strong>25fps</strong></td>
<td>未测试</td>
</tr>
</tbody>
</table>
<p>可以看到这两台机器中，在非高速运动等普通的如电商场景25fps帧率的高清720p视频已经能达到生产环境的标准，但是距离原生的速度还有一定距离。</p>
<h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><p>主要用到了WebAssembly及WebWorker的支持，实际测试中主流浏览器Chrome、Safari、Firefox、Edge均能通过兼容性测试。</p>
<ul>
<li><p>WebAssembly<br><img src="https://img.alicdn.com/tfs/TB1uyl9JbPpK1RjSZFFXXa5PpXa-1224-436.png" alt="wasm"></p>
</li>
<li><p>WebWorker<br><img src="https://img.alicdn.com/tfs/TB1bHp.JkvoK1RjSZPfXXXPKFXa-1226-411.png" alt="worker"></p>
</li>
</ul>
<h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>当前的技术方案已经能在大部分机器的主流浏览器上流畅的播放720P的高清直播流，但是在Edge浏览器及性能稍差的机器上还是存在高清视频解码性能不能满足流畅播放的风险，针对WebAssembly达到native速度的目标还有一定距离，尤其是汇编并行计算的支持，在视音频及大规模数据处理中是很常见的性能优化策略，作者整理了几个优化的方向，在未来还有更多探索的空间：</p>
<ul>
<li><p>汇编<br>FFmpeg中解码有较多利用汇编进行并行计算的优化，但是汇编指令是cpu specific的（比如x86指令和arm指令），而wasm是跨平台的基于栈的虚拟机。Emscripten不支持汇编的编译，考虑用clang等llvm前端将FFmpeg的.c和汇编.asm文件编译成LLVM IR（LLVM Intermediate Representation），然后通过fastcomp或者其他后端来编译测试。</p>
</li>
<li><p>硬解<br>FFmpeg3.3以上开始支持自动硬解探测，支持的硬件设备根据不同操作系统及硬件会有不同的支持，具体参考：<a href="https://trac.ffmpeg.org/wiki/HWAccelIntro" target="_blank" rel="noopener">https://trac.ffmpeg.org/wiki/HWAccelIntro</a> 。因为wasm是跨平台的虚拟指令集，支持程度还要待进一步探究。</p>
</li>
<li><p>多线程<br>FFmpeg内部解码有多线程来提高解码性能，通过pthread可以支持跨平台的多线程支持的，但是如果不支持共享内存，则线程之间的数据传输会有很多性能消耗（深拷贝或者Transfered Object）。浏览器端共享内存通过SharedArrayBuffer来实现，因为有安全隐患，大部分主流浏览器关闭了SharedArrayBuffer、Chrome67+开始恢复。考虑到兼容性多线程的支持还要再进行尝试。</p>
</li>
<li><p>WebGL渲染<br>解码平均时长中有4ms左右(15%)在yuv转rgba上，通过WebGL可以用gpu加速图像的计算，但是同时与WebGL的数据交换又会产生一定的性能损耗，需要再测试查看性能结果</p>
</li>
</ul>
<h1 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h1><p>通过H.265视频播放将开源视音频库<strong>FFmpeg</strong>的能力<strong>及WebAssembly</strong>性能的优势在浏览器端视音频处理上有了一次深入的尝试。视频作为一种多媒体形式，相比现有的文字、图像、音频都能有更生动及更丰富信息的表现。尤其经过了直播和短视频的爆发增长后，成为了一种基础的多媒体形式，也是网络及移动端手机性能等技术发展的体现。未来随着5G及更高性能的硬件设备的发展会被更广泛的应用到各个领域。浏览器在这场视频革命中也是不可或缺的一个环节，通过这次的探索，为未来浏览器端扩展视音频处理的通用能力提供了想象的空间，同时也在浏览器端通过WebAssembly向native性能及能力靠近的路上做了一个落地的尝试，虽然从测试情况看现在的表现还不如native，但是随着标准及技术的演进，为未来对性能要求比较高的图形图像及人工智能等相关方向在浏览器端处理一定会渐渐被广泛的应用起来，比如如下几个方向：</p>
<ul>
<li><p><strong>扩展浏览器端视频播放能力</strong><br>借助FFmpeg强大的编解码能力，除了H.265视频的播放，未来还可以在浏览器端兼容各种格式及编码类型的视频播放。如不同的编码格式AV1、不同的容器格式mov格式等等。</p>
</li>
<li><p><strong>扩展浏览器端视音频处理能力</strong><br>借助FFmpeg及其他语言框架的现有能力，还可以在视音频领域做更多复杂的操作如视频滤镜、视频剪切、视频格式转换等功能，减少网络传输及存储的成本。</p>
</li>
<li><p><strong>基于WebAssembly的高性能web应用</strong><br>借助WebAssembly的跨平台优势，可以将传统的其他语言的开源框架如图形相关开源库OpenGL、SDL等的能力移植到浏览器上来。借助性能上的优势也可以将传统的图像、3D等运算能力要求较高的应用扩展到浏览器端。</p>
</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li>Chromium媒体元素源码: <a href="https://github.com/chromium/chromium/tree/master/media" target="_blank" rel="noopener">https://github.com/chromium/chromium/tree/master/media</a></li>
<li>WebAssembly: <a href="https://webassembly.org/" target="_blank" rel="noopener">https://webassembly.org/</a></li>
<li>优秀的开源视音频处理框架FFmpeg: <a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">https://www.ffmpeg.org/</a></li>
<li>基于LLVM编译的WebAssembly打包工具集Emscripten：<a href="https://emscripten.org/index.html" target="_blank" rel="noopener">https://emscripten.org/index.html</a></li>
<li>基于WebAssembly的ogg播放器：<a href="https://github.com/brion/ogv.js" target="_blank" rel="noopener">https://github.com/brion/ogv.js</a></li>
<li>基于FFmpeg的简单播放器：<a href="https://github.com/leixiaohua1020/simplest_ffmpeg_player" target="_blank" rel="noopener">https://github.com/leixiaohua1020/simplest_ffmpeg_player</a></li>
</ul>
<h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>本文介绍了我们在Web端H.265播放器上研发的过程和进展，后续还有很多继续优化和深入的点。对相关知识感兴趣的同学欢迎沟通交流，附上我们前端团队的介绍：</p>
<p>淘宝技术部内容与开放平台前端团队是淘系核心的商业变革阵地，相对于横向资源前端团队，我们更深入在内容电商、音视频技术领域，探寻创新商业模式及业界领先技术。</p>
<p>本团队目前正火热招聘20届优秀毕业生，欢迎有志之士加入！<br>有意向者可直接联系团队负责人： 灵玉 <a href="mailto:lingyu.csh@taobao.com" target="_blank" rel="noopener">lingyu.csh@taobao.com</a></p>
<blockquote>
<p>题图出处：<a href="https://unsplash.com/photos/oTjFWTHDRZQ" target="_blank" rel="noopener">https://unsplash.com/photos/oTjFWTHDRZQ</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1lEw2MwHqK1RjSZFgXXa7JXXa-900-500.png" alt="Web端H.265播放器研发解密"></p>
<p>音视频编解码对于前端工程师是一个比较少涉足的领域，涉及到流]]>
    </summary>
    
      <category term="player" scheme="http://taobaofed.org/tags/player/"/>
    
      <category term="h265" scheme="http://taobaofed.org/tags/h265/"/>
    
      <category term="WebAssembly" scheme="http://taobaofed.org/tags/WebAssembly/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[淘宝前端团队 2019 年实习生内部推荐通道已开启]]></title>
    <link href="http://taobaofed.org/blog/2019/03/13/fed-2019/"/>
    <id>http://taobaofed.org/blog/2019/03/13/fed-2019/</id>
    <published>2019-03-13T02:22:25.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1uzLwLQzoK1RjSZFlXXai4VXa-900-500.jpg" alt="淘宝前端团队 2019 年实习生内部推荐通道已开启"></p>
<p>随着阿里巴巴 2019 年实习生招聘的启动，淘宝前端团队（Taobao FED）实习生内部推荐也已经拉开序幕。这是一个有着十多年历史与荣耀的团队，相信你已经从各个渠道听到过我们的名字。选择一家公司进行实习，对于大学生来说是一个关键的抉择；找到有潜力的实习生进行培养，对于一个团队来说更是求贤若渴。</p>
<p>在这里，请让我向你介绍我们在做的一些事情以及我的小伙伴们。如果你感到有兴趣，并且认为自己足够优秀，不要吝啬你的才华，直接邮件简历给他们，也许他们将会成为你职业生涯的第一个老板，以及你全新人生阶段的良师益友。</p>
<p>以下是我们团队的几个技术场景和负责的小伙伴，你可以选择跟随这些业界大牛学习和成长。</p>
<h3 id="Node-架构体系"><a href="#Node-架构体系" class="headerlink" title="Node 架构体系"></a>Node 架构体系</h3><p>从 Node.js 应用框架到全链路监控以及故障演练，从基于 TypeScript 的 IoC 容器到 Serverless Node.js 运行时，这里有一帮 maker 组成的团队。2020 年毕业的喜欢动手的 maker/创客们欢迎投递简历至：<a href="mailto:qinian.wmq@taobao.com" target="_blank" rel="noopener">qinian.wmq@taobao.com</a></p>
<p><img src="https://img.alicdn.com/tfs/TB1f_A0LQzoK1RjSZFlXXai4VXa-750-150.jpg" alt="七念"></p>
<h3 id="中后台体系"><a href="#中后台体系" class="headerlink" title="中后台体系"></a>中后台体系</h3><p>如果你有志于通过打造桌面工具帮助开发者极速构建前端应用，亦或是参与智能界面设计平台的建设以革新前端的开发模式，还是参与到 Github 1w+ star 开源项目 ICE，简历投递至：<a href="mailto:yuanyan.cao@alibaba-inc.com" target="_blank" rel="noopener">yuanyan.cao@alibaba-inc.com</a></p>
<p><img src="https://img.alicdn.com/tfs/TB1BOxFLSrqK1RjSZK9XXXyypXa-750-150.jpg" alt="元彦"></p>
<h3 id="前端智能化"><a href="#前端智能化" class="headerlink" title="前端智能化"></a>前端智能化</h3><p>专注前端智能化，提效与业务密切相关的开发场景效率，基于计算机视觉、深度学习等，从设计稿（Sketch、PSD、静态图片）一键智能生成高可维护性代码，在这里，我们持续探索智能化的世界。欢迎对前端智能化感兴趣的极客们投递简历至：<a href="mailto:miaojing@taobao.com" target="_blank" rel="noopener">miaojing@taobao.com</a></p>
<p><img src="https://img.alicdn.com/tfs/TB1oyxFLSrqK1RjSZK9XXXyypXa-750-150.jpg" alt="妙净"></p>
<h3 id="终端架构"><a href="#终端架构" class="headerlink" title="终端架构"></a>终端架构</h3><p>坐落于北京的淘宝前端团队，覆盖淘宝 H5 主站、前端数据体系、海报搭建平台、个性化定制、跨端解决方案等场景，我们专注于挖掘业务价值、提升性能体验、拓展技术边界；欢迎 2020 年毕业的精英们投递简历至：<a href="mailto:haiwen.lpy@taobao.com" target="_blank" rel="noopener">haiwen.lpy@taobao.com</a></p>
<p><img src="https://img.alicdn.com/tfs/TB1628yLMTqK1RjSZPhXXXfOFXa-750-150.jpg" alt="海文"></p>
<h3 id="前端搭建体系"><a href="#前端搭建体系" class="headerlink" title="前端搭建体系"></a>前端搭建体系</h3><p>从支持双十一、双十二活动页面的搭建系统，到炙手可热的小程序搭建系统，前端技术-搭建服务团队承担着淘宝页面搭建服务的重任，实现可视化的方式从0到1搭建页面，配置页面动态数据，后期页面运维等一系列服务。不管你是爱好前端技术，还是热衷于 Nodejs 后台开发，搭建服务团队都期待你的加入！欢迎 2020 年毕业的祖国花朵投递简历至：<a href="mailto:butian.wth@taobao.com" target="_blank" rel="noopener">butian.wth@taobao.com</a></p>
<p><img src="https://img.alicdn.com/tfs/TB1fithL4naK1RjSZFBXXcW7VXa-750-150.jpg" alt="步天"></p>
<p>从手淘里的普通页面再到支撑万千页面生成的搭建平台，我们实现了从零到一的效率飞跃。从前端的性能平台再到前端的稳定性治理，我们定义了前端的新数据指标。从 PWA 的全面实践再到 Serverless 理念的引导落地，我们始终站在技术潮流的最前沿。我们是创新业务团队，在淘宝的大平台与前端的风口上尽情挥洒。2020 年毕业的同学，创新业务的未来，有你会更精彩。欢迎投递简历至：<a href="mailto:suhe.ly@taobao.com" target="_blank" rel="noopener">suhe.ly@taobao.com</a></p>
<p><img src="https://img.alicdn.com/tfs/TB1D4gULHPpK1RjSZFFXXa5PpXa-750-150.jpg" alt="苏河"></p>
<h3 id="前端开放体系"><a href="#前端开放体系" class="headerlink" title="前端开放体系"></a>前端开放体系</h3><p>我们尝试 Weex 在跨端应用开发的最佳实践，推进 IDE 在工程链路中的集成，还有面向商家装修的中后台应用，面向 ISV 的开放平台。服务用户广，技术不设限，等你来挑战！欢迎投递简历至：<a href="mailto:zhenghao.zmw@taobao.com" target="_blank" rel="noopener">zhenghao.zmw@taobao.com</a></p>
<p><img src="https://img.alicdn.com/tfs/TB1VMwYLSzqK1RjSZFHXXb3CpXa-750-150.jpg" alt="正豪"></p>
<h3 id="前端工程体系"><a href="#前端工程体系" class="headerlink" title="前端工程体系"></a>前端工程体系</h3><p>如果你想打造整个阿里前端开发的工程化基础底层体系，参与业内领先的前端工程底层系统开发，掌握从项目初始化到线上编译、扫描、发布的全链路体系架构设计与实现。欢迎投递简历至: <a href="mailto:ada@taobao.com" target="_blank" rel="noopener">ada@taobao.com</a></p>
<p><img src="https://img.alicdn.com/tfs/TB1fhQZLFzqK1RjSZSgXXcpAVXa-750-150.jpg" alt="阿大"></p>
<h3 id="图形渲染"><a href="#图形渲染" class="headerlink" title="图形渲染"></a>图形渲染</h3><p>2020 年毕业热爱图形渲染的你一定不要错过这班车，这里有一群致力于 WebGL/WebGPU 跨端标准化实现的小伙伴，诞生了为极致渲染而生的图形渲染引擎 GCanvas，正在面向 5G/IoT 发力创造新一代渲染框架的路上邀你同行，欢迎投递简历至：<a href="mailto:yuantong.xyt@alibaba-inc.com" target="_blank" rel="noopener">yuantong.xyt@alibaba-inc.com</a></p>
<p><img src="https://img.alicdn.com/tfs/TB1B6.ZLMHqK1RjSZFgXXa7JXXa-750-150.jpg" alt="二同"></p>
<p>了解完将要可能与你一起共事的小伙伴，再来给大家介绍你将会工作的阿里西溪园区。在我看来它拥有国内最好的办公环境。</p>
<p><img src="https://img.alicdn.com/tfs/TB1J9l1LSzqK1RjSZFLXXcn2XXa-1000-664.jpg" alt></p>
<p><img src="https://img.alicdn.com/tfs/TB1VbV9LFzqK1RjSZFoXXbfcXXa-1000-650.jpg" alt></p>
<p><img src="https://img.alicdn.com/tfs/TB1hHJ7LSzqK1RjSZFjXXblCFXa-750-750.jpg" alt></p>
<p><img src="https://img.alicdn.com/tfs/TB1Pd9cLMHqK1RjSZFkXXX.WFXa-3992-2242.jpg" alt></p>
<p><img src="https://img.alicdn.com/tfs/TB1TRFEeDZmx1VjSZFGXXax2XXa-3992-2242.jpg" alt></p>
<p>而至于招聘的要求，千篇一律，不再赘述。相信你已有信心和耐心接受接下来的挑战。</p>
<p>敲黑板，以下是工作地点和内推时间：</p>
<ul>
<li>工作地点：杭州、北京</li>
<li>毕业时间：2019.11.01 ~ 2020.10.31  </li>
<li>内推时间：2019.03.12 ~ 2019.04.23</li>
</ul>
<p>任何疑问，可邮件联系：<a href="mailto:xwt.wuji@alibaba-inc.com" target="_blank" rel="noopener">xwt.wuji@alibaba-inc.com</a> 。亦可通过下面的二维码进入内推流程：</p>
<p><img src="https://img.alicdn.com/tfs/TB1jEi2LNnaK1RjSZFtXXbC2VXa-150-150.png" alt="二维码"></p>
<blockquote>
<p>题图：阿里巴巴五年陈现场，出自 <a href="http://alvinhui.lofter.com/post/1cb252a0_12bf2c4e3" target="_blank" rel="noopener">http://alvinhui.lofter.com/post/1cb252a0_12bf2c4e3</a>。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1uzLwLQzoK1RjSZFlXXai4VXa-900-500.jpg" alt="淘宝前端团队 2019 年实习生内部推荐通道已开启"></p>
<p>随着阿里巴巴 2019 年实习生招聘的]]>
    </summary>
    
      <category term="实习生" scheme="http://taobaofed.org/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
      <category term="校招" scheme="http://taobaofed.org/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="团队生活" scheme="http://taobaofed.org/categories/%E5%9B%A2%E9%98%9F%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[imgcook 体验版发布]]></title>
    <link href="http://taobaofed.org/blog/2019/01/07/imgcook/"/>
    <id>http://taobaofed.org/blog/2019/01/07/imgcook/</id>
    <published>2019-01-07T09:09:12.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB19QQxApYqK1RjSZLeXXbXppXa-900-500.png" alt="imgcook 体验版发布"></p>
<h1 id="imgcook-体验版发布"><a href="#imgcook-体验版发布" class="headerlink" title="imgcook 体验版发布"></a>imgcook 体验版发布</h1><p>经过淘宝前端团队内部近一年半的打磨，imgcook 迎来了社区体验版发布，欢迎试用～。</p>
<h2 id="imgcook-是什么？"><a href="#imgcook-是什么？" class="headerlink" title="imgcook 是什么？"></a>imgcook 是什么？</h2><p>imgcook 是专注以各种图像（Sketch/PSD/静态图片）为原材料烹饪的匠心大厨，通过智能化手段将各种图像一键生成可维护的 UI 视图代码，期望此 imgcook (图像大厨) 未来能够成为一位 P5 级别的重构工程师，能切实提高开发的开发效率，并助力开发、设计师、测试的高效协作，我们期望做到：</p>
<ul>
<li>100% 还原【设计师再也不用还原走查了】</li>
<li>100% 兼容【测试再也不用适配样式了】</li>
<li>一键上线【开发再也不用切图写样式了】</li>
</ul>
<p>愿景：能够高度还原各种图像，释放 UI 开发生产力，让你关注更具挑战性的事情！</p>
<p><img src="https://gw.alicdn.com/tfs/TB1ZGmCAXzqK1RjSZSgXXcpAVXa-1440-900.gif#align=left&amp;display=inline&amp;height=466&amp;linkTarget=_blank&amp;originHeight=900&amp;originWidth=1440&amp;width=746#align=left&amp;display=inline&amp;height=466&amp;linkTarget=_blank&amp;originHeight=900&amp;originWidth=1440&amp;width=746" alt></p>
<h2 id="为什么做-imgcook？"><a href="#为什么做-imgcook？" class="headerlink" title="为什么做 imgcook？"></a>为什么做 imgcook？</h2><p>对于 UI 还原而言，早在很多年前，对于类似的从设计稿中还原生成静态 UI 场景的解决方案也都涌现过，比如一些设计稿标注工具（如Marketch），又或者说目前的一些可视化建站平台也都能够在搭建完后直接产出线上页面，为什么做 imgcook，它的优势体现在哪？</p>
<p>我们回到 UI 还原主题上，当我们说图像生成代码的时候，我们关心的不仅仅是生成 UI 的还原度，也关心生成的代码是否合理、可维护，如果生成的代码属于不可读不可维护的快餐代码，开发使用上再对其进行二次开发就会显得极为艰难，而往往后者的难度相比前者更甚，如果需要在生产环境中使用，这个问题就无法避免。</p>
<p>对此，imgcook 的定位就在于解决 UI 还原以及生成可维护代码的问题。</p>
<h3 id="1-设计稿无约束-高还原"><a href="#1-设计稿无约束-高还原" class="headerlink" title="1. 设计稿无约束+高还原"></a>1. 设计稿无约束+高还原</h3><p>对于 UI 还原，目前比较常见的场景是从设计工具（比如Sketch、PS）入手。但比较不如意的是，设计师交付的设计稿里所带的结构化信息往往是杂乱无章的，如果需要精确得解析一个设计稿里某个模块的结构化数据，往往又需要跟设计师进行合作，规范设计稿中的设计以及制定一些约束来进行使用，这就变相要求设计师用设计的方式来写试图代码，一定程度上增加了设计师的成本。<br>imgcook 为了解决这个问题，目前在对设计稿的解析上做了一些智能化的处理，去除了对设计师图层设计规范这块的依赖，当然 imgcook 也提供了一些官方的设计稿规范建议可以让还原效果更符合预期。</p>
<h3 id="2-生成可维护代码"><a href="#2-生成可维护代码" class="headerlink" title="2. 生成可维护代码"></a>2. 生成可维护代码</h3><p>对于可维护性代码的问题，imgcook 会对还原后的 UI 在代码层面上生成目前使用比较广泛的 Flexbox 布局以及相对定位布局，在一些自定义的命名上（比如样式命名），imgcook 也会根据开发者的习惯生成更加人性化的命名。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1EpqnAXYqK1RjSZLeXXbXppXa-2050-1214.png#align=left&amp;display=inline&amp;height=442&amp;linkTarget=_blank&amp;originHeight=1214&amp;originWidth=2050&amp;width=746#align=left&amp;display=inline&amp;height=442&amp;linkTarget=_blank&amp;originHeight=1214&amp;originWidth=2050&amp;width=746" alt></p>
<h2 id="如何使用-imgcook？"><a href="#如何使用-imgcook？" class="headerlink" title="如何使用 imgcook？"></a>如何使用 imgcook？</h2><p>imgcook 目前对外的体验版里，暂时只开放了针对 Sketch 设计稿的还原插件。</p>
<h3 id="1-插件导出模块"><a href="#1-插件导出模块" class="headerlink" title="1. 插件导出模块"></a>1. 插件导出模块</h3><p>在使用 Sketch 插件进行还原的时候，可选中一个模块外层的容器节点（画板、Group或者Symbol）来进行导出。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1A0N9AhTpK1RjSZR0XXbEwXXa-1482-740.png#align=left&amp;display=inline&amp;height=372&amp;linkTarget=_blank&amp;originHeight=740&amp;originWidth=1482&amp;width=746#align=left&amp;display=inline&amp;height=372&amp;linkTarget=_blank&amp;originHeight=740&amp;originWidth=1482&amp;width=746" alt></p>
<h3 id="2-粘贴还原"><a href="#2-粘贴还原" class="headerlink" title="2. 粘贴还原"></a>2. 粘贴还原</h3><p>模块导出完毕后，可前往 imgcook 平台进行粘贴还原。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1AnKhAmzqK1RjSZFpXXakSXXa-1842-960.png#align=left&amp;display=inline&amp;height=389&amp;linkTarget=_blank&amp;originHeight=960&amp;originWidth=1842&amp;width=746#align=left&amp;display=inline&amp;height=389&amp;linkTarget=_blank&amp;originHeight=960&amp;originWidth=1842&amp;width=746" alt></p>
<h3 id="3-保存查阅代码"><a href="#3-保存查阅代码" class="headerlink" title="3. 保存查阅代码"></a>3. 保存查阅代码</h3><p>检查模块还原 UI 以及左侧的布局结构无误后，可进行保存-&gt;查阅代码，目前对外的体验版中 imgcook 提供了几种可选择的 DSL 进行代码生成，对于每个 DSL，可在右侧的 playground 里查看具体运行的效果。<br><br><br><img src="https://gw.alicdn.com/tfs/TB120WjAbrpK1RjSZTEXXcWAVXa-1612-1078.png#align=left&amp;display=inline&amp;height=499&amp;linkTarget=_blank&amp;originHeight=1078&amp;originWidth=1612&amp;width=746#align=left&amp;display=inline&amp;height=499&amp;linkTarget=_blank&amp;originHeight=1078&amp;originWidth=1612&amp;width=746" alt></p>
<h2 id="什么场景下使用-imgcook？"><a href="#什么场景下使用-imgcook？" class="headerlink" title="什么场景下使用 imgcook？"></a>什么场景下使用 imgcook？</h2><p>imgcook 的诞生源于业务，也最终服务于业务。</p>
<ul>
<li>场景使用层面上，imgcook 倾向于以页面中的<strong>模块级别</strong>图文组合的模块。</li>
<li>技术层面上，imgcook 对于支持 Flexbox 布局类型的 DSL 都会有一个比较好的支持，目前 imgcook 提供了四种 DSL，接下来也还会陆续提供更多。<blockquote>
<p>适合使用 imgcook 的场景例子</p>
</blockquote>
</li>
</ul>
<p><img src="https://gw.alicdn.com/tfs/TB16pblAXzqK1RjSZFCXXbbxVXa-1790-1166.png#align=left&amp;display=inline&amp;height=473&amp;linkTarget=_blank&amp;originHeight=1166&amp;originWidth=1790&amp;width=726#align=left&amp;display=inline&amp;height=486&amp;linkTarget=_blank&amp;originHeight=1166&amp;originWidth=1790&amp;width=746" alt><br><br><img src="https://gw.alicdn.com/tfs/TB1qazWApzqK1RjSZFCXXbbxVXa-1526-1000.png#align=left&amp;display=inline&amp;height=489&amp;linkTarget=_blank&amp;originHeight=1000&amp;originWidth=1526&amp;width=746" alt></p>
<h2 id="更多信息"><a href="#更多信息" class="headerlink" title="更多信息"></a>更多信息</h2><ul>
<li><a href="https://imgcook.taobao.org/" target="_blank" rel="noopener">下载 imgcook</a></li>
<li><a href="https://imgcook.taobao.org/docs" target="_blank" rel="noopener">imgcook 使用指南</a><h2 id="建议反馈"><a href="#建议反馈" class="headerlink" title="建议反馈"></a>建议反馈</h2>imgcook 目前还处于体验版，会存在一些不确定性的还原 badcase 以及代码生成不合理的 badcase，请向我们反馈，我们会第一时间进行问题收集、跟进处理。</li>
<li><a href="https://github.com/taobaofed/imgcook/issues" target="_blank" rel="noopener">Issue</a></li>
<li>钉钉交流</li>
</ul>
<p><img src="https://gw.alicdn.com/tfs/TB11YVgAbrpK1RjSZTEXXcWAVXa-842-1114.png#align=left&amp;display=inline&amp;height=314&amp;linkTarget=_blank&amp;originHeight=1114&amp;originWidth=842&amp;width=237#align=left&amp;display=inline&amp;height=987&amp;linkTarget=_blank&amp;originHeight=1114&amp;originWidth=842&amp;width=746" alt></p>
<blockquote>
<p>题图出处：<a href="https://unsplash.com/photos/LrPKL7jOldI" target="_blank" rel="noopener">https://unsplash.com/photos/LrPKL7jOldI</a>，寓意为萌芽阶段的前端智能。</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB19QQxApYqK1RjSZLeXXbXppXa-900-500.png" alt="imgcook 体验版发布"></p>
<h1 id="imgcook-体验版发布"><a href="#i]]>
    </summary>
    
      <category term="AI" scheme="http://taobaofed.org/tags/AI/"/>
    
      <category term="imgcook" scheme="http://taobaofed.org/tags/imgcook/"/>
    
      <category term="智能还原" scheme="http://taobaofed.org/tags/%E6%99%BA%E8%83%BD%E8%BF%98%E5%8E%9F/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[WebGL 纹理详解]]></title>
    <link href="http://taobaofed.org/blog/2018/12/17/webgl-texture/"/>
    <id>http://taobaofed.org/blog/2018/12/17/webgl-texture/</id>
    <published>2018-12-17T07:35:29.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1ng7ewCzqK1RjSZFLXXcn2XXa-900-500.png" alt="WebGL 纹理详解"></p>
<h1 id="WebGL-纹理详解"><a href="#WebGL-纹理详解" class="headerlink" title="WebGL 纹理详解"></a>WebGL 纹理详解</h1><p>Buffer（数据缓冲区）与 Texture（纹理）是 WebGL 程序的两大数据来源。Buffer 可以通过 ArrayBuffer 或更语义化的 TypedArray 来构造；而 Texture 在大多数情况下，是通过 Image 对象来构造的。在构造和使用 Texture 的过程中，需要确定很多<strong>选项</strong>来以不同的方式构造 Texture；这些选项之间有着各种各样的关系，或互相依赖，或互相排斥，或互相影响。最近，我又重新梳理了一遍我所用到的 WebGL 纹理各种参数的影响，稍作整理，以防遗忘。</p>
<p>为此，我专门编写了一个 Demo，如下所示。Demo 页的右上角有一个使用 <a href="https://github.com/dataarts/dat.gui" target="_blank" rel="noopener">dat.GUI</a> 生成的控件，其中列举了影响纹理的一些选项。这篇文章将逐个讨论这些选项的作用和相互关系。</p>
<p><a class="jsbin-embed" href="https://jsbin.com/boxazam/latest/embed?output&height=512px" target="_blank" rel="noopener">JS Bin on jsbin.com</a></p>
<h2 id="Wrap"><a href="#Wrap" class="headerlink" title="Wrap"></a>Wrap</h2><p>在 JavaScript 中，创建纹理的基本流程大约如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 激活纹理单元</span></span><br><span class="line">gl.activeTexture(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建和绑定</span></span><br><span class="line"><span class="keyword">const</span> texture = gl.createTexture();</span><br><span class="line">gl.bindTexture(gl.TEXTURE_2D, texture);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数设置</span></span><br><span class="line">gl.texParameteri(...);</span><br><span class="line">gl.texParameteri(...);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 填充纹理的内容</span></span><br><span class="line">gl.texImage2D(..., image);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过纹理单元将纹理传送给着色器程序</span></span><br><span class="line">gl.uniform1i(...);</span><br></pre></td></tr></table></figure>
<p>然后，在着色器中，使用一个坐标 (x,y) 从纹理上取色。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec4</span> color = <span class="built_in">texture2D</span>(<span class="built_in">texture</span>, <span class="type">vec2</span>(x, y));</span><br></pre></td></tr></table></figure>
<p>通常，从纹理上取色的坐标 x 和 y 的值均在 0~1 之间。Wrap 配置项规定了当取色坐标的坐标取值在 (0, 1) 之外（即试图从纹理图片之外取色）时，应该如何取色。Wrap 有两种：切割(CLAMP)和重复(REPEAT)。我们可以操作上面的 Demo，调整 scale 的值使得纹理图片缩小一些，然后切换 Wrap 配置项为 CLAMP 或 REPEAT，可以发现：当选项置为 CLAMP 时，从纹理外部取色会落到对应的纹理的边缘，比如 <code>texture2D(texture, vec2(2.2, 0.5))</code> 的值会等于 <code>texture2D(texture, vec2(1.0, 0.5))</code>；而选项置为 REPEAT 时，纹理会「平铺」开来，从外部取色会把取色坐标按1取模，映射到纹理内部，比如 <code>texture2D(texture, vec2(2.2, 0.5))</code> 的值会等于 <code>texture2D(texture, vec2(0.2, 0.5))</code>。</p>
<p>切换 Wrap 配置项的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CLAMP</span></span><br><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);</span><br><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);</span><br><span class="line"></span><br><span class="line"><span class="comment">// REPEAT</span></span><br><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);</span><br><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);</span><br></pre></td></tr></table></figure>
<p>下图是 REPEAT 的情况：</p>
<p><img src="https://gw.alicdn.com/tfs/TB1XAx8t9zqK1RjSZPcXXbTepXa-600-380.jpg" alt="repeat"></p>
<p>下图是 CLAMP 的情况：</p>
<p><img src="https://gw.alicdn.com/tfs/TB1dgqbt7voK1RjSZFwXXciCFXa-600-375.jpg" alt="clamp"></p>
<blockquote>
<p>有一点需要注意的是，REPEAT 模式对纹理图片的尺寸有要求，宽度和高度必须为 2 的整数次幂，如 32x32 或 1024x256 的图片都是符合要求的，但 500x512 或 300x300 是不符合的。我们可以将控件中的 size 从 512 改成 300，这时 Demo 将加载这张图片的一个尺寸为 300x300 的替代品作为纹理。如果 Wrap 为 CLAMP，我们会发现稍微纹理模糊了一些，但是如果 Wrap 为 REPEAT，则会报警并黑屏。</p>
</blockquote>
<h2 id="FlipY"><a href="#FlipY" class="headerlink" title="FlipY"></a>FlipY</h2><p>FlipY 是 WebGL 的一个全局配置项（准确地说，它的名称是 UNPACK_FLIP_Y_WEBGL），在本文的范畴中，它主要影响了 <code>texImage2D()</code> 方法的行为。</p>
<p>按照 OpenGL 的惯例，当着色器调用 <code>texture2D(t, st)</code> 方法从纹理中取色时，传入的取色坐标 <code>st</code> 的原点是左下角。换言之，如果传入的坐标是 (0, 0)，那么 OpenGL 期望取到的是左下角的那个像素的颜色。但是，由于在 Web 上图片数据的存储是从左上角开始的，传入坐标 (0,0) 时，实际上会取到左上角坐标的值。如果我们设置了 <code>FlipY</code> 配置项，那么在向纹理中加载数据的时候，就会对数据作一次翻转，使纹理坐标原点变为左下角。</p>
<p>开启 FlipY 的代码是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>在 Demo 中，默认情况下 FlipY 配置项是勾选的，如果你勾选取消，会发现纹理图片被翻转了。下图是取消 FlipY 配置后的情况。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1dFuJtVzqK1RjSZSgXXcpAVXa-600-379.jpg" alt="cancel-flipY"></p>
<h2 id="MIN-FILTER-和-MAG-FILTER"><a href="#MIN-FILTER-和-MAG-FILTER" class="headerlink" title="MIN_FILTER 和 MAG_FILTER"></a>MIN_FILTER 和 MAG_FILTER</h2><p>一个纹理是由离散的数据组成的，比如一个 2x2 的纹理是由 4 个像素组成的，使用 (0,0)、(0, 1) 等四个坐标去纹理上取样，自然可以取到对应的像素颜色；但是，如果使用非整数坐标到这个纹理上去取色。比如，当这个纹理被「拉近」之后，在屏幕上占据了 4x4 一共 16 个像素，那么就会使用 (0.33,0) 之类的坐标去取值，如何根据离散的 4 个像素颜色去计算 (0.33,0) 处的颜色，就取决于参数 MAG_FILTER。在 WebGL 中设置这两个项的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);</span><br><span class="line">gl.texParameteri(</span><br><span class="line">    gl.TEXTURE_2D, </span><br><span class="line">    gl.TEXTURE_MIN_FILTER, </span><br><span class="line">    gl.LINEAR_MIPMAP_LINEAR</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>MAG_FILTER 有两个可选项，NEAREST 和 LINEAR。顾名思义，NEAREST 就是去取距离当前坐标最近的那个像素的颜色，而 LINEAR 则会根据距离当前坐标最近的 4 个点去内插计算出一个数值，如图所示。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1hgfJt3HqK1RjSZFEXXcGMXXa-600-481.png" alt="MAG_FILTER"></p>
<p>显然 NEAREST 的运行速度更快，但 LINEAR 的效果更好。使用 NEAREST 时，当纹理被拉得比较近，颗粒感会比较明显，而使用 LINEAR 则会顺滑一些。你可以切换右上角空间上的 MAG_FILTER 选项，然后拖动 scale 滑块将纹理放大，体会一下两者的差别。</p>
<p>下图是 MAG_FILTER 为 NEAREST 的效果：</p>
<p><img src="https://gw.alicdn.com/tfs/TB1l_nZtYvpK1RjSZFqXXcXUVXa-600-421.png" alt="MAG_FILTER_NEAREST"></p>
<p>下图是 MAG_FILTER 为 LINEAR 的效果：</p>
<p><img src="https://gw.alicdn.com/tfs/TB1I2_St4TpK1RjSZR0XXbEwXXa-600-419.png" alt="MAG_FILTER_LINEAR"></p>
<p>MAG_FILTER 作用于将纹理拉近/放大的情形，而当纹理远离/缩小的时候，起作用的是 MIN_FILTER。MIN_FILTER 有以下 6 个可选配置项：</p>
<ul>
<li>NEAREST</li>
<li>LINEAR</li>
<li>NEAREST_MIPMAP_NEAREST</li>
<li>NEAREST_MIPMAP_LINEAR</li>
<li>LINEAR_MIPMAP_NEAREST</li>
<li>LINEAR_MIPMAP_LINEAR</li>
</ul>
<p>前两个配置项和 MAG_FILTER 的含义和作用是完全一样的。但问题是，当纹理被缩小时，原纹理中并不是每一个像素周围都会落上采样点，这就导致了某些像素，完全没有参与纹理的计算，新纹理丢失了一些信息。假设一种极端的情况，就是一个纹理彻底缩小为了一个点，那么这个点的值应当是纹理上所有像素颜色的平均值，这才比较合理。但是 NEAREST 只会从纹理中取一个点，而 LINEAR 也只是从纹理中取了四个点计算了一下而已。这时候，就该用上 MIPMAP 了。</p>
<h2 id="Mipmap-和-MIN-FILTER"><a href="#Mipmap-和-MIN-FILTER" class="headerlink" title="Mipmap 和 MIN_FILTER"></a>Mipmap 和 MIN_FILTER</h2><p>为了在纹理缩小也获得比较好的效果，需要按照采样密度，选择一定数量（通常大于 LINEAR 的 4 个，极端情况下为原纹理上所有像素）的像素进行计算。实时进行计算的开销是很大的，所有有一种称为 MIPMAP（金字塔）的技术。在纹理创建之初，就为纹理创建好 MIPMAP，比如对 512x512 的纹理，依次建立 256x256（称为 1 级 Mipmap）、128x128（称为 2 级 Mipmap） 乃至 2x2、1x1 的纹理。实时渲染时，根据采样密度选择其中的某一级纹理，以此避免运行时的大量计算。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1_0.ot9zqK1RjSZPxXXc4tVXa-501-503.png" alt="Mipmap"></p>
<blockquote>
<p>显而易见的是，使用 MIPMAP 同样需要纹理尺寸为 2 的整数次幂。</p>
</blockquote>
<p>WebGL 中，可以通过调用以下方法来生成 mipmap。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.generateMipmap(gl.TEXTURE_2D);</span><br></pre></td></tr></table></figure>
<p>我们将控制面板中的 <code>generateMipmap</code> 打开，并把 scale 调到一个较小的值（比如 0.5），然后切换 MIN_FILTER 的各种设置，就可以观察到 mipmap 的效果了。</p>
<p>下图是 MIN_FILTER 为 LINEAR 的效果（NEAREST 效果是类似的）：</p>
<p><img src="https://gw.alicdn.com/tfs/TB1CmY0tVzqK1RjSZFvXXcB7VXa-600-420.png" alt="MIN_FILTER_LINEAR"></p>
<p>下图是 MIN_FILTER 为 LINEAR_MIPMAP_NEAREST 的效果（LINEAR_MIPMAP_LINEAR 效果是类似的）：</p>
<p><img src="https://gw.alicdn.com/tfs/TB11zLZt9zqK1RjSZPcXXbTepXa-600-418.png" alt="MIN_FILTER_MIPMAP"></p>
<p>可以看到当采用 MIPMAP 时，纹理平滑了很多（特别是头发部分）。</p>
<blockquote>
<p>MIN_FILTER 的默认值是 LINEAR_MIPMAP_NEAREST。在 XXX_MIPMAP_XXX 的格式中，前一个 XXX 表示在单个 MIPMAP 中取色的方式，与单独的 LINEAR 或 NEAREST 类似，而后一个 XXX 表示，随着采样密度连续变化（通常是因为缩放因子连续变化）时，是否在多层 MIPMAP 之间内插。使用 MIPMAP 时，后一个 LINEAR 比较重要，只要后者是 LINEAR，前者的意义其实并不特别大，所以默认选项 NEAREST_MIPMAP_LINEAR 也是最常用的。</p>
</blockquote>
<h2 id="自定义-Mipmap"><a href="#自定义-Mipmap" class="headerlink" title="自定义 Mipmap"></a>自定义 Mipmap</h2><p>我们可以使用 <code>gl.generateMipmap()</code> 方法来根据原始纹理生成一套 mipmap，这种生成的方式是默认的。但是实际上，我们还有一种更灵活的方式来自定义 Mipmap，那就是直接传入另一张图片。比如，这里我们使用的是一张 512x512 的 lena 图，调用 <code>gl.generateMipmap()</code> 会生成 256x256、128x128 直至 1x1 等一系列图片。但是，如果我们手头正好有一张 128x128 尺寸的图片，我们就可以强制指定这张图片作为原始纹理的 1 级 Mipmap。</p>
<p><img src="https://gw.alicdn.com/tfs/TB17fknt9rqK1RjSZK9XXXyypXa-600-503.png" alt="Custom Mipmap"></p>
<p>自定义 Mipmap 纹理的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先要调用此方法</span></span><br><span class="line"><span class="comment">// 如果在 texImage2D 后调用，则定制的 mipmap 会被覆盖</span></span><br><span class="line">gl.generateTexture(gl.TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">gl.texImage2D(</span><br><span class="line">    gl.TEXTURE_2D,</span><br><span class="line">    <span class="number">1</span>,  <span class="comment">// 就是这个参数指定几级 Mipmap</span></span><br><span class="line">    gl.RGBA,</span><br><span class="line">    gl.RGBA,</span><br><span class="line">    gl.UNSIGNED_BYTE,</span><br><span class="line">    image <span class="comment">// 尺寸必须严格符合指定级别 Mipmap 应有的尺寸</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>当我们指定好自定义的 Mipmap 纹理后（即勾选 customMipmap），同时勾选 generateMipmap，并且保证 MIN_FILTER 在 XXX_MIPMAP_XXX 的配置上，此时拖动 scale 滑块，会发现在缩小过程中的某个过程，纹理会变成自定义图片。当 MIN_FILTER 在 XXX_MIPMAP_NEAREST 时，纹理是「突变」的；而当 MIN_FILTER 位于 XXX_MINMAP_LINEAR 时，纹理是「渐变」的，这也印证了前面关于 XXX_MIPMAP_XXX 的解释。</p>
<p>下图是 MIN_FILTER 为 LINEAR_MIPMAP_NEAREST 时缩放的效果：</p>
<p><img src="https://gw.alicdn.com/tfs/TB11r3xt7voK1RjSZFDXXXY3pXa-500-316.gif" alt="CustomMipmap1"></p>
<p>下图是 MIN_FILTER 为 LINEAR_MIPMAP_LINEAR 时缩放的效果：</p>
<p><img src="https://gw.alicdn.com/tfs/TB1ctgvtYvpK1RjSZFqXXcXUVXa-500-316.gif" alt="CustomMipmap2"></p>
<h2 id="SRGB-扩展"><a href="#SRGB-扩展" class="headerlink" title="SRGB 扩展"></a>SRGB 扩展</h2><p>RGB 颜色空间是为人眼设计的。但是人眼感光强度和真实光线的物理强度并不是线性关系，这是人眼的生理结构所决定的。比如，在人眼看来，屏幕上显示的白色 #FFFFFF 的亮度，是半灰色 #888888 亮度的 2 倍，但是两者真实的光线物理强度（直射下单位面积上受光照的功率）并不是 2 倍关系。所以，当着色器需要基于一些物理规律来计算颜色时，直接取纹理的颜色没有意义，需要作一次转换。</p>
<p>一个经验是，将人眼感知的颜色归一化到 (0,1) 之间，然后取 2.2 次方幂，得到的结果与光线物理强度是呈线性关系的。如下所示，横轴是 RGB 色彩空间，蓝色直线是人眼的感光曲线，红色曲线是光线物理强度曲线。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1QD7Xt3HqK1RjSZFEXXcGMXXa-297-286.png" alt="SRGB"></p>
<p>SRGB 扩展所做的就是这件事，在用户调用 <code>texImage2D</code> 向纹理中传输数据时，将纹理的每个像素颜色取了自己的 2.2 次方幂。开启 SRGB 扩展的代码如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SRGBExtension = gl.getExtension(<span class="string">"EXT_SRGB"</span>);</span><br><span class="line"></span><br><span class="line">gl.texImage2D(</span><br><span class="line">    gl.TEXTURE_2D, </span><br><span class="line">    <span class="number">0</span>, </span><br><span class="line">    <span class="comment">// 接下来两个参数原本是 gl.RGBA</span></span><br><span class="line">    SRGBExtension.SRGB_ALPHA_EXT, </span><br><span class="line">    SRGBExtension.SRGB_ALPHA_EXT, </span><br><span class="line">    gl.UNSIGNED_BYTE, </span><br><span class="line">    image</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>在控件中勾选 SRGB，会发现纹理变暗了很多，因为颜色作为 [0,1] 之间的数值，取了自己的 2.2 次方幂，自然变小了。其实，如果不使用 SRGB 扩展，在着色器中也可以模拟。我们可以取消勾选 SRGB 选项，然后将 postProcess（后处理）项置为 c^2.2，画面也同样变暗了。postProcess 是这个 Demo 埋在 Shader 中的一个普通 uniform 变量，为最后颜色输出增加一个可选的环节（取自己的 2.2 次方幂，或者取自己的 1/2.2 次方幂）。</p>
<p>着色器中有关 postProcess 的代码如下：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(uPostProcess == <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="built_in">pow</span>(<span class="built_in">gl_FragColor</span>.rgb, <span class="type">vec3</span>(<span class="number">1.0</span>/<span class="number">2.2</span>)), <span class="number">1.0</span>);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(uPostProcess == <span class="number">2</span>)&#123;</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="built_in">pow</span>(<span class="built_in">gl_FragColor</span>.rgb, <span class="type">vec3</span>(<span class="number">2.2</span>)), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图是 SRGB 模式的效果，postProcess 选择 c^2.2 能达到同样的效果。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1Aqr8tZbpK1RjSZFyXXX_qFXa-600-419.png" alt="SRGB"></p>
<p>当然，我们也可以勾选 SRGB，然后在 postProcess 中选择取 1/2.2 次方幂，这样输出的颜色和最初的几乎一样。SRGB 扩展将纹理颜色值压低，后处理又把输出的颜色值调亮，两者相互抵消。这正是 PBR 渲染的常用做法，先把纹理颜色从人眼颜色空间的纹理压低成物理空间，然后进行一系列物理规律运算，最后输出时再调亮成人眼颜色空间。</p>
<p>下图是 SRGB + postProcess c^1/2.2 的效果，和不使用 SRGB 和 postProcess 的效果基本一致：</p>
<p><img src="https://gw.alicdn.com/tfs/TB1Qr__tYvpK1RjSZFqXXcXUVXa-600-421.png" alt="SRGB_PostProcess"></p>
<h2 id="Tex-Lod-扩展"><a href="#Tex-Lod-扩展" class="headerlink" title="Tex_Lod 扩展"></a>Tex_Lod 扩展</h2><p>之前说过，从 Mipmap 中的哪一级纹理取色，取决于在此纹理上采样的密度。但是有了 Tex_Lod 扩展，可以不受此限制，在着色器中直接编码指定从某一级纹理取色。</p>
<p>开启 Tex_Lod 扩展：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gl.getExtension(<span class="string">"EXT_shader_texture_lod"</span>);</span><br></pre></td></tr></table></figure>
<p>着色器中也需要加入开启 #extension 宏：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#extension GL_EXT_shader_texture_lod: enable</span></span><br></pre></td></tr></table></figure>
<p>在着色器中，可调用 <code>texture2DLodExt</code> 函数来从指定级别的 Mipmap 上取色。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gl_FragColor</span> = texture2DLodEXT(uTexture, st, uExtLodLevel);</span><br></pre></td></tr></table></figure>
<p>在右上角的控制器中，确保 Mipmap 相关的选项都打开，然后打开 extLod，拖动 extLodLevel 滑块，可见虽然纹理本身没有在缩放，但是纹理似乎变模糊了，此时实际上就是取到级别较高的 Mipmap 中去了，因为 Mipmap 的级别越高，像素数量越少，在尺寸不变的情况下，就会变模糊了。</p>
<p>下图是 extLod 开启后，在不依赖纹理的缩放导致采样密度变化的情况下，直接手动编码来从不同级别的 Mipmap 上取色的情况：</p>
<p><img src="https://gw.alicdn.com/tfs/TB1xK7vtVYqK1RjSZLeXXbXppXa-500-316.gif" alt="extLod"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>至此，完成了上述所有配置项的讨论。</p>
<p>（完）</p>
<script async src="https://static.jsbin.com/js/embed.min.js?4.1.7"></script>

<blockquote>
<p>题图出处 <a href="https://unsplash.com/photos/95YRwf6CNw8" target="_blank" rel="noopener">https://unsplash.com/photos/95YRwf6CNw8</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1ng7ewCzqK1RjSZFLXXcn2XXa-900-500.png" alt="WebGL 纹理详解"></p>
<h1 id="WebGL-纹理详解"><a href="#WebGL-纹]]>
    </summary>
    
      <category term="WebGl" scheme="http://taobaofed.org/tags/WebGl/"/>
    
      <category term="纹理" scheme="http://taobaofed.org/tags/%E7%BA%B9%E7%90%86/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[前端架构杂思录：议 Function Component 与 Hooks]]></title>
    <link href="http://taobaofed.org/blog/2018/11/27/hooks-and-function-component/"/>
    <id>http://taobaofed.org/blog/2018/11/27/hooks-and-function-component/</id>
    <published>2018-11-27T03:18:33.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB11clIsgHqK1RjSZFkXXX.WFXa-900-500.png" alt="前端架构杂思录：议 Function Component 与 Hooks"></p>
<p>最近团队里 @大果 分享了 React Hooks，也尝试讨论下 Function Component 与 React Hooks，技术的发展路径总是逐步降低其门槛，简单从轻量级角度我们做一个排序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createClass Component &gt; Class Component &gt; Function Component</span><br></pre></td></tr></table></figure>
<p>技术上 Class Component 是可以完全代替 createClass Component 方式，所以已经是废弃不推荐使用，那是不是 Function Component 也可以完全替代 Class Component？在没有 Hooks 之前显然是无法做到的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hey</span>(<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>Good &#123;props.boy&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Function Component 没有内部状态变化机制，只能从外部进行状态的驱动，组件的可测试性也非常高，是一个没有争议的 Good Design。</p>
<p>但这个 Design 并没法替代 Class Component，只是一个可选。所以现实是无论一个组件内部是不是有状态，大部分开发者一定是用思维惯性在编程，或者说 make it work first，都用 Class Component 没毛病。</p>
<p>但当下基于 Class Component 的 React 应用有哪些小问题？</p>
<p>第一，曾经 createClass 不用关心 this 的问题，现在很糟心，比如下面 <code>handleClick</code> 的 this 并不是当前 Hey 类的实例，一不小就异常，这虽然不是 Class Component 的锅，但确实是用户侧存在的多数问题。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hey</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    name: <span class="string">'yiyi'</span>,</span><br><span class="line">    emoji: <span class="string">'😊'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="comment">// throw error</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      emoji: <span class="string">'😢'</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Hey &#123;this.state.name&#125;, &#123;this.state.emoji&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二，当前的 React 应用很容易陷入 <code>标签嵌套地狱</code> 的情形，比如下面用到 Context 的场景就非常典型，看着眼花缭乱。在数据同步场景里，<br>因为需要通知更新所有引用数据的地方，所以通过 render-props 形式定义在 Context.Consumer 的 Children 中，使用到越多的 Context 就会导致嵌套越多的层级，这简直是噩梦。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;FooContext.Provider value=&#123;<span class="keyword">this</span>.state.foo&#125;&gt;</span><br><span class="line">      &lt;BarContext.Provider value=&#123;<span class="keyword">this</span>.state.bar&#125;&gt;</span><br><span class="line">        &lt;BarContext.Consumer&gt;</span><br><span class="line">          &#123;bar =&gt; (</span><br><span class="line">            &lt;FooContext.Consumer&gt;</span><br><span class="line">              &#123;foo =&gt; (</span><br><span class="line">                <span class="built_in">console</span>.log(bar, foo)</span><br><span class="line">              )&#125;</span><br><span class="line">            &lt;<span class="regexp">/FooContext.Consumer&gt;</span></span><br><span class="line"><span class="regexp">          )&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>BarContext.Consumer&gt;</span><br><span class="line">      &lt;<span class="regexp">/BarContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>FooContext.Provider&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三，一些有状态的逻辑比较难重用。这个其实不算 React 独有的问题，只能说当前主流前端架构体系里都没有很好的解决方案。</p>
<p>因此 React 团队基于 Function Component 提出 Hooks 的概念，Hooks 有几个关键 API: useState、useEffect、useContext。这些 API 让 React 更 Reactive：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState, useContext, useEffect, createContext &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">const</span> FooContext = createContext(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">const</span> BarContext = createContext(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hey</span>(<span class="params">props, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">'yiyi'</span>);</span><br><span class="line">  <span class="keyword">const</span> [emoji, setEmoji] = useState(<span class="string">'😊'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> foo = useContext(FooContext);</span><br><span class="line">  <span class="keyword">const</span> bar = useContext(BarContext);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> handleClick = <span class="function"><span class="params">()</span> =&gt;</span> setEmoji(<span class="string">'😢'</span>);</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'componentDidMount or componentDidUpdate'</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'componentWillUnmount'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, [name]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;span onClick=&#123;handleClick&#125;&gt;Hey &#123;name&#125;, &#123;emoji&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">      &lt;FooContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">        &lt;BarContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">          &#123;foo&#125;, &#123;bar&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>BarContext.Provider&gt;</span><br><span class="line">      &lt;<span class="regexp">/FooContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基于 Function Component 与 Hooks 整体代码是比较简洁的，也直接避免了 this 指向的问题，对比上文中 <code>标签嵌套地狱</code> 的代码，尤其使用 useContext 看起来的确舒服太多了，在使用 Context 的地方尽量通过 Function Component 结合 useContext hook 应该是未来的最佳实践。</p>
<p>Hooks 在架构上最值得称赞是提供一种有状态逻辑的复用机制，并且是通过组合的方式。如下使用 hooks 机制对页面是否可见状态的封装：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; useState, useEffect &#125; = <span class="built_in">require</span>(<span class="string">'react'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useDocumentVisibility</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [documentVisibility, setDocumentVisibility] = useState(<span class="built_in">document</span>.visibilityState);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleVisibilityChange</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setDocumentVisibility(<span class="built_in">document</span>.visibilityState);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'visibilitychange'</span>, handleVisibilityChange);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">window</span>.removeEventListener(<span class="string">'visibilitychange'</span>, handleVisibilityChange);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;, []);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> documentVisibility;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Hey</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> documentVisibility = useDocumentVisibility();</span><br><span class="line">  <span class="keyword">return</span> &#123;documentVisibility === <span class="string">'visible'</span> ? <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>: <span class="literal">null</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 Hooks 可以方便的把状态关注点进行分离，每一个状态分离后可复用，对于一个高复杂逻辑的项目，往往有非常多的业务数据状态，比如A页面与B页面都有一个登录状态需要同步，在原先我们的做法需要主动去关注状态与渲染之间的关系：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isLogin: getLoginState()</span><br><span class="line">  &#125;</span><br><span class="line">  componenetDidMount() &#123;</span><br><span class="line">    LoginManager.on(<span class="string">'status'</span>, (status) =&gt; &#123; <span class="keyword">this</span>.setState(&#123;<span class="attr">isLogin</span>: status&#125;)&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="keyword">this</span>.state.isLogin ? <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>A<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> : <span class="literal">null</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    isLogin: getLoginState()</span><br><span class="line">  &#125;</span><br><span class="line">  componenetDidMount() &#123;</span><br><span class="line">    LoginManager.on(<span class="string">'status'</span>, (status) =&gt; &#123; <span class="keyword">this</span>.setState(&#123;<span class="attr">isLogin</span>: status&#125;)&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="keyword">this</span>.state.isLogin ? <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>B<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> : <span class="literal">null</span> &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以明显的察觉到两个页面为了做登录状态同步的事情，感觉 80% 的代码都是冗余重复的，如果使用 Hooks 就是完全不同的情形：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useLogin</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [isLogin, setLogin] = useState(getLoginState());</span><br><span class="line">  LoginManager.on(<span class="string">'status'</span>, (status) =&gt; &#123; setLogin(status)&#125;);</span><br><span class="line">  <span class="keyword">return</span> isLogin;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLogin = useLogin();</span><br><span class="line">  <span class="keyword">return</span> &#123;isLogin ? <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>A<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> : <span class="literal">null</span> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> isLogin = useLogin();</span><br><span class="line">  <span class="keyword">return</span> &#123;isLogin ? <span class="xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span>B<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> : <span class="literal">null</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>细心的同学可能会发现 Function Component 在 re-render 时除了纯粹的 render 代码之外 useState 也是重复被申明与执行了的，这在逻辑上似乎有些不合常理，为什么下面代码重复被执行组件内上一次的 state 依旧还在？</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [name, setName] = useState(<span class="string">'yiyi'</span>);</span><br><span class="line"><span class="keyword">const</span> [emoji, setEmoji] = useState(<span class="string">'😊'</span>);</span><br></pre></td></tr></table></figure>
<p>这里我们了解下 useState 的工作原理，看如下 useState 实现原理的示例代码，引擎通过代码上 useState 的执行顺序在内部维护一个 stateIndex 来识别当前是哪一个 state，并且只在第一次 render 时的才接受 initState, re-render 的时候从内部维护 state 存储器中获取上一次的 state 值。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> stateIndex = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> currentComponentInstance = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> isComponentDidMount = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initState</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> index = ++stateIndex;</span><br><span class="line">  <span class="keyword">const</span> privateStateStore = currentComponentInstance._state;</span><br><span class="line">  <span class="keyword">if</span> (!isComponentDidMount) &#123;</span><br><span class="line">    privateStateStore[index] = initState;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 示例代码只考虑简单的数据类型</span></span><br><span class="line">  <span class="keyword">const</span> stateUpdater = <span class="function">(<span class="params">state</span>) =&gt;</span> privateStateStore[index] = state;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> [privateStateStore[index], stateUpdater];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从内部原理实现角度，这个方案并不优雅，解决了问题但坑也比较大，比方说：useState 的执行顺序要在每次 render 时必须保持一致，否则 stateIndex 的顺序就会错乱，对于不熟悉个约定的新手来说是一个噩梦，这个问题一旦发生非常难调试。有人提议借助 Lint 来规避这个问题，这是典型的填补一个坑通过挖另一个坑来解决。 </p>
<p>关于生命周期，使用 useEffect 基本解决了在 Fuction Component 无生命周期的问题，但这也是有代价的，显然 useEffect 在语义上抽象的不确定的，最糟糕的是 useEffect 约定了 return 的函数执行时机等价与 componentWillUnmount 执行时机，表达上比较晦涩，给代码的可读性上带来了些许的不愉快。要清楚 useEffect 并没有避免生命周期的概念，只是用一种方式隐藏了他们，这种隐藏方式我理解是基于 Fuction Component 的一种无奈。</p>
<p>此外 Function Component 还有一个特点是外部对组件的操作只能通过 props 进行控制，所以组件暴露方法来控制组件内部状态的方式不存在了，理想上能统一使用 Function Component 在架构上这一个益处，外部接口暴露更一致了，但只是理想。</p>
<p>结尾，复杂应用尽可能使用 Function Component + Hooks 是值得推荐的，这是更美好的明天。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB11clIsgHqK1RjSZFkXXX.WFXa-900-500.png" alt="前端架构杂思录：议 Function Component 与 Hooks"></p>
<p>最近团队里 @大]]>
    </summary>
    
      <category term="React" scheme="http://taobaofed.org/tags/React/"/>
    
      <category term="Hooks" scheme="http://taobaofed.org/tags/Hooks/"/>
    
      <category term="函数式组件" scheme="http://taobaofed.org/tags/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BB%84%E4%BB%B6/"/>
    
      <category term="前端架构" scheme="http://taobaofed.org/tags/%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Atag - Web Components 最佳实践]]></title>
    <link href="http://taobaofed.org/blog/2018/10/31/a-tag/"/>
    <id>http://taobaofed.org/blog/2018/10/31/a-tag/</id>
    <published>2018-10-31T08:09:15.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1Q3Y4l4TpK1RjSZFGXXcHqFXa-900-500.jpg" alt="Atag - Web Components 最佳实践"></p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>上一次社区中谈论起 Web Components 已经可以追溯到三四年前了，彼时 Web Components 仍处于不稳定的草案阶段，Polymer 的出世使大家似乎看到了新一代的前端技术，但直到今天，在今年五月 Google I/O 发布 Polymer 3 之后， Web Components 的规模化应用才看似成为了可能。</p>
<p>过去一段时间，我一直在使用 Web Components 构建淘宝小程序的 <a href="https://github.com/alibaba/rax/tree/master/packages/atag" target="_blank" rel="noopener">基础组件 Atag</a>。MDN 上对 Web Components 这个名词的解释是</p>
<blockquote>
<p>Web Components是一套不同的技术，允许您创建可重用的定制元素（它们的功能封装在您的代码之外）并且在您的web应用中使用它们。</p>
</blockquote>
<p>我们从中提取几个关键字：<code>可重用</code> <code>定制元素</code> <code>封装</code> </p>
<p>这些特性刚好能满足可复用组件的需求，更重要的是，这是由 W3C 标准提供的，面向标准编程不需要再考虑我使用的技术在未来几年内会不会过时。目前社区中的框架大都具有<strong>传染性</strong>，什么是传染性？如果你希望使用一个 React 组件，大概率你的整个用户界面都会使用 React 来开发。而 Custom Elements 不是这样，因为它替代的是 <code>div</code>，能使用 <code>div</code> 的地方就能使用它，它即插即用：引入一个 <code>js</code> 文件就可以了，直接操作 DOM 使它的性能更高，它并不跟社区主流的框架相克，这样看来它更适合用来开发底层的基础组件。</p>
<p>回到正题，这篇文章的目的，是希望总结在 Atag 开发阶段中使用 Web Components 的经验，避免大家踩坑。</p>
<h2 id="基础设施"><a href="#基础设施" class="headerlink" title="基础设施"></a>基础设施</h2><h3 id="webcomponentsjs"><a href="#webcomponentsjs" class="headerlink" title="webcomponentsjs"></a>webcomponentsjs</h3><p><a href="https://github.com/webcomponents/webcomponentsjs" target="_blank" rel="noopener">Github 地址</a></p>
<p>这是一系列 Web Components 规范的 polyfill 集合，如果你的目标用户不是最新的现代浏览器，强烈建议引入这个库。</p>
<p>引用方式 ：</p>
<p>建议在 html 中使用 script 标签引入它，而不是通过 npm 引入，这样浏览器可以使用缓存帮助你减少二次加载的消耗。</p>
<p>(以下引入方式二选一) </p>
<ol>
<li>使用 bundle 整包引入，这样会引入整个库中包含的所有 polyfills。<ul>
<li>如果你需要按需引入 bundle，这个库的 bundles 目录下有一系列预打包好的 bundle 文件，用后缀标明了它包含的功能：ce 表示 custom-elements，sd 表示 shadow-dom，pf 表示环境的 polyfills。</li>
</ul>
</li>
<li>[推荐] 使用 loader 按需引入，引入 <code>webcomponents-loader.js</code> 后，它会根据浏览器中的特征按需加载。</li>
</ol>
<p>这里有必要对一些名词做一些解释：</p>
<ul>
<li>ShadyDOM 这是 Shadow DOM 的 polyfill 的官方名称，它通过劫持 HTMLElement 的原型方法来实现一些 Shadow DOM 节点拥有的功能，实际上它的原理是把节点添加到了真实(light) DOM 节点之上。</li>
<li>ShadyCSS 跟上面一样，这也是 polyfill 的名称，它提供了一些 Shadow DOM 节点内样式的封装，使得可以在真实 DOM 中模拟 scoped style 的效果。它的原理是通过解析和重写 style 节点内部的样式规则来实现的。</li>
</ul>
<p>需要注意的是，在引入 polyfill 的同时，有一些功能是无法被模拟的，需要我们在使用的时候避开，在下文中会介绍到。</p>
<blockquote>
<p>NOTE: 这个库的 2.1.x 版本对 Symbol 的 polyfill 有一些问题，在官方修复之前建议使用 2.0.4 的稳定版本。</p>
<p>这里提供一份 alicdn 的 bundle URL：</p>
<p><code>https://g.alicdn.com/code/npm/@webcomponents/webcomponentsjs/2.0.4/bundles/webcomponents-sd-ce-pf.js</code></p>
</blockquote>
<h3 id="polymer-3"><a href="#polymer-3" class="headerlink" title="polymer 3"></a>polymer 3</h3><p><a href="https://github.com/Polymer/polymer" target="_blank" rel="noopener">Github 地址</a></p>
<p>在 Web Components 的实践中，Polymer 不是必须的，但有了它会让我们轻松很多。强烈建议使用最新版本的 Polymer 3，在这个版本不再使用 html 定义和引入组件，官方推荐使用 JS 模块的方式进行文件组织，同时抛弃了 bower 迎接 npm，这使得很多现代的前端工具能派上用场，比如使用 webpack 和 babel 进行打包，使用 ESLint 对代码进行规则校验，使用 prettier 对代码进行美化等。</p>
<p>安装 polymer 3:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @polymer/polymer --save</span><br></pre></td></tr></table></figure>
<p>官方推荐的 polymer-cli 工具比较鸡肋，可以不用。</p>
<p>在使用之前强烈建议对 <a href="https://www.polymer-project.org/3.0/start/quick-tour" target="_blank" rel="noopener">polymer 的文档</a> 或者本文进行一番了解，避免踩坑。</p>
<h3 id="构建配置"><a href="#构建配置" class="headerlink" title="构建配置"></a>构建配置</h3><p>为什么要把构建配置单独拿出来讲呢，当然是因为有坑?。开发组件过程中 ES 678 已经是标配，运行在低版本浏览器还得依赖 Babel。Web Components 中每一个 Component，对应一个类 (class)。Babel 的转换逻辑如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTag</span> <span class="keyword">extends</span> <span class="title">HTMLElement</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'my-tag'</span>, MyTag);</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'my-tag'</span>);</span><br></pre></td></tr></table></figure>
<p><strong>—&gt;</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> MyTag = <span class="function"><span class="keyword">function</span> (<span class="params">_HTMLElement</span>) </span>&#123;</span><br><span class="line">  _inherits(MyTag, _HTMLElement);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">MyTag</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    _classCallCheck(<span class="keyword">this</span>, MyTag);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _possibleConstructorReturn(<span class="keyword">this</span>, (MyTag.__proto__ || <span class="built_in">Object</span>.getPrototypeOf(MyTag)).apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> MyTag;</span><br><span class="line">&#125;(HTMLElement);</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'my-tag'</span>, MyTag);</span><br><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'my-tag'</span>);</span><br></pre></td></tr></table></figure>
<p>这样执行的话浏览器会显示如下报错 <code>Uncaught TypeError: Failed to construct &#39;HTMLElement&#39;: Please use the &#39;new&#39; operator, this DOM object constructor cannot be called as a function</code>，大意就是被继承的类 HTMLElement 必须使用 new 来初始化，不能使用函数调用 + apply 的使用方式。</p>
<p>针对这个问题 webcomponentsjs 额外提供了一份 <code>custom-elements-es5-adapter-index.js</code> 的 polyfill 来解决，这个文件的具体代码<a href="https://github.com/webcomponents/custom-elements/blob/master/src/native-shim.js" target="_blank" rel="noopener">见此</a>。引入这个文件可以通过在组件库的 webpack 配置中添加或者额外在使用的 html 文件中通过 script 标签引入，只要在组件被注册之前执行这段脚本就可以避免报错。</p>
<h2 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h2><table>
<thead>
<tr>
<th>特性</th>
<th>Import</th>
<th>ShadowDOM</th>
<th>CustomElement</th>
<th>Template</th>
</tr>
</thead>
<tbody>
<tr>
<td>Chrome 最新版 (66)</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Firefox 最新版</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>Y</td>
</tr>
<tr>
<td>iOS 最新版 (12)</td>
<td>N</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>Android (UC 11.6.0.960)</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
</tbody>
</table>
<p>其中 import 特性在整个体系下比较鸡肋，可以通过 webpack 打包的方式来替代。</p>
<p>结论是在移动端下，99% 以上的用户可以通过 polyfill 的方式来获得比较好的 Web Components 特性支持。</p>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><table>
<thead>
<tr>
<th>(单位 ms)</th>
<th>注册 1W 个组件</th>
<th>渲染 1W 个组件</th>
</tr>
</thead>
<tbody>
<tr>
<td>pure web-components</td>
<td>55.5ms  48.6ms 47.2ms</td>
<td>934.3ms  889.0ms  915.1ms</td>
</tr>
<tr>
<td>polymer</td>
<td>184.9ms 191.9ms 197.8ms</td>
<td>768.0ms  858.4ms  785.0ms</td>
</tr>
<tr>
<td>React 16.2.0</td>
<td>38.9ms 38.0ms  40.60ms</td>
<td>1834.8ms 1754.8ms 1869.5ms</td>
</tr>
<tr>
<td>Rax 使用 View 和 Text 组件</td>
<td>86.4ms  73.9ms 82.4ms</td>
<td>11587.4ms  11238.0ms 11289.6ms</td>
</tr>
<tr>
<td>Rax使用 append={‘tree’} 模式</td>
<td>82.5ms  67.3ms 81.4ms</td>
<td>798.0ms  823.5ms  878.0ms</td>
</tr>
</tbody>
</table>
<p>可以看到，由于 React JSX 的 VDOM 在构建时解析的加持，React 的注册时间是最短的，但是放大到 1W 个组件的渲染时，原生 DOM 的性能就发挥出来了，web-components 获得了比较优秀的表现。对原生 web-components 和 polymer，后者只是在注册的时候由于需要在运行时解析模板字符串，牺牲了一些性能，但是如果组件数量有限，这个性能差距可以忽略不计，加上 polymer 本身提供的一些组件化开发的便利，整体来看使用 polymer 获得的收益还是比较高的。</p>
<blockquote>
<p>基准环境:</p>
<ul>
<li>Chrome 66</li>
<li>macOS 10.13.1</li>
<li>Macbook Pro 15’ late 2015</li>
</ul>
</blockquote>
<h2 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h2><p>个人认为，Web Components 在整个前端的语境下更偏向于提供符合 DOM 标准的规范，而 Polymer 则是在这种规范之上的一种框架封装，使用 Polymer 可以带来更便利的组件化开发体验。因此这里就不多介绍如何使用标准的 custom element 来创建自定义标签，下文都使用 Polymer 来封装自定义标签。文章中的组件、自定义标签、自定义组件其实描述的是同一个东西。</p>
<p>推荐使用以下模式创建一个自定义组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PolymerElement, html &#125; <span class="keyword">from</span> <span class="string">'@polymer/polymer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomElement</span> <span class="keyword">extends</span> <span class="title">PolymerElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> is() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'custom-element'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> template() &#123;</span><br><span class="line">    <span class="keyword">return</span> html<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;style&gt;:host &#123; color: red; &#125;&lt;/style&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用以下方式注册自定义组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">customElements.define(CustomElement.is, CustomElement);</span><br></pre></td></tr></table></figure>
<p>使用以下或任意方式使用自定义组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'custom-element'</span>);</span><br><span class="line">el.innerText = <span class="string">'Hello World'</span>;</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(el);</span><br></pre></td></tr></table></figure>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>PolymerElement 继承了 HTMLElement，所以它拥有和 HTMLElement 一致的生命周期。</p>
<p><strong>constructor</strong>：组件被 create 的时候会被调用，整个生命周期中最早触发也只会触发一次，通常可以在这里做一些初始化私有变量、记录数据的一些操作；但是出于性能和职责分离的考虑，不建议在这里做一些 DOM 相关的事情。</p>
<p><strong>connectedCallback</strong>：组件被 <code>连接</code> 到 DOM Tree 的时候会触发，这个时机包括节点被插入节点树、节点被从节点树中移动，所以它可能会被触发多次。你可以在这里监听 DOM 事件或者对 DOM 节点做一些修改。</p>
<p><strong>disconnectedCallback</strong>：组件被从 DOM Tree 中移除的时候触发，这个生命周期也可能被触发多次。如果你在 connectedCallback 中监听了事件，一定要记得在这里移除，否则事件监听回调可能会一直引用导致内存泄露和一些奇怪的问题。</p>
<p><strong>adoptedCallback</strong>：不常用，不多介绍。</p>
<p><strong>attributeChangedCallback</strong>：当组件的 attribute 发生变化的时候触发，它的三个形参分别是 <code>name, oldValue, newValue</code>，记得别把顺序搞反了。如果你声明了 properties 对象，对 attribute 的相应值变化也会触发这个回调。需要注意的是，如果你覆盖了组件的 <code>observedAttributes</code> 静态方法，properties 对象中声明的值不会触发，它会按照你覆盖的 <code>observedAttributes</code> 静态方法的返回值为准。</p>
<p>除此之外，polymer 还额外添加了一些生命周期</p>
<p><strong>ready</strong>：由于 HTMLElement 的生命周期中没有一个可以操作 DOM，又只触发一次的周期，Polymer 人为地添加了 ready 这个时机，它在整个生命周期中只会触发一次，也就是第一次节点插入到 DOM 树的时刻。</p>
<p>记得调用 <code>super.ready()</code> 来触发 <code>PolymerElement</code> 的初始化阶段。在初始化阶段，Polymer 会做以下几件事情：</p>
<ul>
<li>attache 组件实例的 Shadow DOM，所以在这个阶段之后才可以访问 <code>this.shadowRoot</code></li>
<li>初始化 properties，并赋初始值</li>
<li>如果 properties 有声明 observer 或者 computed，会执行它们</li>
</ul>
<p>通常可以在 ready 函数中给组件实例添加一个 <code>this._isReady = true;</code> 的状态以标明组件已经 ready。</p>
<h4 id="首屏性能优化技巧"><a href="#首屏性能优化技巧" class="headerlink" title="首屏性能优化技巧"></a>首屏性能优化技巧</h4><p>我们知道页面的首屏渲染直接影响了这个页面的性能，组件也是一样。Polymer 提供了 render-status 的 afterNextRender 方法来帮助你在首次渲染之后执行一些不必要的 DOM 操作，比如添加事件绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; afterNextRender &#125; <span class="keyword">from</span> <span class="string">'@polymer/polymer/lib/utils/render-status'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DeferElement</span> <span class="keyword">extends</span> <span class="title">PolymerElement</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  ready() &#123;</span><br><span class="line">    <span class="keyword">super</span>.ready();</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// When possible, use afterNextRender to defer non-critical</span></span><br><span class="line">    <span class="comment">// work until after first paint.</span></span><br><span class="line">    afterNextRender(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>._handleClick);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="属性-property-和属性-attribute"><a href="#属性-property-和属性-attribute" class="headerlink" title="属性 (property)和属性 (attribute)"></a>属性 (property)和属性 (attribute)</h2><p>在 DOM 中，property 和 attribute 这两个概念是严格区分的，虽然有时它们会产生类似双向绑定的联动，例如 id、input 的 checked 属性等。</p>
<p>在 Polymer 中，使用 properties 静态属性来声明组件的 property：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XCustom</span> <span class="keyword">extends</span> <span class="title">PolymerElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> properties() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      user: <span class="built_in">String</span>,</span><br><span class="line">      isHappy: <span class="built_in">Boolean</span>,</span><br><span class="line">      count: &#123;</span><br><span class="line">        type: <span class="built_in">Number</span>,</span><br><span class="line">        readOnly: <span class="literal">true</span>,</span><br><span class="line">        notify: <span class="literal">true</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">customElements.define(<span class="string">'x-custom'</span>, XCustom);</span><br></pre></td></tr></table></figure>
<p>在大多数情况下，如果你的属性需要暴露为公有 (public) API，你需要把这个属性声明到 properties 对象中。</p>
<p>关于 properties 对象的声明，可以参考<a href="https://www.polymer-project.org/3.0/docs/devguide/properties" target="_blank" rel="noopener">文档</a></p>
<h3 id="属性的默认值"><a href="#属性的默认值" class="headerlink" title="属性的默认值"></a>属性的默认值</h3><p>通过 property 的 value 可以设置属性的默认值，这里<strong>强烈建议</strong>所有的属性都显式声明一个默认值，这样更清晰于阅读，也避免了默认为 undefined 值处理的坑。</p>
<p>如果声明的 value 是一个函数，Polymer 会在初始化这个组件的时候取函数的返回值为默认属性；如果 value 是一个对象或数组，Polymer 会在初始化这个组件的时候对 value 做一次浅拷贝，所以不用担心会在不同组件实例中会共享同一个对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomEl</span> <span class="keyword">extends</span> <span class="title">PolymerElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> properties() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      mode: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        value: <span class="string">'auto'</span></span><br><span class="line">      &#125;,</span><br><span class="line"></span><br><span class="line">      data: &#123;</span><br><span class="line">        type: <span class="built_in">Object</span>,</span><br><span class="line">        notify: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> &#123;&#125;; &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="attribute-映射为-property"><a href="#attribute-映射为-property" class="headerlink" title="attribute 映射为 property"></a>attribute 映射为 property</h3><p>在 properties 对象中声明的属性，polymer 会自动创建从 attribute 到 perperty 的映射解析规则，解析的规则是：</p>
<ul>
<li>大写的 attribute 名称会被转换为小写的 property：<code>firstName</code> 映射为 <code>firstname</code></li>
<li>带中划线 <code>-</code>的 attribute 名会被转换为小驼峰 (camelCased) 的 property：<code>first-name</code> 映射为 <code>firstName</code></li>
</ul>
<p>值的解析会使用声明的类型去判断和解析，对于 JS 基本类型的值，会直接转换类型映射；对于 Object 和 Array 类型，会通过 <code>JSON.parse</code> 来解析。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;my-element id=<span class="string">"foo"</span> book=<span class="string">'&#123; "title": "Persuasion", "author": "Austen" &#125;'</span>&gt;&lt;/my-element&gt;</span><br></pre></td></tr></table></figure>
<p>由于 JSON 的序列化和反序列化会比较消耗性能，而且我们从数据源获取数据后一般已经是 JS Object，这个时候通过 property 赋值的方式来使用 Object/Array 类型的数据可以避免额外的性能消耗。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.querySelector(<span class="string">'#foo'</span>);</span><br><span class="line">el.book = &#123; <span class="attr">title</span>: <span class="string">'Persuasion'</span>, <span class="attr">author</span>: <span class="string">'Austen'</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>关于布尔值，我们在 React 中习惯于显式传递布尔值 <code>&lt;Checkbox checked={false} /&gt;</code> ，但在 DOM 中，attribute 判断布尔类型的方式是判断 attribute value 字符串的长度。<code>&lt;a-checkbox checked /&gt; &lt;a-checkbox checked=&quot;false&quot;&gt;</code> 前面这些都表示 checked 为 true，而只有 <code>&lt;a-checkbox  /&gt;</code> 才表示 checked 为 false。</p>
<p>所以对于布尔值，这里建议在使用时跟对象一样，使用 property 赋值的方式去修改，避免使用 setAttribute 修改布尔类型的属性。如果你希望修改 checked attribute 的语义，在为字符串 “false” 的时候表示真正的 false 概念，你也可以声明一个 getter 来帮助你在内部做判断，但是其实我不建议这么做。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> <span class="title">extend</span> <span class="title">PolymerElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">get</span> _isLoop() &#123;</span><br><span class="line">        <span class="keyword">var</span> loop = <span class="keyword">this</span>.getAttribute(<span class="string">'loop'</span>);</span><br><span class="line">        <span class="keyword">return</span> loop !== <span class="string">'false'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="property-映射为-attribute"><a href="#property-映射为-attribute" class="headerlink" title="property 映射为 attribute"></a>property 映射为 attribute</h3><p>双向绑定不是必须的。</p>
<p>通过开启 <code>reflectToAttribute: true</code> 选项可以自动把 property 映射为 attribute 值，序列化的方式跟上边正好相反。由于涉及到 setAttribute 这一 DOM 操作，开启这个功能是比较消耗性能的，仅在必要的时候开启。</p>
<p>使用的例子如 <code>radio</code> 、<code>checkbox</code> 组件的 <code>checked</code> 属性，<code>image</code> 组件的 <code>src</code> 属性等。</p>
<h3 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h3><p>跟 Vue 的 computed 很像 (其实是 Vue 参考了这里)，计算属性允许你用一个方法来计算 property 的值。</p>
<h3 id="观察属性"><a href="#观察属性" class="headerlink" title="观察属性"></a>观察属性</h3><p>跟 Vue 的 watch 很像，当你的属性发生变化时，polymer 会通知相应的函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XCustom</span> <span class="keyword">extends</span> <span class="title">PolymerElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> properties() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      active: &#123;</span><br><span class="line">        type: <span class="built_in">Boolean</span>,</span><br><span class="line">        <span class="comment">// Observer method identified by name</span></span><br><span class="line">        observer: <span class="string">'_activeChanged'</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Observer method defined as a class method</span></span><br><span class="line">  _activeChanged(newValue, oldValue) &#123;</span><br><span class="line">    <span class="keyword">this</span>.toggleClass(<span class="string">'highlight'</span>, newValue);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="观察-children-的变化"><a href="#观察-children-的变化" class="headerlink" title="观察 children 的变化"></a>观察 children 的变化</h2><p>有时候我们需要观察 children 节点的添加或者删除，比如在 <a href="https://developers.taobao.com/components/container/swiper.html" target="_blank" rel="noopener"><code>swiper</code> 组件</a>中，它需要动态地监听子节点中 <code>swiper-item</code> 节点的增删改，来变化其内部的 <code>indicator-dots</code> 数量等。</p>
<p>Polymer 提供了 FlattenedNodesObserver 工具集合来追踪子孙节点的变化。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; FlattenedNodesObserver &#125; <span class="keyword">from</span> <span class="string">'@polymer/polymer/lib/utils/flattened-nodes-observer'</span>;</span><br></pre></td></tr></table></figure>
<p>添加监听器，每当子节点发生变化的时候会触发对应的回调函数，回调函数的第一个参数包含了一些增加或者删除节点的信息可以使用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._childrenObserver = <span class="keyword">new</span> FlattenedNodesObserver(<span class="keyword">this</span>, <span class="keyword">this</span>._handleChildrenChanged);</span><br></pre></td></tr></table></figure>
<p>当然不要忘记移除监听器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>._childrenObserver.disconnect();</span><br></pre></td></tr></table></figure>
<p>获取子孙节点的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FlattenedNodesObserver.getFlattenedNodes(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h2 id="模板语法"><a href="#模板语法" class="headerlink" title="模板语法"></a>模板语法</h2><p>Polymer 使用 <code>html</code> 方法来把模板字符串转换成一个 DOM fragment，并可以自由绑定组件实例上下文中的属性。</p>
<h3 id="创建-Shadow-DOM"><a href="#创建-Shadow-DOM" class="headerlink" title="创建 Shadow DOM"></a>创建 Shadow DOM</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PolymerElement, html &#125; <span class="keyword">from</span> <span class="string">'@polymer/polymer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomElement</span> <span class="keyword">extends</span> <span class="title">PolymerElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> is() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'custom-element'</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> template() &#123;</span><br><span class="line">    <span class="keyword">return</span> html<span class="string">`</span></span><br><span class="line"><span class="string">      &lt;style&gt;:host &#123; color: red; &#125;&lt;/style&gt;</span></span><br><span class="line"><span class="string">      &lt;slot&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>slot</code> 表示该组件子节点的引用，跟 Vue 的 slot 师出同门，对应 React 的 <code>this.props.children</code> 的概念。</p>
<p>需要注意的是反引号语法在这里其实等价于 <code>html(templateString)</code>，但是不要试图在模板字符串中使用插值，至于原因你可以参考阮老师的 <a href="http://es6.ruanyifeng.com/#docs/string#%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF" target="_blank" rel="noopener">ES6 参考</a>。</p>
<h3 id="创建-Light-DOM"><a href="#创建-Light-DOM" class="headerlink" title="创建 Light DOM"></a>创建 Light DOM</h3><p>有时候由于 Shadow DOM 的一些限制，它并不能满足所有组件的需求，我们可能需要创建一个拥有真实节点的自定义标签组件。</p>
<p>跟普通的 DOM 操作一样，如果你需要创建真实节点(light dom)，直接在 constructor 生命周期中使用 DOM 方法创建并添加到节点的 children 中即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PolymerElement, html &#125; <span class="keyword">from</span> <span class="string">'@polymer/polymer'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomElement</span> <span class="keyword">extends</span> <span class="title">PolymerElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> is() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'custom-element'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">        container.innerHTML = <span class="string">'Hello World'</span>;</span><br><span class="line">        <span class="keyword">this</span>.appendChild(container);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>详细参考 <a href="https://www.polymer-project.org/3.0/docs/devguide/dom-template" target="_blank" rel="noopener">https://www.polymer-project.org/3.0/docs/devguide/dom-template</a></p>
</blockquote>
<h3 id="公私有方法和属性的命名约定"><a href="#公私有方法和属性的命名约定" class="headerlink" title="公私有方法和属性的命名约定"></a>公私有方法和属性的命名约定</h3><p>这是一个建议，但是 W3C 标准中的方法大多遵守这一约定。除生命周期方法外，组件的实例属性和实例方法会被视作外部接口，可被外部直接访问到。所以如果是私有的属性和方法，需要加上 <code>_</code> 作为前缀以作区分。如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVideo</span> <span class="keyword">extends</span> <span class="title">PolymerElement</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">get</span> properties() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 作为接口暴露的属性</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      status: &#123;</span><br><span class="line">        type: <span class="built_in">String</span>,</span><br><span class="line">        value: <span class="string">'paused'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  connectedCallback() &#123;</span><br><span class="line">    <span class="keyword">this</span>.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>._handleClick);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 私有方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  _handleClick(evt) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 作为接口暴露的方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  play() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> video = <span class="built_in">document</span>.createElement(<span class="string">'my-video'</span>);</span><br><span class="line">video.play(); <span class="comment">// 使用暴露的接口方法</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Polymer 官方建议使用 <code>_</code> 前缀表示私有变量，<code>__</code> 前缀表示受保护的变量，个人以为这种区分太过复杂，建议用一个 <code>_</code> 来替代就可以了。</p>
</blockquote>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>这里的事件指的都是 DOM 事件，你可以通过模板事件监听或者 DOM 事件监听两种方式来绑定事件。前者是声明式的而且不需要处理解除绑定，所以更加推荐使用模板事件监听器的方式来绑定事件。</p>
<h3 id="模板事件监听器"><a href="#模板事件监听器" class="headerlink" title="模板事件监听器"></a>模板事件监听器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">get</span> template()&#123;</span><br><span class="line">  <span class="keyword">return</span> html<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;button on-click="handleClick"&gt;Click Me&lt;/button&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 handleClick 指的是实例方法，其它就跟直接绑定 <code>onclick</code> 事件没什么差别。</p>
<h3 id="DOM-事件监听器"><a href="#DOM-事件监听器" class="headerlink" title="DOM 事件监听器"></a>DOM 事件监听器</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connectedCallback() &#123;</span><br><span class="line">  <span class="keyword">super</span>.connectedCallback()</span><br><span class="line">  <span class="keyword">this</span>.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>._handleClick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不要忘记在 disconnectedCallback 的时候解除绑定</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">disconnectedCallback() &#123;</span><br><span class="line">  <span class="keyword">super</span>.disconnectedCallback()</span><br><span class="line">  <span class="keyword">this</span>.removeEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>._handleClick);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有一种情况下你必须使用 DOM 事件监听器：你希望监听的事件节点不在 ShadowDOM 中，例如使用 window 或者 document 对象代理监听事件等。</p>
<h3 id="关于冒泡"><a href="#关于冒泡" class="headerlink" title="关于冒泡"></a>关于冒泡</h3><p>slot 子节点的冒泡，在 ShadowDOM 中，slot 子节点是出现在影子节点树内部的，所以它冒泡事件传递顺序会包含 slot 节点，在 polyfill 的实现中并不是这样，所以不要依赖这一项来实现一些功能。</p>
<h3 id="触发自定义事件"><a href="#触发自定义事件" class="headerlink" title="触发自定义事件"></a>触发自定义事件</h3><p>有时候组件可能希望在事件中带入一些额外的 <code>detail</code> 信息。如果你的事件名称与 DOM 事件不同名，直接使用 Custom Event 的接口声明和派发即可。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myEvent = <span class="keyword">new</span> CustomEvent(<span class="string">'myevent'</span>, &#123;</span><br><span class="line">  bubbles: <span class="literal">true</span>,</span><br><span class="line">  datail: &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">this</span>.dispatchEvent(myEvent);</span><br></pre></td></tr></table></figure>
<p>如果你的事件名称与 DOM 事件同名，原生 DOM 事件可不支持修改，但是你可以在它冒泡的时候阻止它并派发一个自己的同名事件出来。</p>
<p>在 <code>window</code> 上捕获你需要拦截的事件，并在事件处理回调中停止冒泡原生事件和派发一个自定义的同名事件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">connectedCallback() &#123;</span><br><span class="line">  <span class="keyword">super</span>.connectedCallback();</span><br><span class="line">  afterNextRender(<span class="keyword">this</span>, () =&gt; &#123;</span><br><span class="line">  	<span class="built_in">window</span>.addEventListener(<span class="string">'click'</span>, <span class="keyword">this</span>._handleClick, <span class="literal">true</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_handleClick(evt) &#123;</span><br><span class="line">  evt.stopPropagation();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> event = <span class="keyword">new</span> CustomEvent(<span class="string">'click'</span>, &#123;</span><br><span class="line">    bubbles: <span class="literal">true</span>,</span><br><span class="line">    detail: &#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">this</span>.dispatchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="手势"><a href="#手势" class="headerlink" title="手势"></a>手势</h2><p>在移动端中手势的处理可以说是比较常用的功能，我们可以通过监听 <code>touchstart</code> <code>touchmove</code> <code>touchend</code> <code>touchacancel</code> 事件并合成处理几乎所有的复杂交互。Polymer 为组件开发者提供了 <code>Gesture</code> 工具库，你可以按需地引入它：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> Gestures <span class="keyword">from</span> <span class="string">'@polymer/polymer/lib/utils/gestures'</span>;</span><br></pre></td></tr></table></figure>
<p>它提供了很多合成事件的封装，比如在 ATAG 中，swiper 轮播器组件就使用到了 track 合成事件。</p>
<p>在 ready 的时刻添加 track 事件的监听，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ready() &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  Gestures.addListener(<span class="keyword">this</span>, <span class="string">'track'</span>, <span class="keyword">this</span>._handleTrack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_handleTrack(e) &#123;</span><br><span class="line">  <span class="keyword">const</span> detail = e.detail;</span><br><span class="line">  <span class="keyword">if</span> (detail.state === <span class="string">'start'</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> dx = detail.dx;</span><br><span class="line">    <span class="keyword">const</span> dy = detail.dy;</span><br><span class="line">    <span class="keyword">const</span> direction = <span class="built_in">Math</span>.abs(dy) - <span class="built_in">Math</span>.abs(dx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.vertical &amp;&amp; direction &lt; <span class="number">0</span> || <span class="keyword">this</span>.vertical &amp;&amp; direction &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._onTouchStart(detail);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>track 使你追踪手指滑动的过程和方向。</p>
<p>有时候你需要考虑横向滚动和纵向滚动之间的关系，比如在横向滚动 swiper 轮播器的时候，通常并不希望同时触发纵向的页面滚动，这个时候就需要在开始内部滚动的时候为组件添加一个拖动的状态，在拖动状态中的 <code>touchmove</code> 事件需要被执行 <code>preventDefault</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">_handleSwiperTouchMove = <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// Prevent scrolling in swipper when user is dragging</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.dragging) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外在 Polymer 监听 track 事件的时候，组件本身的 <code>touch-action</code> CSS 属性会被置为 <code>none</code>，这是一个 Chrome 下已经支持的属性，当为 <code>none</code> 时组件不向上传递触摸事件和阻止默认事件，跟 <code>preventDefault</code> 的效果一致。所以如果你需要响应滚动事件，可以参考以下方法自定义 <code>touch-action</code> 的值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">NOTE:</span> if swiper direction is different with parent</span></span><br><span class="line"><span class="comment"> * scroll view direction, set touch-action to pan-x if vertically,</span></span><br><span class="line"><span class="comment"> * to pan-y if not.</span></span><br><span class="line"><span class="comment"> * Excepted case: if parent scroll element is the whole page (body)</span></span><br><span class="line"><span class="comment"> * and the swiper's scroll direction is vertical, set touch action</span></span><br><span class="line"><span class="comment"> * to none to avoid double scrolling.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">_observeVertical() &#123;</span><br><span class="line">  afterNextRender(<span class="keyword">this</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> parentScrollView = <span class="keyword">this</span>._getParentScrollView();</span><br><span class="line">    <span class="keyword">const</span> parentScrollVertical = !(</span><br><span class="line">      parentScrollView &amp;&amp; parentScrollView.scrollX</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.vertical &amp;&amp; parentScrollView === <span class="literal">null</span>) &#123;</span><br><span class="line">      Gestures.setTouchAction(<span class="keyword">this</span>, <span class="string">'none'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.vertical === parentScrollVertical) &#123;</span><br><span class="line">      Gestures.setTouchAction(<span class="keyword">this</span>, <span class="string">'auto'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Gestures.setTouchAction(<span class="keyword">this</span>, <span class="keyword">this</span>.vertical ? <span class="string">'pan-x'</span> : <span class="string">'pan-y'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>NOTE: </p>
<ul>
<li><p>更多详细的手势使用可以<a href="https://www.polymer-project.org/3.0/docs/devguide/gesture-events" target="_blank" rel="noopener">参考这里</a></p>
</li>
<li><p>touch-action 的 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/touch-action" target="_blank" rel="noopener">MDN 文档</a></p>
</li>
</ul>
</blockquote>
<h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><p>使用 Polymer 的 template 方法创建的 customElement 默认是 Shadow DOM，Shadow DOM 内的样式是局部作用域的，也就是说内部的样式不会影响全局。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">get</span> template() &#123;</span><br><span class="line">  <span class="keyword">return</span> html<span class="string">`</span></span><br><span class="line"><span class="string">    &lt;style&gt;</span></span><br><span class="line"><span class="string">      :host &#123;</span></span><br><span class="line"><span class="string">        display: inline-block;</span></span><br><span class="line"><span class="string">        background-color: #fff;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">      #input &#123;</span></span><br><span class="line"><span class="string">        all: unset;</span></span><br><span class="line"><span class="string">        width: 100%;</span></span><br><span class="line"><span class="string">        height: 100%;</span></span><br><span class="line"><span class="string">        -webkit-text-fill-color: initial;</span></span><br><span class="line"><span class="string">        -webkit-user-select: auto;</span></span><br><span class="line"><span class="string">        user-select: auto;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &lt;/style&gt;</span></span><br><span class="line"><span class="string">    &lt;input id="input" /&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="避免动态修改-style-标签来应用样式"><a href="#避免动态修改-style-标签来应用样式" class="headerlink" title="避免动态修改 style 标签来应用样式"></a>避免动态修改 style 标签来应用样式</h3><p>对于 Shadow DOM 内部的样式，ShadyCSS 会解析和重写以正确地作用到真实节点上，所以如果你的组件内部有动态创建或者写 style 标签的 innerHTML 属性，这些都不会被 ShadyCSS 作用到，应当避免。</p>
<p>如果实在无法避免，我在使用的过程中使用了一种 HACK 的手段：</p>
<ul>
<li>给每一个组件添加一个 uid 的标识来区分组件实例，并带到组件的 data-id attribute 上面</li>
<li>在写 CSS 的时候通过 [data-id=xxx] 选择符来区分</li>
<li>这种方式你需要同时写 :host {} 和 my-element[data-id=xxx]{} 两个 CSS 选择符来保证同时非 polyfill 情况下和 polyfill 情况下都能工作</li>
<li>由于对 ShadyCSS 的源码研究还不够，可能还有更好的办法，如果你有的话也请在下边评论指教~~</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>一个健壮的基础应用必须有响应的测试机制来保障，一般一款软件的稳定性跟它的测试代码/应用代码的比例正相关。DOM 相关的 UI 测试在前几年一直有着不错的发展，比如截图对比测试，Driver 服务化等，但是真正被大规模使用的寥寥。本着实用至上的原则，Atag 的测试分为自动化的冒烟测试和手动的 UI 测试。</p>
<h3 id="冒烟测试"><a href="#冒烟测试" class="headerlink" title="冒烟测试"></a>冒烟测试</h3><p>顾名思义，就是渲染一个组件，看看有没有报错或者渲染异常，进行一些简单的 DOM 渲染判断。这里我们用到了 Karma + puppteer 的搭配，如果你想验证浏览器兼容性的差异也可以加入更多的 karma-driver。</p>
<p>karma 配置文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpackConfig = <span class="built_in">require</span>(<span class="string">'./tests/webpack.test.js'</span>);</span><br><span class="line">process.env.CHROME_BIN = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>).executablePath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// karma.conf.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config.set(&#123;</span><br><span class="line">    browsers: [<span class="string">'ChromeHeadless'</span>],</span><br><span class="line">    frameworks: [<span class="string">'mocha'</span>, <span class="string">'sinon-chai'</span>],</span><br><span class="line">    reporters: [<span class="string">'spec'</span>, <span class="string">'coverage'</span>],</span><br><span class="line">    files: [<span class="string">'vendors/custom-elements-es5-adapter.js'</span>, <span class="string">'tests/index.js'</span>],</span><br><span class="line"></span><br><span class="line">    preprocessors: &#123;</span><br><span class="line">      <span class="string">'./tests/index.js'</span>: [<span class="string">'webpack'</span>, <span class="string">'sourcemap'</span>]</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    webpack: webpackConfig,</span><br><span class="line"></span><br><span class="line">    webpackMiddleware: &#123;</span><br><span class="line">      stats: <span class="string">'errors-only'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    coverageReporter: &#123;</span><br><span class="line">      dir: <span class="string">'./coverage'</span>,</span><br><span class="line">      reporters: [&#123; <span class="attr">type</span>: <span class="string">'html'</span> &#125;, &#123; <span class="attr">type</span>: <span class="string">'text'</span> &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>tests/index.js：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// require all src files except main.js for coverage.</span></span><br><span class="line"><span class="comment">// you can also change this to match only the subset of files that</span></span><br><span class="line"><span class="comment">// you want coverage for.</span></span><br><span class="line"><span class="keyword">const</span> srcContext = <span class="built_in">require</span>.context(<span class="string">'../src'</span>, <span class="literal">true</span>, /^\.\/(?!index(\.js)?$)/);</span><br><span class="line">srcContext.keys().forEach(srcContext);</span><br><span class="line"></span><br><span class="line"><span class="comment">// require all test files (files that ends with .spec.js)</span></span><br><span class="line"><span class="keyword">const</span> testsContext = <span class="built_in">require</span>.context(<span class="string">'./specs'</span>, <span class="literal">true</span>, /\.spec$/);</span><br><span class="line">testsContext.keys().forEach(testsContext);</span><br></pre></td></tr></table></figure>
<p>一个简单的测试用例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> SOURCE =</span><br><span class="line">  <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">'&lt;a-audio&gt;'</span>, () =&gt; &#123;</span><br><span class="line">  it(<span class="string">'should render a-audio'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="string">'a-audio'</span>);</span><br><span class="line">    el.setAttribute(<span class="string">'src'</span>, SOURCE);</span><br><span class="line">    el.setAttribute(<span class="string">'autoplay'</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(el);</span><br><span class="line">    expect(el).to.not.be.an.instanceOf(HTMLUnknownElement);</span><br><span class="line">    expect(getComputedStyle(el).display).to.equal(<span class="string">'block'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="UI-测试"><a href="#UI-测试" class="headerlink" title="UI 测试"></a>UI 测试</h3><p>真正功能性的测试依旧是通过组件例子的方式来验证，因为很多富交互的组件用例很难通过单元测试的方式书写。有了 UI 测试用例，很多可视的元素效果能一目了然；当然你也可以使用一些针对 DOM 编程的测试框架。</p>
<blockquote>
<p>这个是 Atag 的 <a href="https://github.com/alibaba/rax/blob/master/packages/atag/demo/index.htm" target="_blank" rel="noopener">UI 测试用例</a>。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://github.com/alibaba/rax/tree/master/packages/atag" target="_blank" rel="noopener">ATAG</a></li>
<li><a href="https://developers.taobao.com/components/" target="_blank" rel="noopener">淘宝小程序组件文档</a></li>
<li><a href="http://w3c.github.io/webcomponents/" target="_blank" rel="noopener">W3C Web Components Specs</a></li>
<li><a href="https://polymer-project.org" target="_blank" rel="noopener">Polymer Project</a></li>
<li><a href="https://www.webcomponents.org/" target="_blank" rel="noopener">Web Components.org</a></li>
<li><a href="https://github.com/polymer" target="_blank" rel="noopener">Github@Polymer</a></li>
<li><a href="https://github.com/webcomponents" target="_blank" rel="noopener">Github@WebComponents</a></li>
</ul>
<blockquote>
<p>题图出处 <a href="https://www.webcomponents.org/community/articles/why-web-components" target="_blank" rel="noopener">https://www.webcomponents.org/community/articles/why-web-components</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1Q3Y4l4TpK1RjSZFGXXcHqFXa-900-500.jpg" alt="Atag - Web Components 最佳实践"></p>
<h2 id="引子"><a href="#]]>
    </summary>
    
      <category term="小程序" scheme="http://taobaofed.org/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
      <category term="web-components" scheme="http://taobaofed.org/tags/web-components/"/>
    
      <category term="Polymer" scheme="http://taobaofed.org/tags/Polymer/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Workbox 3：Service Worker 可以如此简单]]></title>
    <link href="http://taobaofed.org/blog/2018/08/08/workbox3/"/>
    <id>http://taobaofed.org/blog/2018/08/08/workbox3/</id>
    <published>2018-08-08T08:35:49.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB19EDcJMmTBuNjy1XbXXaMrVXa-900-500.jpg" alt="Workbox 3：Service Worker 可以如此简单"></p>
<p>如果你追求极致的 Web 体验，你一定在站点中使用过 PWA，也一定面临过在编写 Service Worker 代码时的犹豫不决，因为 Service Worker 太重要了，一旦注册在用户的浏览器，全站的请求都会被 Service Worker 控制，一不留神，小问题也成了大问题了。不过到了现在有了 Workbox 3，一切关于 Service Worker 的担心都不再是问题。</p>
<h2 id="科普-Service-Worker"><a href="#科普-Service-Worker" class="headerlink" title="科普 Service Worker"></a>科普 Service Worker</h2><p>如果你已经熟悉 Service Worker，可以跳过此段。</p>
<p>Service Worker 是 PWA 中重要的一部分，它是一个网站安插在用户浏览器中的大脑。Service Worker 是这样被注册在页面上的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'serviceWorker'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  navigator.serviceWorker.register(<span class="string">'/sw.js'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么说 SW（下文将 Service Worker 简称为 SW）是网站的大脑？举个例子，如果在 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 的根路径下注册了一个 SW，那么这个 SW 将可以控制所有该浏览器向 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 站点发起的请求。只需要监听 fetch 事件，你就可以任意的操纵请求，可以返回从 CacheStorage 中读的数据，也可以通过 Fetch API 发起新的请求，甚至可以 new 一个 Response，返回给页面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一段糟糕的 SW 代码，在这个 SW 注册好以后，整个 SW 控制站点的所有请求返回的都将是字符串 "bad"，包括页面的 HTML</span></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.respondWith(</span><br><span class="line">    <span class="keyword">new</span> Response(<span class="string">'bad'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>就是因为 SW 权利太大了，写起来才会如履薄冰，一不小心有些页面资源就不能及时正确的更新了。</p>
<h3 id="一个还算完整的-Service-Worker-示例"><a href="#一个还算完整的-Service-Worker-示例" class="headerlink" title="一个还算完整的 Service Worker 示例"></a>一个还算完整的 Service Worker 示例</h3><p>先来看一个直接手写的 SW 文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cacheStorageKey = <span class="string">'cachesName'</span>;</span><br><span class="line"><span class="keyword">var</span> cacheList = [</span><br><span class="line">  <span class="comment">// 注册成功后要立即缓存的资源列表</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当浏览器解析完 SW 文件时触发 install 事件</span></span><br><span class="line">self.addEventListener(<span class="string">'install'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// install 事件中一般会将 cacheList 中要换存的内容通过 addAll 方法，请求一遍放入 caches 中</span></span><br><span class="line">  e.waitUntil(</span><br><span class="line">    caches.open(cacheStorageKey).then(<span class="function"><span class="keyword">function</span>(<span class="params">cache</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> cache.addAll(cacheList)</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 激活时触发 activate 事件</span></span><br><span class="line">self.addEventListener(<span class="string">'activate'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// active 事件中通常做一些过期资源释放的工作，匹配到就从 caches 中删除</span></span><br><span class="line">  <span class="keyword">var</span> cacheDeletePromises = caches.keys().then(<span class="function"><span class="params">cacheNames</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.all(cacheNames.map(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (name !== cacheStorageKey) &#123;</span><br><span class="line">        <span class="keyword">return</span> caches.delete(name);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  e.waitUntil(</span><br><span class="line">    <span class="built_in">Promise</span>.all([cacheDeletePromises])</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">self.addEventListener(<span class="string">'fetch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 在此编写缓存策略</span></span><br><span class="line">  e.respondWith(</span><br><span class="line">    <span class="comment">// 可以通过匹配缓存中的资源返回</span></span><br><span class="line">    caches.match(e.request)</span><br><span class="line">    <span class="comment">// 也可以从远端拉取</span></span><br><span class="line">    fetch(e.request.url)</span><br><span class="line">    <span class="comment">// 也可以自己造</span></span><br><span class="line">    <span class="keyword">new</span> Response(<span class="string">'自己造'</span>)</span><br><span class="line">    <span class="comment">// 也可以通过吧 fetch 拿到的响应通过 caches.put 方法放进 caches</span></span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>其实所有站点 SW 的 install 和 active 都差不多，无非是做预缓存资源列表，更新后缓存清理的工作，逻辑不太复杂，而重点在于 fetch 事件。上面的代码，我把 fetch 事件的逻辑省略了，因为如果认真写的话，太多了，而且也不利于讲明白缓存策略这件事。想象一下，你需要根据不同文件的扩展名把不同的资源通过不同的策略缓存在 caches 中，各种 CSS，JS，HTML，图片，都需要单独搞一套缓存策略，你就知道 fetch 中需要写多少东西了吧。</p>
<h2 id="Workbox-3"><a href="#Workbox-3" class="headerlink" title="Workbox 3"></a>Workbox 3</h2><p>Workbox 的出现就是为了解决上面的问题的，它被定义为 PWA 相关的工具集合，其实围绕它的还有一些列工具，如 workbox-cli、gulp-workbox、webpack-workbox-plagin 等等，不过他们都不是今天的重点，今天想聊的就是 Workbox 本身。</p>
<p>其实可以把 Workbox 理解为 Google 官方的 PWA 框架，它解决的就是用底层 API 写 PWA 太过复杂的问题。这里说的底层 API，指的就是去监听 SW 的 install、active、 fetch 事件做相应逻辑处理等。使用起来是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先引入 Workbox 框架</span></span><br><span class="line">importScripts(<span class="string">'https://storage.googleapis.com/workbox-cdn/releases/3.3.0/workbox-sw.js'</span>);</span><br><span class="line">workbox.precaching([</span><br><span class="line">  <span class="comment">// 注册成功后要立即缓存的资源列表</span></span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// html的缓存策略</span></span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">''</span>.*\.html<span class="string">'),</span></span><br><span class="line"><span class="string">  workbox.strategies.networkFirst()</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">workbox.routing.registerRoute(</span></span><br><span class="line"><span class="string">  new RegExp('</span>.*\.(?:js|css)<span class="string">'),</span></span><br><span class="line"><span class="string">  workbox.strategies.cacheFirst()</span></span><br><span class="line"><span class="string">);</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">workbox.routing.registerRoute(</span></span><br><span class="line"><span class="string">  new RegExp('</span>https:<span class="comment">//your\.cdn\.com/'),</span></span><br><span class="line">  workbox.strategies.staleWhileRevalidate()</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">workbox.routing.registerRoute(</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'https://your\.img\.cdn\.com/'</span>),</span><br><span class="line">  workbox.strategies.cacheFirst(&#123;</span><br><span class="line">    cacheName: <span class="string">'example:img'</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面的代码理解起来就容易的多了，通过 workbox.precaching 中的是 install 以后要塞进 caches 中的内容，workbox.routing.registerRoute 中第一个参数是一个正则，匹配经过 fetch 事件的所有请求，如果匹配上了，就走相应的缓存策略 workbox.strategies 对象为我们提供了几种最常用的策略，如下：</p>
<h5 id="Stale-While-Revalidate"><a href="#Stale-While-Revalidate" class="headerlink" title="Stale-While-Revalidate"></a>Stale-While-Revalidate</h5><p><img src="https://gw.alicdn.com/tfs/TB1LNY7JFOWBuNjy0FiXXXFxVXa-1014-492.png" alt></p>
<h5 id="Cache-First"><a href="#Cache-First" class="headerlink" title="Cache First"></a>Cache First</h5><p><img src="https://gw.alicdn.com/tfs/TB1kmv2JKSSBuNjy0FlXXbBpVXa-1004-496.png" alt></p>
<h5 id="Network-First"><a href="#Network-First" class="headerlink" title="Network First"></a>Network First</h5><p><img src="https://gw.alicdn.com/tfs/TB1Il7mJQCWBuNjy0FaXXXUlXXa-1014-492.png" alt></p>
<h5 id="Network-Only"><a href="#Network-Only" class="headerlink" title="Network Only"></a>Network Only</h5><p><img src="https://gw.alicdn.com/tfs/TB1LYbuJKOSBuNjy0FdXXbDnVXa-1014-345.png" alt></p>
<h5 id="Cache-Only"><a href="#Cache-Only" class="headerlink" title="Cache Only"></a>Cache Only</h5><p><img src="https://gw.alicdn.com/tfs/TB1oveWJFGWBuNjy0FbXXb4sXXa-1013-344.png" alt></p>
<p>你可以通过 plugin 扩展这些策略，比如增加个缓存过期时间（官方有提供）什么的。甚至可以继续监听 fetch 事件，然后使用这些策略，官方文档在<a href="https://developers.google.com/web/tools/workbox/modules/workbox-strategies#stale-while-revalidate" target="_blank" rel="noopener">这里</a>.</p>
<h2 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h2><p>在经过一段时间的使用和思考以后，给出我认为最为合理，最为保守的缓存策略。</p>
<p>HTML，如果你想让页面离线可以访问，使用 NetworkFirst，如果不需要离线访问，使用 NetworkOnly，其他策略均不建议对 HTML 使用。</p>
<p>CSS 和 JS，情况比较复杂，因为一般站点的 CSS，JS 都在 CDN 上，SW 并没有办法判断从 CDN 上请求下来的资源是否正确（HTTP 200），如果缓存了失败的结果，问题就大了。这种我建议使用 Stale-While-Revalidate 策略，既保证了页面速度，即便失败，用户刷新一下就更新了。</p>
<p>如果你的 CSS，JS 与站点在同一个域下，并且文件名中带了 Hash 版本号，那可以直接使用 Cache First 策略。</p>
<p>图片建议使用 Cache First，并设置一定的失效事件，请求一次就不会再变动了。</p>
<p>上面这些只是普适性的策略，见仁见智。</p>
<p>还有，要牢记，对于不在同一域下的任何资源，绝对不能使用 Cache only 和 Cache first。</p>
<h2 id="最后打个报告"><a href="#最后打个报告" class="headerlink" title="最后打个报告"></a>最后打个报告</h2><p>淘宝 PC 首页的 Service Worker 上线已经有一段时间了，经过不断地对缓存策略的调整，收益还是比较明显的，页面总下载时间从平均 1.7s，下降到了平均 1.4s，缩短了近 18% 的下载时间。</p>
<p>前面的例子中，我们使用的是 Google 的 CDN 地址引入的 Workbox，我已经将 3.3.0 版本迁移到 alicdn，后续还会继续维护更新，使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">importScripts(<span class="string">'https://g.alicdn.com/kg/workbox/3.3.0/workbox-sw.js'</span>);</span><br><span class="line">workbox.setConfig(&#123;</span><br><span class="line">  modulePathPrefix: <span class="string">'https://g.alicdn.com/kg/workbox/3.3.0/'</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul>
<li><a href="https://developers.google.com/web/tools/workbox/" target="_blank" rel="noopener">Workbox 官方文档</a></li>
<li><a href="https://zoumiaojiang.com/article/amazing-workbox-3/" target="_blank" rel="noopener">神奇的 Workbox 3.0</a></li>
</ul>
<blockquote>
<p>Photo by Peter Wendt on Unsplash</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB19EDcJMmTBuNjy1XbXXaMrVXa-900-500.jpg" alt="Workbox 3：Service Worker 可以如此简单"></p>
<p>如果你追求极致的 Web 体]]>
    </summary>
    
      <category term="PWA" scheme="http://taobaofed.org/tags/PWA/"/>
    
      <category term="Service Worker" scheme="http://taobaofed.org/tags/Service-Worker/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[基于 BindingX 的富交互解决方案]]></title>
    <link href="http://taobaofed.org/blog/2018/05/31/a-rich-interaction-solution-based-on-bindingx/"/>
    <id>http://taobaofed.org/blog/2018/05/31/a-rich-interaction-solution-based-on-bindingx/</id>
    <published>2018-05-31T04:22:18.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB15lFuuGmWBuNjy1XaXXXCbXXa-900-500.jpg" alt="基于 BindingX 的富交互解决方案"></p>
<h1 id="基于-BindingX-的富交互解决方案"><a href="#基于-BindingX-的富交互解决方案" class="headerlink" title="基于 BindingX 的富交互解决方案"></a>基于 BindingX 的富交互解决方案</h1><p>BindingX 官网: <a href="https://alibaba.github.io/bindingx/" target="_blank" rel="noopener">https://alibaba.github.io/bindingx/</a><br>BindingX 项目地址: <a href="https://github.com/alibaba/bindingx" target="_blank" rel="noopener">https://github.com/alibaba/bindingx</a></p>
<h3 id="一-背景"><a href="#一-背景" class="headerlink" title="一. 背景"></a>一. 背景</h3><p>在 Weex 环境下实现一些复杂的手势交互效果可能会产生卡顿，这是因为每次手势交互都会产生两次 JS-native 通信。第一次是 native call JS，将手势事件传递到 JS 层交给前端处理，当 JS 层接收到回调后，会产生第二次通信，JS call native，用来驱动界面变化。与此同时，手势回调事件触发的频率是非常高的，频繁通信带来的时间成本很可能导致界面无法在 16ms 中完成绘制，因而产生卡顿。</p>
<p>我们提出了 <code>Expression Binding</code> 方案用来解决这个问题。方案是在手势开始的时候，将具体的手势控制函数以<code>表达式</code>的形式传递给 Native 层，当手势发生时，Native 根据预置的表达式解析器去解释执行表达式，并根据结果驱动视图变化。这样带来的好处是大大的减少了 native-JS 的通信次数，下面两幅图描述了传统方案与 <code>Expression Binding</code> 方案的差别：</p>
<p>图 1：传统方案</p>
<p><img src="https://gw.alicdn.com/tfs/TB1PAkXrbGYBuNjy0FoXXciBFXa-2318-768.png" alt></p>
<p>图 2：Expression Binding 方案</p>
<p><img src="https://gw.alicdn.com/tfs/TB1N0tgrqmWBuNjy1XaXXXCbXXa-2250-708.png" alt></p>
<p>事实上，<code>Expression Binding</code> 不仅仅可以解决手势交互问题，任何 JS-native 频繁通信 + UI 更新的场景理论上都可以复用这套方案。比如：</p>
<ol>
<li>监听容器的滚动，并基于滚动距离等变量更新UI如最常见的视差动画等；</li>
<li>监听陀螺仪方向变化数据，并更新 UI；</li>
<li>监听时间变化，更新 UI；</li>
<li>……</li>
</ol>
<p><img src="https://gw.alicdn.com/tfs/TB1o8AoreSSBuNjy0FlXXbBpVXa-2172-1090.png" alt></p>
<p>因此，我们将原方案进行了横向的扩展，实现了这些新的特性，并将它命名为 BindingX。2018 年 3 月，BindingX 正式开源，并同时支持了 React Native。</p>
<h3 id="二-特性一览"><a href="#二-特性一览" class="headerlink" title="二. 特性一览"></a>二. 特性一览</h3><h4 id="1-手势能力"><a href="#1-手势能力" class="headerlink" title="1. 手势能力"></a>1. 手势能力</h4><p>BindingX 能够监听元素的 pan 事件，基于此可以实现拖拽、卡片横滑等跟手的交互效果。更令人惊喜的是，类似 Weex <a href="http://weex-project.io/cn/references/components/slider.html" target="_blank" rel="noopener">Slider</a> 这样的组件现在也可以使用 BindingX 来实现！</p>
<p><img src="https://gw.alicdn.com/tfs/TB1qzW3iER1BeNjy0FmXXb0wVXa-281-500.gif" alt="demo1"><br><img src="https://gw.alicdn.com/tfs/TB1EoOuiuuSBuNjSsziXXbq8pXa-281-500.gif" alt="demo2"><br><img src="https://gw.alicdn.com/tfs/TB18oHrrkyWBuNjy0FpXXassXXa-281-500.gif" alt="demo3"></p>
<h4 id="2-动画"><a href="#2-动画" class="headerlink" title="2. 动画"></a>2. 动画</h4><p>在 Weex 上实现动画通常的做法是使用 <code>animation module</code>，现在有了新的选择。使用 BindingX 可以实现所有 animation module 能实现的效果，另外，BindingX 内置了 30 多组常见的<a href="https://alibaba.github.io/bindingx/guide/cn_api_interpolator" target="_blank" rel="noopener">插值器</a>，可以自由选择，当然也可以使用 cubicBezier 贝塞尔曲线定制插值器。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1Fn_srgmTBuNjy1XbXXaMrVXa-281-499.gif" alt="demo4"><br><img src="https://gw.alicdn.com/tfs/TB1Csuwiv1TBuNjy0FjXXajyXXa-281-500.gif" alt="demo6"></p>
<h4 id="3-陀螺仪"><a href="#3-陀螺仪" class="headerlink" title="3. 陀螺仪"></a>3. 陀螺仪</h4><p>BindingX 内置了陀螺仪监听器，可以监听设备方向变化。这在很多富交互场景中非常实用，比如在手机淘宝里，你可以看到很多基于陀螺仪的视差效果：</p>
<p><img src="https://gw.alicdn.com/tfs/TB1UjMUrhGYBuNjy0FnXXX5lpXa-281-500.gif" alt="demo7"><br><img src="https://gw.alicdn.com/tfs/TB18ej1rbGYBuNjy0FoXXciBFXa-281-500.gif" alt="demo8"></p>
<h4 id="4-列表滚动监听"><a href="#4-列表滚动监听" class="headerlink" title="4. 列表滚动监听"></a>4. 列表滚动监听</h4><p>BindingX 能够监听列表等滚动容器的 <code>onScroll</code> 事件，通过它可以实现酷炫的视差动画：</p>
<p><img src="https://gw.alicdn.com/tfs/TB18v3VrhGYBuNjy0FnXXX5lpXa-281-499.gif" alt="demo9"><br><img src="https://gw.alicdn.com/tfs/TB1NCGhipOWBuNjy0FiXXXFxVXa-281-500.gif" alt="demo10"></p>
<h3 id="三-使用方式"><a href="#三-使用方式" class="headerlink" title="三. 使用方式"></a>三. 使用方式</h3><p>BiningX 同时支持 ReactNative 和 Weex，对于 Weex 来说不管你是使用 Rax 还是 Vue DSL，都没有关系。下面以 Weex 举例来说明如何使用 BindingX。</p>
<h5 id="第一步：安装依赖"><a href="#第一步：安装依赖" class="headerlink" title="第一步：安装依赖"></a>第一步：安装依赖</h5><ul>
<li>安装 npm 依赖</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install weex-bindingx --save</span><br></pre></td></tr></table></figure>
<ul>
<li>在 JS 代码中引入 BindingX 模块</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BindingX <span class="keyword">from</span> weex-bindingx;</span><br></pre></td></tr></table></figure>
<h5 id="第二步：编写表达式"><a href="#第二步：编写表达式" class="headerlink" title="第二步：编写表达式"></a>第二步：编写表达式</h5><ul>
<li>根据业务场景，选择您需要的 eventType。 比如，要监听手势，eventType 值为 pan，监听滚动容器 scrollOffset 变化，eventType 值为 scroll。</li>
<li>根据交互行为，选择要改变的属性，并编写相应的表达式。比如，交互行为是“用户横滑 100 单位，透明度从 1 变化到 0”。则属性为 “opacity”，表达式为 “1 - x / 100”。</li>
</ul>
<h5 id="第三步：绑定表达式"><a href="#第三步：绑定表达式" class="headerlink" title="第三步：绑定表达式"></a>第三步：绑定表达式</h5><p>根据第二步得到的 eventType、Expression 以及 Property，调用 BindingX 模块的 bind 方法，完成绑定。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> result = BindingX.bind(&#123;</span><br><span class="line">    eventType: <span class="string">'pan'</span>,       ==&gt; 事件类型</span><br><span class="line">    anchor: <span class="string">'foo'</span>,          ==&gt; anchor 指的是事件的触发者，如果是 eventType 是 “orientation” 或 “timing”，则不用填</span><br><span class="line">    props: [</span><br><span class="line">        &#123;</span><br><span class="line">            element: view.ref,     ==&gt; 要改变的视图的引用或者 id</span><br><span class="line">            expression: <span class="string">"1 - x / 100"</span>, ==&gt; 表达式</span><br><span class="line">            property: <span class="string">"opacity"</span>    ==&gt; 要改变的属性</span><br><span class="line">        &#125;</span><br><span class="line">    ] </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当调用 bind 方法之后，native 会启动监听，当目标事件（比如手指滑动、设备方向变化等）发生的时候，便会执行您先前绑定的一组或者多组表达式。 bind 方法会返回一个 JS 对象，其中包含了一个 token 属性，可以使用这个 token 取消绑定。</p>
<p>更多细节，请参考我们的<a href="https://alibaba.github.io/bindingx/guide/cn_introduce" target="_blank" rel="noopener">文档</a>。</p>
<h5 id="第四步：取消绑定"><a href="#第四步：取消绑定" class="headerlink" title="第四步：取消绑定"></a>第四步：取消绑定</h5><p>在合适的时机调用 BindingX 的 unbind 方法取消绑定。比如，页面不可见或者即将销毁的时候。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BindingX.unbind(&#123;</span><br><span class="line">    token: result.token,</span><br><span class="line">    eventType: <span class="string">'pan'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="四-内部细节"><a href="#四-内部细节" class="headerlink" title="四. 内部细节"></a>四. 内部细节</h3><p>下面以 Android 为例从 native 的视角介绍下 BindingX 的具体实现，首先我们来梳理整个流程：</p>
<ol>
<li><p>前端通过声明的方式定义具体的视图变化，每个视图变化过程都用一个三元组描述：</p>
<ul>
<li>element：目标元素。</li>
<li>property：要改变的属性。</li>
<li>expression：表达式。通过工具生成抽象语法树。</li>
</ul>
</li>
<li><p>native 根据 eventType 注册对应的事件监听器，并将映射关系保存起来；</p>
</li>
<li>当指定的事件发生的时候，native 自行消费先前绑定的所有表达式，计算结果，并根据结果对视图进行更新。</li>
</ol>
<p>这个过程可以用下面这张图描述:</p>
<p><img src="https://img.alicdn.com/tfs/TB101ahSVXXXXXuXVXXXXXXXXXX-986-432.jpg" alt></p>
<p>在这个模型里，输入可以是手势事件、滚动事件、陀螺仪方向变化事件，而输出则是经过视图变换的view，视图变换的过程在 native 完成。而视图变换的规则是通过<code>表达式</code>来描述的，一个表达式在前端声明之后，会先通过 <a href="https://github.com/alibaba/bindingx/blob/master/parser/src/index.js" target="_blank" rel="noopener">parser</a> 转成 <code>Abstract syntax tree</code>，native 会通过预置的解析器来解析表达式树，并计算出结果，根据结果去驱动视图变化。</p>
<h3 id="五-更多想象力"><a href="#五-更多想象力" class="headerlink" title="五. 更多想象力"></a>五. 更多想象力</h3><p>事实上，<code>BindingX</code> 比我们想象的更加强大，在上面那张架构图中，输出部分画的是 <code>transformed view</code>，但是事实上除了 view，我们还在探索更多有趣的玩法，比如：</p>
<ul>
<li>BindingX 和 Lottie 结合。用 BindingX 驱动 <code>lottie</code> 实现动画；</li>
<li>BindingX 和 <code>Weex SVG</code> 结合，实现好玩的轨迹动画、路径跟随动画，甚至是 morph 变形动画;</li>
<li>BindingX 和 <code>Shader</code> 结合，用 BindingX 来控制着色器!</li>
<li>……</li>
</ul>
<h3 id="六-下一步"><a href="#六-下一步" class="headerlink" title="六. 下一步?"></a>六. 下一步?</h3><p>BindingX 在内部经过很长时间的孵化，在上层衍生出了很多通用的业务组件，它们涵盖了大部分的交互场景，诸如下拉刷新、转场、联动、视差动画，<a href="https://github.com/alibaba/rax/blob/master/packages/rax-tab-panel/src/index.js" target="_blank" rel="noopener">tab-panel</a>、<a href="https://github.com/alibaba/rax/blob/master/packages/rax-parallax/src/index.js" target="_blank" rel="noopener">parallax</a> 就是很好的例子。一个基于 <code>BindingX</code> 的前端交互体系正在成型，下一步我们会将它们逐渐开源到社区，敬请期待！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB15lFuuGmWBuNjy1XaXXXCbXXa-900-500.jpg" alt="基于 BindingX 的富交互解决方案"></p>
<h1 id="基于-BindingX-的富交互解决方案]]>
    </summary>
    
      <category term="BindingX" scheme="http://taobaofed.org/tags/BindingX/"/>
    
      <category term="交互" scheme="http://taobaofed.org/tags/%E4%BA%A4%E4%BA%92/"/>
    
      <category term="Weex" scheme="http://taobaofed.org/tags/Weex/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[活用 Shader，让你的页面更小，更炫，更快]]></title>
    <link href="http://taobaofed.org/blog/2018/05/07/optimizing-page-performance-with-shader/"/>
    <id>http://taobaofed.org/blog/2018/05/07/optimizing-page-performance-with-shader/</id>
    <published>2018-05-07T08:21:04.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1zdJ_qeOSBuNjy0FdXXbDnVXa-900-500.jpg" alt="活用 Shader，让你的页面更小，更炫，更快"></p>
<p>可编程着色器（shader）是运行在 GPU 中的程序，是现代图形渲染技术的基础。shader 赋予了开发者「逐像素着色」的能力。桌面/移动设备的图形程序 API 诸如 OpenGL，OpenGL ES，DirectX 以及新一代的 Vulkan，shader 都是重中之重，核心中的核心。</p>
<p>WebGL 的出现，使得在浏览器环境中渲染 3D 场景变得轻而易举。但是 WebGL 和 shader 不仅可以用来渲染 3D 场景，还可以做一些其他酷酷的事情。前两天，我用 shader 技术改造 / 复刻了之前开发的一个业务页面，颇有心得和启发，不妨记录下来。</p>
<blockquote>
<p>广告：在 GCanvas 的帮助下，前端开发可以在 Weex，RN 等 Hybrid 环境中使用本文中用到的技术。详情见 <a href="https://alibaba.github.io/GCanvas/" target="_blank" rel="noopener">GCanvas</a>。</p>
</blockquote>
<p>先看一下效果：<a href="http://g.alicdn.com/gama/assets/0.0.10/assets/shader-view-demo/compare.html" target="_blank" rel="noopener">链接</a></p>
<p><img src="https://img.alicdn.com/tfs/TB1RNl_qntYBeNjy1XdXXXXyVXa-600-529.jpg" alt></p>
<p>左侧是原页面，<a href="http://g.alicdn.com/gama/assets/0.0.10/assets/shader-view-demo/index.html" target="_blank" rel="noopener">地址</a>；右侧是用 Shader 复刻后的页面，<a href="http://g.alicdn.com/gama/assets/0.0.10/assets/shader-view-demo/shader.html" target="_blank" rel="noopener">地址</a>。</p>
<p>这其实是 2018 年春晚项目的一个活动页面，页面结构非常简单。这个页面当时是我完成的，所以现在复刻起来熟悉一些。</p>
<p>我们可以看到，复刻前的页面（后面称「原页面」）是静态的，加载了 1 个 js 文件和 6 张图片共 599K 的资源（包含一张 502K 的大尺寸透明 png 图片）；而复刻后的页面上，有不少元素在动，加载了 1 个 js 文件和 4 张图片共 122K 的资源。不管是视觉效果，还是页面尺寸上的提升，都是比较明显的。</p>
<p><img src="https://img.alicdn.com/tfs/TB1B88_qntYBeNjy1XdXXXXyVXa-500-254.jpg" alt></p>
<p><img src="https://img.alicdn.com/tfs/TB1Xcsip1uSBuNjy1XcXXcYjFXa-500-226.jpg" alt></p>
<p>下面，我们就以这个页面为例，分析一下，使用 shader 是如何让这个页面更小，更炫，更快。</p>
<blockquote>
<p>阅读后面的文本需要一些 WebGL 和 GLSL 的基础知识，之前在团内对曾做过一些培训，参加的同学应该不会有什么压力，没参加的同学，也可以稍微看下 the book of shaders 这篇教程。shader 比你想象的要简单易用，相信我。</p>
</blockquote>
<h1 id="大尺寸透明背景图"><a href="#大尺寸透明背景图" class="headerlink" title="大尺寸透明背景图"></a>大尺寸透明背景图</h1><p>原页面存在的一个最大的问题是，有一张特别大的透明背景图。</p>
<p><img src="https://img.alicdn.com/tfs/TB11dUjp1uSBuNjy1XcXXcYjFXa-750-571.jpg" alt></p>
<p>这张图的体积达到了惊人的 501K，这是因为这张图是具有透明通道的 png 图片。而且由于这张图是广告内容，可能不止一张，是无法融合到背景里去的，必须透明。这时怎么优化呢？<br>我们知道，具有透明通道的 png 的压缩是比较困难的；而不具备透明通道的图片，我们可以把它转化为 jpg 等格式，压缩比就高得多了，我们就可以以较小的质量损失去换取较大的压缩空间。</p>
<p>我的思路是这样：把这张透明的 png 格式图片拆分为两张不透明的 jpg 格式图片。这两张不透明的图片，其中一张继承 png 图片的 rgb 通道，还有一张则仅使用 r 通道储存 png 图片的 a 通道。然后把这两张图片拼接在一起，给 WebGL 使用。由于拼接后的这张图没有透明度分量，所以可以使用 jpg 格式压缩，尺寸大幅度降低。这张图只有 41.5k，大约为之前的 8.2%。</p>
<p>这张图看上去是这样的：</p>
<p><img src="https://img.alicdn.com/tfs/TB13tUjp1uSBuNjy1XcXXcYjFXa-700-700.jpg" alt></p>
<blockquote>
<p>注意，前一张图的像素尺寸是 750x571，而后一张图的像素尺寸为 1024x1024，这里我并没有通过缩小图片的像素尺寸来进行压缩。</p>
<p>此外，第二张图看上去有些变形，这是因为图片尺寸为 2 的整数次幂，WebGL 能够方便地生成 mipmap，这对我们的使用没有影响。</p>
</blockquote>
<p>在 shader 中，我们根据像素坐标从图片中取色，注意需要从图的上半部分和下半部分各取一个颜色，然后根据一定规则拼起来即可。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">precision</span> <span class="keyword">mediump</span> <span class="type">float</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">uniform</span> <span class="type">vec2</span> uResolution;</span><br><span class="line"><span class="keyword">uniform</span> <span class="type">sampler2D</span> uImage;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy / uResolution;</span><br><span class="line"></span><br><span class="line">    <span class="type">vec4</span> c2 = <span class="built_in">texture2D</span>(uImage, <span class="type">vec2</span>(st.x, st.y*<span class="number">0.5</span>));      <span class="comment">// 取 A​lpha 通道</span></span><br><span class="line">    <span class="type">vec4</span> c1 = <span class="built_in">texture2D</span>(uImage, <span class="type">vec2</span>(st.x, st.y*<span class="number">0.5</span>+<span class="number">0.5</span>));  <span class="comment">// 取 RGB 通道</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(c1.xyz, c2.r &gt; <span class="number">0.6</span> ? c2.r : <span class="number">0.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>png 图片转化为 jpg 图片的过程，可以很轻松地在浏览器里操作 canvas 完成（示例），也可以借助一些其他的工具完成。</p>
<h1 id="会动的背景"><a href="#会动的背景" class="headerlink" title="会动的背景"></a>会动的背景</h1><p>首先，我们注意到，原页面的背景是在红色的渐变之上，随机散布着一些黄色的氛围小碎片。红色渐变背景和这些小碎片全部画在一张静态 jpg 图片上，如下图（1.原图）所示。</p>
<p><img src="https://img.alicdn.com/tfs/TB16JUjp1uSBuNjy1XcXXcYjFXa-700-1256.jpg" alt></p>
<p>在复刻前，我把原页面用到的图片分为了两类，图案（pattern）性质和图片（image）性质。Pattern 性质的图片，本身并不传递信息，通常用作底纹，氛围等场景；而 image 性质的图片则是信息的载体。</p>
<p>这张图片明显是 pattern 性质的，这类图片往往尺寸大，体积也较大（尤其是半透明图案）。其实，这些图案完全可以用 shader 「手绘」出来，这样就不用去加载此图片了。<br>用 shader 绘制图案的另一个好处是，图案可以有规律地动起来。在这个例子中，如果碎片能像天女散花一般洒下来，那就太棒了，对吧？但是熟悉前端动画的同学，一定会想到，这么多粒子组成的动画，如果用纯 CSS 或者 canvas 2d 来做的话，性能肯定好不了，粒子越多，动画的性能越差。用 WebGL 和 shader 来做粒子动画则不会因为粒子数量的增多而导致性能变差。</p>
<p>我们来看看如何用 shader 绘制这些碎片。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec2</span> random2(<span class="type">vec2</span> st)&#123;</span><br><span class="line">  st = <span class="type">vec2</span>( <span class="built_in">dot</span>(st,<span class="type">vec2</span>(<span class="number">127.1</span>,<span class="number">311.7</span>)),</span><br><span class="line">            <span class="built_in">dot</span>(st,<span class="type">vec2</span>(<span class="number">269.5</span>,<span class="number">183.3</span>)));</span><br><span class="line">  st = <span class="number">-1.0</span> + <span class="number">2.0</span>*<span class="built_in">fract</span>(<span class="built_in">sin</span>(st)*<span class="number">43758.5453123</span>);</span><br><span class="line">  <span class="keyword">return</span> st;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="built_in">noise2</span>(<span class="type">vec2</span> ist, <span class="type">vec2</span> fst)&#123;</span><br><span class="line">  <span class="type">vec2</span> g1 = random2(ist+<span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">0.0</span>));</span><br><span class="line">  <span class="type">vec2</span> g2 = random2(ist+<span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>));</span><br><span class="line">  <span class="type">vec2</span> g3 = random2(ist+<span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>));</span><br><span class="line">  <span class="type">vec2</span> g4 = random2(ist+<span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>));</span><br><span class="line"></span><br><span class="line">  <span class="type">vec2</span> f1 = fst - <span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">  <span class="type">vec2</span> f2 = fst - <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">  <span class="type">vec2</span> f3 = fst - <span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">  <span class="type">vec2</span> f4 = fst - <span class="type">vec2</span>(<span class="number">1.0</span>, <span class="number">1.0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="type">float</span> p1 = <span class="built_in">dot</span>(g1, f1);</span><br><span class="line">  <span class="type">float</span> p2 = <span class="built_in">dot</span>(g2, f2);</span><br><span class="line">  <span class="type">float</span> p3 = <span class="built_in">dot</span>(g3, f3);</span><br><span class="line">  <span class="type">float</span> p4 = <span class="built_in">dot</span>(g4, f4);</span><br><span class="line"></span><br><span class="line">  fst = <span class="built_in">smoothstep</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, fst);</span><br><span class="line">  </span><br><span class="line">  <span class="type">float</span> p = <span class="built_in">mix</span>(</span><br><span class="line">    <span class="built_in">mix</span>(p1, p2, fst.x),</span><br><span class="line">    <span class="built_in">mix</span>(p3, p4, fst.x),</span><br><span class="line">    fst.y</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> inFrag()&#123;</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy / uResolution.xx;</span><br><span class="line">    st = st * <span class="number">60.0</span>;</span><br><span class="line">    <span class="type">float</span> res = <span class="built_in">noise2</span>(<span class="built_in">floor</span>(st), <span class="built_in">fract</span>(st));</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">float</span> pct = inFrag();</span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(pct), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们要借助一个梯度噪声函数 noise2（参考此教程），对每个像素而言，把像素坐标输入，这个函数则会输出一个灰度值。此函数输出的图像大致如上图 （2.梯度噪声）所示。<br>如果你对诸如「噪声函数」的原理感到陌生，其实也没太大关系。你可以在社区找到大量各种各样的开箱即用的功能函数，只需要知道它们的效果是什么，而不必太拘泥于其内部的原理。<br>显然，图 2.梯度噪声 和我们设想的还有差距。接下来，我们用一个筛子把亮度大于某个阈值的点筛出来：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function initFrag()&#123;</span><br><span class="line">    ...</span><br><span class="line">    res = <span class="built_in">step</span>(<span class="number">0.5</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，用 step 函数直接把大于 0.5 的点筛出来。可是这样做容易产生锯齿，为了使碎片的边缘比较平滑，所以我们用 smoothsStep 函数进行截取。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res = <span class="built_in">smoothstep</span>(<span class="number">0.35</span>, <span class="number">0.5</span>, res);</span><br></pre></td></tr></table></figure>
<p>这样，我们就得到了图 3.拉伸的结果。</p>
<p>图 3 只是一张灰度图，我们使用这个灰度混合红色和黄色，使之得到一张彩色的图。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> bgColor()&#123;</span><br><span class="line">    <span class="type">float</span> y = <span class="built_in">gl_FragCoord</span>.y / uResolution.y;</span><br><span class="line">    <span class="type">vec3</span> c1 = <span class="type">vec3</span>(<span class="number">0.96</span>, <span class="number">0.02</span>, <span class="number">0.16</span>);</span><br><span class="line">    <span class="type">vec3</span> c2 = <span class="type">vec3</span>(<span class="number">0.96</span>, <span class="number">0.25</span>, <span class="number">0.21</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(c1, c2, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">vec3</span> cRed = bgColor();</span><br><span class="line">    <span class="type">vec3</span> cYello = <span class="type">vec3</span>(<span class="number">0.96</span>, <span class="number">0.70</span>, <span class="number">0.26</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="built_in">mix</span>(cRed, cYello, pct), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里 bgColor 方法返回红色，由于红色背景仍然是有一点垂直渐变色效果的，所以这里也要额外用两种不同的红色进行混合（混合系数和像素坐标的 Y 值相关），处理成渐变色。</p>
<p>此时我们的结果和原图的意图还有些不同：</p>
<ul>
<li>原图中，页面下半部分的碎片比较透明度，越往页面下方，碎片就越透明（融入了红色背景）。</li>
<li>原图中，中间圈圈部分（即红色窗格占据的部分）没有碎片。</li>
<li>原图中，碎片的分布没有这么均匀，常有一小块区域完全没有碎片的情况，似乎有一种尺寸更大的随机变量在影响。</li>
</ul>
<p>从以上三点出发，我们制作了 3 个通道，并依次叠加（如图 5，图 6，图 7）所示，最终得到如 图 7 所示。将叠加后的结果与图 3 进行叠加，也就是说，图 3 中被筛出的点，如果在图 7 中是较暗的，则也会被降低亮度。再使用这一步的结果进行混色，最终得到图 8 的效果。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> pct = inFrag();</span><br><span class="line">    pct = <span class="built_in">min</span>(pct, yFactor());</span><br><span class="line">    pct = <span class="built_in">min</span>(pct, rFactor());</span><br><span class="line">    pct = <span class="built_in">min</span>(pct, mFactor());</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面，我们来使碎片动起来（洒下来）。在生成碎片的时候，传入噪音函数的坐标数据中，加上和时间有关的偏移量：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> inFrag()&#123;</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy / uResolution.xx;</span><br><span class="line">    st = st * <span class="number">60.0</span>;</span><br><span class="line">    st.y += uTime * <span class="number">2.0</span>;  <span class="comment">// 增加与时间相关的偏移量</span></span><br><span class="line">    <span class="type">float</span> res = <span class="built_in">noise2</span>(<span class="built_in">floor</span>(st), <span class="built_in">fract</span>(st));</span><br><span class="line">    res = <span class="built_in">smoothstep</span>(<span class="number">0.35</span>, <span class="number">0.5</span>, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，为了更出色的效果，我这里做了两个碎层碎片，两层碎片具有不同的下落速度，形成一些视差效果。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> main() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> pct = inFrag();</span><br><span class="line">    pct = <span class="built_in">min</span>(pct, yFactor());</span><br><span class="line">    pct = <span class="built_in">min</span>(pct, rFactor());</span><br><span class="line">    pct = <span class="built_in">min</span>(pct, mFactor());</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> pct2 = inFrag2();</span><br><span class="line">    pct2 = <span class="built_in">min</span>(pct2, yFactor());</span><br><span class="line">    pct2 = <span class="built_in">min</span>(pct2, rFactor());</span><br><span class="line">    pct2 = <span class="built_in">min</span>(pct2, mFactor());</span><br><span class="line"></span><br><span class="line">    pct = <span class="built_in">max</span>(pct, pct2);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，就在完全不依赖外部资源的情况下，仅用 shader 直接绘制，制作出了氛围碎片的效果。</p>
<h1 id="手绘图案"><a href="#手绘图案" class="headerlink" title="手绘图案"></a>手绘图案</h1><p>原页面中有一个圆形的窗格，这个窗格也是画在一张透明图片上。不知读者是否注意到，在复刻后的页面中，这个窗格是用 shader 直接画出来的。</p>
<p><img src="https://img.alicdn.com/tfs/TB10Tp.qntYBeNjy1XdXXXXyVXa-400-363.jpg" alt></p>
<p>实际上，这种复杂程度的窗格，也可以归为图案（pattern）一类，shader 是完全可以直接画出来的。下面，我们就来看看用 shader 如何来画窗格。<br>窗格是由线组成的，其基本单元是线。首先我们看一下是如何画线的：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制线的函数 veins</span></span><br><span class="line"><span class="type">float</span> line(<span class="type">float</span> e, <span class="type">float</span> w, <span class="type">float</span> d, <span class="type">float</span> p)&#123;</span><br><span class="line">    <span class="type">float</span> e1 = e - w/<span class="number">2.0</span>;</span><br><span class="line">    <span class="type">float</span> e2 = e + w/<span class="number">2.0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(e1 - d / <span class="number">2.0</span>, e1 + d / <span class="number">2.0</span>, p) * </span><br><span class="line">            <span class="built_in">smoothstep</span>(e2 + d / <span class="number">2.0</span>, e2 - d / <span class="number">2.0</span>, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制网格</span></span><br><span class="line"><span class="type">vec3</span> veins()&#123;</span><br><span class="line">    <span class="type">float</span> r = uResolution.x * <span class="number">0.4</span>;</span><br><span class="line">    <span class="type">vec2</span> center = <span class="type">vec2</span>(uResolution.x/<span class="number">2.0</span>, uResolution.y-r<span class="number">-5.0</span>);</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy - center;</span><br><span class="line">    st /= uResolution.x * <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = line(<span class="number">0.0</span>, <span class="number">0.3</span>, <span class="number">0.2</span>, st.x);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(veinsBgColor, veinsFgColor, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec3</span> res = veins();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = <span class="type">vec4</span>(<span class="type">vec3</span>(res), <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main 函数调用 veins 函数，veins 又调用 line 函数得到一个灰度值，然后混合两种颜色。上述程序的结果如下图所示。</p>
<p><img src="https://img.alicdn.com/tfs/TB1ctq.p3mTBuNjy1XbXXaMrVXa-400-430.jpg" alt></p>
<p>解释一下几个参数：p 是当前像素的 x 或 y 坐标值（取决于横线还是竖线，如果是横线为 y 坐标值，如果为竖线为 x 坐标值），e 则是所绘制的直线所在的坐标。w 指线的宽度，而 d 指在线与非线的交界处，用来平滑的区域的宽度。</p>
<blockquote>
<p>在上面的代码中，w 取了 0.3，而 d 取了 0.2，线看上去很粗。后面，我们会把这两个值固定在 0.035 和 0.003 上。</p>
</blockquote>
<p>由于窗格图案中包含多跟线，我们需要多次调用 line 函数，并得到一个一个灰度值。如果当前像素在「任意一个」 line 函数中返回了大于 0 的灰度值，我们就认为这个像素是在图案上的。换言之，我们取多次 line 函数返回的灰度值中最大的那个值，作为最后的灰度值来计算颜色。代码如下所示：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> maxList(<span class="type">float</span> list[<span class="number">20</span>])&#123;</span><br><span class="line">    <span class="type">float</span> res = list[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">20</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(list[i]&gt;res)&#123;</span><br><span class="line">            res = list[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> veins()&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = <span class="number">0.0</span>;</span><br><span class="line">    <span class="type">float</span> pl[<span class="number">20</span>];</span><br><span class="line">    pl[<span class="number">0</span>] = line(<span class="number">0.29</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.x);</span><br><span class="line">    pl[<span class="number">1</span>] = line(<span class="number">0.58</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.x);</span><br><span class="line">    ...</span><br><span class="line">    pl[<span class="number">7</span>] = line(<span class="number">-0.58</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.y);</span><br><span class="line"></span><br><span class="line">    p = maxList(pl);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们计算了 8 根直线，得到的结果如下图 2 所示。</p>
<p><img src="https://img.alicdn.com/tfs/TB1ltq.p3mTBuNjy1XbXXaMrVXa-700-1105.jpg" alt></p>
<p>拆解图案，我们发现光有直线还不能满足要求，还需要有射线和矩形框。同样，我们引入射线 ray 和矩形框 box 函数。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> rayV(<span class="type">vec2</span> ep, <span class="type">float</span> w, <span class="type">float</span> d,  <span class="type">float</span> dir, <span class="type">vec2</span> st)&#123;</span><br><span class="line">    <span class="type">float</span> pct = line(ep.x, w, d, st.x);</span><br><span class="line">    <span class="keyword">if</span>((st.y - ep.y) * dir &lt; <span class="number">0.0</span>)&#123;</span><br><span class="line">        pct = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> rayH(<span class="type">vec2</span> ep, <span class="type">float</span> w, <span class="type">float</span> d,  <span class="type">float</span> dir, <span class="type">vec2</span> st)&#123;</span><br><span class="line">    <span class="type">float</span> pct = line(ep.y, w, d, st.y);</span><br><span class="line">    <span class="keyword">if</span>((st.x - ep.x)* dir &lt; <span class="number">0.0</span>)&#123;</span><br><span class="line">        pct = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pct;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> box(<span class="type">vec2</span> center, <span class="type">float</span> width, <span class="type">float</span> height, <span class="type">float</span> w, <span class="type">float</span> d, <span class="type">vec2</span> st)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> l1 = line(center.x, width+w, d, st.x);</span><br><span class="line">    <span class="type">float</span> l2 = line(center.y, height+w, d, st.y);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> inBox = l1*l2;</span><br><span class="line">    <span class="type">float</span> plist[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">    plist[<span class="number">0</span>] = line(center.x+width*<span class="number">0.5</span>, w, d, st.x);</span><br><span class="line">    plist[<span class="number">1</span>] = line(center.x-width*<span class="number">0.5</span>, w, d, st.x);</span><br><span class="line">    plist[<span class="number">2</span>] = line(center.y+height*<span class="number">0.5</span>, w, d, st.y);</span><br><span class="line">    plist[<span class="number">3</span>] = line(center.y-height*<span class="number">0.5</span>, w, d, st.y);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = maxList(plist);</span><br><span class="line">    p *= inBox;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后依次向图案中增加内容，得到图 4，图 6 的效果。通过最终的叠加，得到了图 7 的效果。代码如下（不要被密密麻麻的浮点数吓住了，其实都是一些固定的坐标而已，有意义的值只有几个，通过正负号进行组合形成图案）：</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> p = <span class="number">0.0</span>;</span><br><span class="line"><span class="type">float</span> pl[<span class="number">20</span>];</span><br><span class="line">pl[<span class="number">0</span>] = line(<span class="number">0.29</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.x);</span><br><span class="line">pl[<span class="number">1</span>] = line(<span class="number">0.58</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.x);</span><br><span class="line">pl[<span class="number">2</span>] = line(<span class="number">-0.29</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.x);</span><br><span class="line">pl[<span class="number">3</span>] = line(<span class="number">-0.58</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.x);</span><br><span class="line">pl[<span class="number">4</span>] = line(<span class="number">0.29</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.y);</span><br><span class="line">pl[<span class="number">5</span>] = line(<span class="number">0.58</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.y);</span><br><span class="line">pl[<span class="number">6</span>] = line(<span class="number">-0.29</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.y);</span><br><span class="line">pl[<span class="number">7</span>] = line(<span class="number">-0.58</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st.y);</span><br><span class="line"></span><br><span class="line">pl[<span class="number">8</span>] = rayV(<span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">0.29</span>), <span class="number">0.035</span>, <span class="number">0.003</span>, <span class="number">1.0</span>, st);</span><br><span class="line">pl[<span class="number">9</span>] = rayV(<span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">-0.29</span>), <span class="number">0.035</span>, <span class="number">0.003</span>, <span class="number">-1.0</span>, st);</span><br><span class="line">pl[<span class="number">10</span>] = rayH(<span class="type">vec2</span>(<span class="number">0.29</span>, <span class="number">0.0</span>), <span class="number">0.035</span>, <span class="number">0.003</span>, <span class="number">1.0</span>, st);</span><br><span class="line">pl[<span class="number">11</span>] = rayH(<span class="type">vec2</span>(<span class="number">-0.29</span>, <span class="number">0.0</span>), <span class="number">0.035</span>, <span class="number">0.003</span>, <span class="number">-1.0</span>, st);</span><br><span class="line"></span><br><span class="line">p = maxList(pl);</span><br><span class="line"></span><br><span class="line"><span class="type">float</span> pl2[<span class="number">20</span>];</span><br><span class="line"></span><br><span class="line">pl2[<span class="number">0</span>] = box(<span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">0.0</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line"></span><br><span class="line">pl2[<span class="number">1</span>] = box(<span class="type">vec2</span>(<span class="number">0.29</span>, <span class="number">0.29</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line">pl2[<span class="number">2</span>] = box(<span class="type">vec2</span>(<span class="number">-0.29</span>, <span class="number">0.29</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line">pl2[<span class="number">3</span>] = box(<span class="type">vec2</span>(<span class="number">-0.29</span>, <span class="number">-0.29</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line">pl2[<span class="number">4</span>] = box(<span class="type">vec2</span>(<span class="number">0.29</span>, <span class="number">-0.29</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line"></span><br><span class="line">pl2[<span class="number">5</span>] = box(<span class="type">vec2</span>(<span class="number">0.58</span>, <span class="number">0.0</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line">pl2[<span class="number">6</span>] = box(<span class="type">vec2</span>(<span class="number">-0.58</span>, <span class="number">0.0</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line">pl2[<span class="number">7</span>] = box(<span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">0.58</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line">pl2[<span class="number">8</span>] = box(<span class="type">vec2</span>(<span class="number">0.0</span>, <span class="number">-0.58</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line"></span><br><span class="line">pl2[<span class="number">9</span>] = box(<span class="type">vec2</span>(<span class="number">0.58</span>, <span class="number">0.58</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line">pl2[<span class="number">10</span>] = box(<span class="type">vec2</span>(<span class="number">-0.58</span>, <span class="number">0.58</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line">pl2[<span class="number">11</span>] = box(<span class="type">vec2</span>(<span class="number">-0.58</span>, <span class="number">-0.58</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line">pl2[<span class="number">12</span>] = box(<span class="type">vec2</span>(<span class="number">0.58</span>, <span class="number">-0.58</span>), <span class="number">0.39</span>, <span class="number">0.39</span>, <span class="number">0.035</span>, <span class="number">0.003</span>, st);</span><br><span class="line"></span><br><span class="line">p = <span class="built_in">max</span>(p, maxList(pl2));</span><br></pre></td></tr></table></figure>
<p>得到图 7 的图案后，我们还需要为其蒙上一层阴影（可对比原图），这样后面裁切的时候会有一些立体感。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> shadow()&#123;</span><br><span class="line">    <span class="type">float</span> r = uResolution.x * <span class="number">0.4</span>;</span><br><span class="line">    <span class="type">vec2</span> center = <span class="type">vec2</span>(uResolution.x/<span class="number">2.0</span>, uResolution.y-r<span class="number">-5.0</span>);</span><br><span class="line">    <span class="type">vec2</span> st = <span class="built_in">gl_FragCoord</span>.xy - center;</span><br><span class="line">    st /= uResolution.x * <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">smoothstep</span>(<span class="number">0.9</span>, <span class="number">0.3</span>, st.y+<span class="number">0.5</span>*st.x*st.x<span class="number">-0.1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec3</span> veins()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(veinsBgColor, veinsFgColor, p)*shadow();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里为了方便，使用了一个开口朝下，中轴和 y 轴重合的抛物线（st.y + 0.5<em>st.x</em>st.x - 0.1）来模拟圆形的阴影。这样我们就得到了图 8。</p>
<p>最后，原设计稿中红色边框和透明背景的效果，对整个图像进行了两次裁切。裁切掉的部分，分别用红色和透明色来填充。依次得到图 9 和 图 10 的结果。图 10 也就是最终的结果。</p>
<figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">vec3</span> circle(<span class="type">vec3</span> veinsColor)&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> r = uResolution.x * <span class="number">0.4</span>;    </span><br><span class="line">    <span class="type">vec2</span> center = <span class="type">vec2</span>(uResolution.x/<span class="number">2.0</span>, uResolution.y-r<span class="number">-5.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec2</span> dxy = <span class="built_in">gl_FragCoord</span>.xy - center;</span><br><span class="line">    <span class="type">float</span> dist = <span class="built_in">sqrt</span>(dxy.x*dxy.x+dxy.y*dxy.y);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = dist/r;</span><br><span class="line">    p = <span class="built_in">smoothstep</span>(<span class="number">0.95</span>, <span class="number">0.96</span>, p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">mix</span>(veinsColor, borderColor, p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">vec4</span> clip(<span class="type">vec3</span> color)&#123;</span><br><span class="line">    <span class="type">float</span> r = uResolution.x * <span class="number">0.4</span>;    </span><br><span class="line">    <span class="type">vec2</span> center = <span class="type">vec2</span>(uResolution.x/<span class="number">2.0</span>, uResolution.y-r<span class="number">-5.0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">vec2</span> dxy = <span class="built_in">gl_FragCoord</span>.xy - center;</span><br><span class="line">    <span class="type">float</span> dist = <span class="built_in">sqrt</span>(dxy.x*dxy.x+dxy.y*dxy.y);</span><br><span class="line"></span><br><span class="line">    <span class="type">float</span> p = <span class="built_in">smoothstep</span>(<span class="number">1.0</span>, <span class="number">1.02</span>, dist/r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="type">vec4</span>(color, <span class="number">1.0</span>-p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> main()&#123;</span><br><span class="line">    <span class="type">vec3</span> res = veins();</span><br><span class="line">    res = circle(res);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gl_FragColor</span> = clip(res);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h1><p>通过上面三个例子，可以看到，合理地使用 WebGL 可以对页面进行精雕细琢的优化，可以减少对图片的依赖，避免使用大尺寸的透明图层，可以做一些全局性/背景性的动画效果。由于 WebGL 是给了开发者「逐个像素」进行着色的能力，开发者可以非常灵活地使用 shader 来做事情。所以说，灵活地使用 shader ，可以帮助你把页面变得更小，更炫，更快。</p>
<p>其实复刻后的页面里还有一些其他用 shader 完成的小玩意儿，比如底部 loading bar 的动态颜色渐变，以及中部文字「魅族手机祝你新春快乐」上掠过的高光，因为点比较小，用到的技术也比较简单，就不再详细介绍了。</p>
<p>（完）</p>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/NFs6dRTBgaM" target="_blank" rel="noopener">https://unsplash.com/photos/NFs6dRTBgaM</a> By @Ferdinand Stöhr</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1zdJ_qeOSBuNjy0FdXXbDnVXa-900-500.jpg" alt="活用 Shader，让你的页面更小，更炫，更快"></p>
<p>可编程着色器（shader）是运行在 GPU]]>
    </summary>
    
      <category term="WebGL" scheme="http://taobaofed.org/tags/WebGL/"/>
    
      <category term="shader" scheme="http://taobaofed.org/tags/shader/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rax 系列教程（长列表）]]></title>
    <link href="http://taobaofed.org/blog/2018/03/12/long-list-in-rax/"/>
    <id>http://taobaofed.org/blog/2018/03/12/long-list-in-rax/</id>
    <published>2018-03-12T08:46:38.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1GMRPdKOSBuNjy0FdXXbDnVXa-900-500.jpg" alt="Rax 系列教程（长列表）"></p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>Rax 提供的长列表标签有很多，在什么场景下使用什么列表组件，怎样选择列表组件性能会更好，这些问题可能会给刚接触 Rax 的同学带来困扰。本文结合 Rax 0.5 发布版本对列表能力进行一次详细的梳理。</p>
<h2 id="如何让页面滚动"><a href="#如何让页面滚动" class="headerlink" title="如何让页面滚动"></a>如何让页面滚动</h2><p>在开始正题之前先说说为什么要有长列表的概念，以及如何让页面可以滚动。</p>
<p>传统的 Web 页面天生在浏览器里就是可以滚动的，我们额外引入一个滚动容器的概念好像比较多余。但当我们做跨容器开发时，这一层概念就变的有意义。native 的页面天生不可滚动，需要借助滚动容器的滚动能力，比如 iOS 中的 UITableView、Android 中的 RecyclerView，通过组件的方式让页面的部分内容可以滚动。</p>
<p>写好了一个页面发现在 Weex 上是白屏，很可能就是滚动容器没有撑开。真实需求中我们往往想要整个页面滚动，首先要解决的就是屏幕高度问题。下面这段是比较常用的页面占满全屏的手段。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123; <span class="attr">position</span>: <span class="string">'position'</span>, <span class="attr">top</span>: <span class="number">0</span>, <span class="attr">bottom</span>: <span class="number">0</span>, <span class="attr">width</span>: <span class="number">750</span> &#125;&#125;&gt;</span><br><span class="line">  &lt;RecyclerView /&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于动态设置高度的场景，我们可以通过 dom.getComponentRect 方法得到页面可是区域的高度。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dom = <span class="built_in">require</span>(<span class="string">'@weex-module/dom'</span>);</span><br><span class="line">dom.getComponentRect(<span class="string">'viewport'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.result, e.size);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如此以来我们的页面就可以自由滚动，通过下拉刷新、加载更多能力的组合让我们的滚动容器更贴近 Web 体验。</p>
<h2 id="现有列表与能力范围"><a href="#现有列表与能力范围" class="headerlink" title="现有列表与能力范围"></a>现有列表与能力范围</h2><p>Rax 目前提供了很多列表组件，相关基础组建以及主要特点如下：</p>
<ul>
<li>rax-scrollview (水平滚动推荐方案)<ul>
<li>Weex 上实现是 slider，支持垂直和水平的滚动</li>
<li>无法做 cell 回收，内容过多时会有性能问题</li>
</ul>
</li>
<li>rax-recyclerview (最常用高性能推荐方案)<ul>
<li>Weex 实现是 list，可回收的长列表，不可水平滚动</li>
<li>性能上有很大优化，滚动体验流畅</li>
</ul>
</li>
<li>rax-listview (RN 习惯)<ul>
<li>RecyclerView 的上层包装，对标 RN 的能力</li>
<li>对性能和列表多样化展示有更高要求的推荐使用 RecyclerView</li>
</ul>
</li>
<li>rax-waterfall (瀑布图场景推荐)<ul>
<li>底层实现上也是 list 的一个扩展，在 API 能力上向 ListView 靠拢</li>
</ul>
</li>
</ul>
<h2 id="长列表基础能力"><a href="#长列表基础能力" class="headerlink" title="长列表基础能力"></a>长列表基础能力</h2><p>作为最基础的推荐实现方案，以 rax-recyclerview 为例，介绍几个列表的重要功能</p>
<h3 id="onEndReached"><a href="#onEndReached" class="headerlink" title="onEndReached"></a>onEndReached</h3><p>当页面滚动到底部时，往往我们会有继续加载的操作，Weex 上 loadmore 事件。对应到 rax-recyclerview 就是 onEndReached 属性。</p>
<p>在 Weex 中 onEndReached 出发后如果 cell 个数没有发生变化，文档的高度没有继续撑开，则不会重复加载 onEndReached，这种保护措施让我们避免了重复加载，但同时也引入了另外一个问题。</p>
<p><img src="https://gw.alicdn.com/tps/TB1ZNSJOVXXXXXMXpXXXXXXXXXX-716-352.png_400x400.jpg" alt></p>
<p>上面这个例子展示的逻辑是切换 tab 改变同一 list 的功能，当我切换 tab 后更新列表的数据条数与上一个 tab 触发 onEndReached 的位置相同时，会发现 onEndReached 失效了。原因就是不会重复触发导致的，解决方案就是使用 列表的 resetScroll 方法重置列表的滚动情况。下面是示例代码：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.refs.list.resetScroll();</span><br></pre></td></tr></table></figure>
<h3 id="refresh"><a href="#refresh" class="headerlink" title="refresh"></a>refresh</h3><p>下拉刷新是 web 浏览器的原生体验，Weex 上的模拟是通过列表标签内的 RefreshControl 组件实现，注意的是 RefreshControl 需要放在列表的第一个元素，如果有标签在 refresh 之前会导致 RefreshControl 无法正常展示。</p>
<h3 id="appear"><a href="#appear" class="headerlink" title="appear"></a>appear</h3><p>在上手教程中介绍过这个事件，onAppear 事件可以让我们在元素出现的时候做一些事情，在 Web 上 Rax 的 framework 同样提供了 Appear 事件用来抹平与 Weex 的差异。appear 的一些注意点如下</p>
<ul>
<li>appear 需要绑定在 滚动容器内不，不然 Weex 上无法生效</li>
<li>appear 的能力实际上是基于 onScroll，过多的 appear 对于滚动性能会稍有影响</li>
<li>appear 是一个滑动过程中可能频繁触发的事件，在这里的 setState 逻辑需要自己把控好</li>
</ul>
<h3 id="onScroll"><a href="#onScroll" class="headerlink" title="onScroll"></a>onScroll</h3><p>滚动过程中我们需要实时的做一些操作时会用到 onScroll，onScroll 时计 setState 更新内容是一个成本很大的事情，需要注意是否过频繁的操作会引起页面的卡顿，另外在滚动过程中的动画操作我们推荐使用 <a href="https://github.com/alibaba/bindingx" target="_blank" rel="noopener">BindingX</a> ，这个实现方案可以减小通信成本达到性能的提升，如下示例：</p>
<p>完整 demo 在这里，下面代码展示滚动过程中一个元素的动画</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">binding.bind(&#123;</span><br><span class="line">  eventType: <span class="string">'scroll'</span>,</span><br><span class="line">  anchor: list,</span><br><span class="line">  props: [</span><br><span class="line">    &#123;</span><br><span class="line">      element: image,</span><br><span class="line">      property: <span class="string">'transform.translateY'</span>,</span><br><span class="line">      expression: image_origin</span><br><span class="line">    &#125;,</span><br><span class="line">  ]</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="页面的组织"><a href="#页面的组织" class="headerlink" title="页面的组织"></a>页面的组织</h2><h3 id="简单可滚动页面"><a href="#简单可滚动页面" class="headerlink" title="简单可滚动页面"></a>简单可滚动页面</h3><p><img width="200px" src="https://gw.alicdn.com/tps/TB1VLrpMVXXXXaQXpXXXXXXXXXX-406-723.gif"></p>
<p>撑满设备屏幕的 View 内部的滚动容器默认就是高度撑开的，此种场景是我们业务中用到最多也是最基础的滚动场景。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123; <span class="attr">position</span>: <span class="string">'position'</span>, <span class="attr">top</span>: <span class="number">0</span>, <span class="attr">bottom</span>: <span class="number">0</span>, <span class="attr">width</span>: <span class="number">750</span> &#125;&#125;&gt;</span><br><span class="line">  &lt;RecyclerView /&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="页面部分固定"><a href="#页面部分固定" class="headerlink" title="页面部分固定"></a>页面部分固定</h3><p><img width="200px" src="https://img.alicdn.com/tps/TB1tWO2KVXXXXaFXVXXXXXXXXXX-392-701.gif"></p>
<p>如果页面中有部分是固定的其余部分可以滚动我们可以采用如下方式，这种场景通常用来作为顶部导航或者底部 bar。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123; <span class="attr">position</span>: <span class="string">'position'</span>, <span class="attr">top</span>: <span class="number">0</span>, <span class="attr">bottom</span>: <span class="number">0</span>, <span class="attr">width</span>: <span class="number">750</span> &#125;&#125;&gt;</span><br><span class="line">  &lt;View style=&#123;&#123; <span class="attr">height</span>: <span class="number">80</span> &#125;&#125; /&gt;</span><br><span class="line">  &lt;RecyclerView /&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="模块吸顶"><a href="#模块吸顶" class="headerlink" title="模块吸顶"></a>模块吸顶</h3><p><img width="200px" src="https://img.alicdn.com/tps/https://gw.alicdn.com/tfs/TB1Ie46XKSSBuNjy0FlXXbBpVXa-272-480.gif"></p>
<p>楼层吸顶是一个较为常见的会场类页面需求，通常的实现方案是 RecyclerView.Header 标签，需要注意的是 Rax 0.5 版本中还未对 RecyclerView.Header 做 web 上的实现，需要业务上处理，可以将样式设置为 fixed，或者将要吸顶元素拷贝到列表外部。上面的演示图效果更为复杂，使用到了 binding。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123; <span class="attr">position</span>: <span class="string">'position'</span>, <span class="attr">top</span>: <span class="number">0</span>, <span class="attr">bottom</span>: <span class="number">0</span>, <span class="attr">width</span>: <span class="number">750</span> &#125;&#125;&gt;</span><br><span class="line">  &lt;RecyclerView&gt;</span><br><span class="line">    &lt;RecyclerView.Header /&gt;</span><br><span class="line">  &lt;<span class="regexp">/RecyclerView&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>View&gt;</span><br></pre></td></tr></table></figure>
<h3 id="横滑切换多页面"><a href="#横滑切换多页面" class="headerlink" title="横滑切换多页面"></a>横滑切换多页面</h3><p><img width="200px" src="http://gw.alicdn.com/mt/LB18hRSQpXXXXbPXXXXXXXXXXXX-375-667.gif"></p>
<p>性能的优化带来的是体验的提升，我们可以不再拘泥于刷新页面来切换页面。这就有了横滑翻页的尝试。其主要思路就是通过手势来进行横滑拖拽。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123;<span class="attr">width</span>: <span class="number">750</span>, <span class="attr">position</span>: <span class="string">'absolute'</span>, <span class="attr">top</span>: <span class="number">0</span>, <span class="attr">bottom</span>: <span class="number">0</span>&#125;&#125;&gt;</span><br><span class="line">  &lt;Tab ...  /&gt;</span><br><span class="line">  &lt;TabController ... &gt;</span><br><span class="line">    &lt;TabPanel&gt;<span class="xml"><span class="tag">&lt;<span class="name">SamplePage</span> <span class="attr">index</span>=<span class="string">"0"</span> /&gt;</span><span class="tag">&lt;/<span class="name">TabPanel</span>&gt;</span></span></span><br><span class="line">    &lt;TabPanel&gt;<span class="xml"><span class="tag">&lt;<span class="name">SamplePage</span> <span class="attr">index</span>=<span class="string">"1"</span> /&gt;</span><span class="tag">&lt;/<span class="name">TabPanel</span>&gt;</span></span></span><br><span class="line">    &lt;TabPanel&gt;<span class="xml"><span class="tag">&lt;<span class="name">SamplePage</span> <span class="attr">index</span>=<span class="string">"2"</span> /&gt;</span><span class="tag">&lt;/<span class="name">TabPanel</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/TabController&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>View&gt;</span><br></pre></td></tr></table></figure>
<p>此处我们还将引申出另外一个文章，《Rax 系列教程（单页）》敬请期待</p>
<h3 id="模拟滚动嵌套"><a href="#模拟滚动嵌套" class="headerlink" title="模拟滚动嵌套"></a>模拟滚动嵌套</h3><p><img width="200px" src="https://img.alicdn.com/tps/https://gw.alicdn.com/tfs/TB15wTxauuSBuNjy1XcXXcYjFXa-272-480.gif"></p>
<p>随着页面交互形式的越来越复杂，更丰富的体验效果不断的出现。如上图横滑页面的部分上方出现一个公共区域。目前业务中较的实现方案是滚动下方的容器过程中去动态改变一个静态的 header，页面组织形式如下：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;&#123;<span class="attr">width</span>: <span class="number">750</span>, <span class="attr">position</span>: <span class="string">'absolute'</span>, <span class="attr">top</span>: <span class="number">0</span>, <span class="attr">bottom</span>: <span class="number">0</span>&#125;&#125;&gt;</span><br><span class="line">&lt;Parallax&gt; header 部分 &lt;<span class="regexp">/Parallax&gt;</span></span><br><span class="line"><span class="regexp">  &lt;Tab ...  /</span>&gt;</span><br><span class="line">  &lt;TabController ... ／&gt;</span><br><span class="line">&lt;<span class="regexp">/View&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中 Parallax 的部分也可以用 View 加动画的方式实现，不过这种效果毕竟是模拟一个滚动嵌套，还不完美。</p>
<h2 id="长列表使用技巧"><a href="#长列表使用技巧" class="headerlink" title="长列表使用技巧"></a>长列表使用技巧</h2><h3 id="水平与垂直滚动嵌套"><a href="#水平与垂直滚动嵌套" class="headerlink" title="水平与垂直滚动嵌套"></a>水平与垂直滚动嵌套</h3><p>垂直滚动容器中往往会有水平横滑的场景，实现的方案有很多种，比如 Slider 组件可以完成水平的滚动轮播，Tabheader 可以作为可横滑的 tab，如果想要更佳令我我们还可以用 ScrollView 自己实现一个水平的滚动。</p>
<p>在垂直与水平嵌套的场景中需要注意一点，就是水平滚动容器并不能尽兴节点的回收，所以横滑内容过长可能会引发性能问题，需要合理规划横滑内容。</p>
<h3 id="手势冲突"><a href="#手势冲突" class="headerlink" title="手势冲突"></a>手势冲突</h3><p>手势动画我们可以用与 RN 能力对其的 PanResponder，当然我们更推荐性能更加优秀的 <a href="https://github.com/alibaba/bindingx" target="_blank" rel="noopener">BindingX</a> 手势，在 Rax 的标签元素上绑定 onTouchStart 这样的事件也是支持的。在这些能力支持的基础上有一些坑也是需要我们注意的，比如手势与滚动行为相互吃掉。垂直长列表默认就有上下滚动的行为，此时我们想要做一些手势处理的需求时可能要先考虑一下手势的方向会不会被滚动容器的滚动所影响。</p>
<p>一种情况是垂直滑动手势，页面垂直滚动时尽量避免垂直的手势行为。虽然我们可以通过禁用滚动等方式模拟手势滑动，但目前 iOS 和安卓仍然有支持程度不同的兼容问题。所以如果垂直滑动时想要做一些事情，推荐使用 onScroll 事件 或者 BindingX 的 scroll 方法来解决。</p>
<p><img width="600px" src="https://gw.alicdn.com/tfs/TB1.kFcRXXXXXbhapXXXXXXXXXX-826-330.png"></p>
<p>另一种情况是水平横画手势，如上图。页面由 4 个 tab 组成，横画页面可以切换 tab，此事如果我们对容器再绑定水平的华东手势，就会对横画切 tab 的行为造成影响。为了避免这种冲突，我们推荐使用原生 slider 进行页面内的水平滚动操作，省区我们自己处理这一层冲突。</p>
<h3 id="电梯跳转"><a href="#电梯跳转" class="headerlink" title="电梯跳转"></a>电梯跳转</h3><p><img src="https://gw.alicdn.com/tfs/TB1BdBdaSBYBeNjy0FeXXbnmFXa-649-483.png_400x400.jpg" alt></p>
<p>每年大促的页面中我们几乎都能看到电梯的身影，实现的基本思路是 Weex 下利用 Weex dom 模块的 scrollToElement 方法跳转到页面的制定元素，h5 下用锚点进行条转。此时需要页面楼层之间斤两撑开，避免页面抖动的情况。</p>
<p>还有一种方式是利用滚动容器的 scrollTo 方法跳转指定举例，此方式需要在跳转前严格计算每个楼层的高度。</p>
<h3 id="模块的顺序保证"><a href="#模块的顺序保证" class="headerlink" title="模块的顺序保证"></a>模块的顺序保证</h3><p>在长列表数据更新或者模块更新的过程中，如果没有指定每个 cell 之间的顺序就可能出现楼层错位问题，指定的方式就是每个 cell 指定唯一的 key。如果摸个模块返回的是多个 cell 的暑促，那除了每个 cell 指定 key 这个模块也需要指定一个唯一的 key。</p>
<h3 id="视差滚动"><a href="#视差滚动" class="headerlink" title="视差滚动"></a>视差滚动</h3><p>视差滚动需求目前提供了两种解决方案，一种是 Weex 的 parallax 标签，另一种是使用 BindingX 进行视差滚动的模拟。</p>
<h2 id="Web-与-Weex-列表上的不同"><a href="#Web-与-Weex-列表上的不同" class="headerlink" title="Web 与 Weex 列表上的不同"></a>Web 与 Weex 列表上的不同</h2><p>此处说明配合 Rax 0.5 版本。</p>
<ul>
<li>下拉刷新： web 有原生的下拉刷新体验，RefreshControl 仅有 weex 的实现</li>
<li>吸顶：web 上没有实现 RecyclerView.Header 的吸顶效果</li>
<li>电梯：楼层跳转方式不同，web 上采用锚点或距离的方式，Weex 采用 scrollToElement 方法</li>
<li>回收机制：web 上没有节点的回收</li>
<li>appear：weex 原生支持 appear，并且只能在滚动容器内部才能生效，web 是根据元素是否在可视区域进行模拟的</li>
</ul>
<h2 id="长列表的性能注意点"><a href="#长列表的性能注意点" class="headerlink" title="长列表的性能注意点"></a>长列表的性能注意点</h2><ul>
<li>当列表数据过长时，不推荐用 ScrollView 作为页面级别的滚动容器，RecyclerView 有更好的滚动性能（非可视区域 cell 的回收机制）</li>
<li>RecyclerView 的 cell 拆分粒度越细越好</li>
<li>同一 cell 内部不要放置太多图片，保持尽量简洁一致的 cell 结构利于原生 tableview cell 视图复用</li>
<li>cell recycle = false 属性会破坏 cell 的内存回收机制</li>
<li>WaterFall 的 header 没有回收机制，不建议瀑布图头部 header 过长</li>
<li>嵌套太深不利于回收，建议最大深度不超过 15</li>
<li>列表内如果有大量视频需要控制视频标签数量，建议非可视区域的视频区块用图片代替</li>
<li>更新列表数据时，如果 cell 内部有类似事件绑定 onClick={()=&gt;{}} 每次渲染会实例化新的 function 导致列表内容 diff 前后对比不一致，会触发 cell 的重新 render</li>
<li>为避免长列表内元素的重复渲染，可在组件实现上 shouldComponentUpdate 时机可以将其 return 掉</li>
<li>列表内存暴涨、滑动卡顿 优先排查页面是否有频繁的 setState</li>
</ul>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/V7gVxlUE5aY" target="_blank" rel="noopener">https://unsplash.com/photos/V7gVxlUE5aY</a> By @Toa Heftiba</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1GMRPdKOSBuNjy0FdXXbDnVXa-900-500.jpg" alt="Rax 系列教程（长列表）"></p>
<h2 id="引子"><a href="#引子" class="he]]>
    </summary>
    
      <category term="Rax" scheme="http://taobaofed.org/tags/Rax/"/>
    
      <category term="list" scheme="http://taobaofed.org/tags/list/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[G3D —— Hybrid 环境下的 WebGL 3D 渲染引擎]]></title>
    <link href="http://taobaofed.org/blog/2018/03/05/intro-to-g3d/"/>
    <id>http://taobaofed.org/blog/2018/03/05/intro-to-g3d/</id>
    <published>2018-03-05T08:36:31.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1Df1Ab1OSBuNjy0FdXXbDnVXa-900-500.png" alt="G3D —— Hybrid 环境下的 WebGL 3D 渲染引擎"></p>
<p>G3D 是一款基于 WebGL 的 JavaScript 3D 渲染引擎，借助 GCanvas，G3D 可以运行在 Weex，ReactNative 等 hybrid 环境下。G3D 由淘宝终端团队推出，并于 2018 年 3 月与 GCanvas 同时宣布正式开源。</p>
<p>那么就会有同学问了，G3D 和 three.js 有什么不同呀？G3D 和 GCanvas 究竟是什么关系啊？这篇文章，就聊一聊 G3D 这个产品的来龙去脉。</p>
<p><a href="https://alibaba.github.io/G3D/" target="_blank" rel="noopener">G3D 官网</a>，<a href="https://alibaba.github.io/GCanvas/" target="_blank" rel="noopener">GCanvas 官网</a></p>
<h2 id="为什么有-G3D"><a href="#为什么有-G3D" class="headerlink" title="为什么有 G3D"></a>为什么有 G3D</h2><p>G3D 的起源要从 GCanvas 说起。</p>
<p>GCanvas 在 Weex 和 React Native 环境下提供了浏览器环境中 Canvas 的绘图能力，手机淘宝 App 的 Weex 容器已经内置了 GCanvas。和 Canvas 一样，GCanvas 的绘图能力包括 2D 上下文和 WebGL 上下文的绘图能力。2D 上下文相对较为简单，可以直接拿来使用；而 WebGL 上下文比较复杂，从 WebGL API 到真正的 3D 应用之间往往还需要一层 3D 渲染引擎，社区中的 three.js，Babylon.js 等就是这类 3D 渲染引擎中的翘楚。</p>
<p>GCanvas 开发团队曾尝试把 three.js 和 Babylon.js 接入到 GCanvas 环境中来，遇到了一些困难：</p>
<ul>
<li>社区中的 WebGL 渲染引擎依赖了大量的 DOM API 和原生对象，在 Weex 与 React Native 环境中不存在这些 API 与原生对象。开发团队也曾尝试对 Babylon.js 和 three.js 进行改造，但发现成本比较高，而且后续跟进原版项目 bugfix 与功能迭代的难度也比较大。</li>
<li>如 GCanvas 文档所述， GCanvas 目前仅支持 WebGL API 的一个子集。直接引入 Babylon.js 和 three.js，在 GCanvas 环境下还暂时无法正常工作。</li>
<li>由于 three.js 和 Babylon.js 的体积已经比较巨大，其中很多功能在手机淘宝的业务场景中暂时用不到。因此，即使能够成功改造，巨大的 JS 体积也会拖垮手淘中很多页面的性能。</li>
</ul>
<p>所以，GCanvas 开发团队决定从零开始开发一个小型的 WebGL 渲染引擎 G3D，并以此作为 GCanvas 3D 能力的辅助。可以预见，G3D 和 GCanvas WebGL 将会是相辅相成，互相促进，共同发展；并且在较长一段时间内，G3D 将是使用 GCanvas WebGL 能力，除了直接操作原生 WebGL API 之外的唯一选择。</p>
<h2 id="G3D-有哪些功能"><a href="#G3D-有哪些功能" class="headerlink" title="G3D 有哪些功能"></a>G3D 有哪些功能</h2><p>G3D 具有 3D 渲染引擎的基本功能：</p>
<ul>
<li>定义场景，定义透视相机。</li>
<li>光照方面，目前支持 1)环境光；2)平行光；3)点光；4)穹顶光。</li>
<li>材质方面，目前支持 1)基于冯氏反射模型的冯式面材质（朗伯面是冯氏面的一种特殊情况）；2) 非光照材质。</li>
<li>几何体方面，目前支持直接创建的几何体包括立方体，球体，圆柱，圆锥，折线；当然更多情况下是可以通过解析模型数据创建几何体。</li>
<li>模型解析方面，目前支持 1) OBJ/MTL 模型；2) STL 模型这两种模型格式。</li>
<li>交互：支持 3D点选/拖拽（由于 GCanvas framebuffer 仍未正常，此功能仅在浏览器中有效）。</li>
<li>动画：支持骨骼动画和蒙皮动画。</li>
</ul>
<p>值得注意的是，由于 G3D 需要运行在 Hybrid 环境下，无法依赖 DOM API，所以与 three.js，Babylon.js 等浏览器环境的引擎相比，G3D 无法支持诸如声音播放，文件加载等非渲染核心功能。举例来说，如果使用 three.js 加载模型，只需要调用相关方法传入模型的 url 即可，three.js 会自动加载和解析模型；但在使用 G3D 时，你需要手动获取该文件的内容（Hybrid 与浏览器会不一样），然后将内容字符串传入 G3D.MeshBuilder 的相关方法。</p>
<h2 id="G3D-的未来"><a href="#G3D-的未来" class="headerlink" title="G3D 的未来"></a>G3D 的未来</h2><p>目前 G3D 已经在淘宝 3D 定制等业务中有所使用，在未来的半年到一年里，G3D 主要的目的有两个：</p>
<ul>
<li>追赶 Babylon.js 和 three.js 的高阶功能，如阴影、Shader材质、预处理、法线纹理、光线追踪等等，在其过程中推动 GCanvas WebGL 的完善，同时赋能业务和社区。</li>
<li>进一步打通 G3D 与建模-动画工具链的通道，完善模型-材质数据结构，提升渲染效果，达到「（Blender 等工具中）所见即（G3D渲染出）所得」的开发体验，最大程度地降低 3D 项目的开发成本。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB1Df1Ab1OSBuNjy0FdXXbDnVXa-900-500.png" alt="G3D —— Hybrid 环境下的 WebGL 3D 渲染引擎"></p>
<p>G3D 是一款基于 We]]>
    </summary>
    
      <category term="G3D" scheme="http://taobaofed.org/tags/G3D/"/>
    
      <category term="Hybrid" scheme="http://taobaofed.org/tags/Hybrid/"/>
    
      <category term="WebGL" scheme="http://taobaofed.org/tags/WebGL/"/>
    
      <category term="3D" scheme="http://taobaofed.org/tags/3D/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[淘宝技术部 2018 实习生内部推荐启动啦]]></title>
    <link href="http://taobaofed.org/blog/2018/02/27/2018-intern-recruitment/"/>
    <id>http://taobaofed.org/blog/2018/02/27/2018-intern-recruitment/</id>
    <published>2018-02-27T10:31:55.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://img.alicdn.com/tfs/TB106aubntYBeNjy1XdXXXXyVXa-900-500.jpg" alt="淘宝技术部 2018 实习生内部推荐启动啦"></p>
<h2 id="我们是谁？"><a href="#我们是谁？" class="headerlink" title="我们是谁？"></a>我们是谁？</h2><p>我们是淘宝终端技术与基础业务团队，包含 前端、客户端、后端 三个团队有 150+ 同学。</p>
<h3 id="前端团队"><a href="#前端团队" class="headerlink" title="前端团队"></a>前端团队</h3><p>我们负责：导购业务、内容业务、商家业务、基础交易业务、创新业务、店铺业务等大多数淘宝内的前端开发，在过程中不断沉淀，并借助团队具备前端和客户端两个职能岗位的优势，建立起了强大的终端技术体系：</p>
<ul>
<li>多终端体系：在 WEEX 容器上，建立完整的生态体系，包含了：DSL、工程&amp;工具体系、组件体系、底层能力扩展、体检&amp;监控体系、运行态解决方案、国际化能力等等，面向开发者做到 iOS、Android、Web 的三端一致性，面向用户做到极致体验；</li>
<li>泛搭建体系：基于 WEEX 以及基础体系之上，结合业务形态和技术思考，建立一套完整的泛搭建体系，角色包含了设计师、前端、后端、产品、运营、测试，这一完整职能岗位链路，能力上从 Sketch 生成代码、模块开发、数据源标准化接入、站点搭建、投放能力以及线上数据监控，很好的将业务与技术结合在一起；</li>
<li>中后台体系：面向中后台产品建立了一套解决方案，非前端开发人员也能低门槛低成本的开发中后台页面，整个体系包括了：基础组件体系、上层业务物料体系、开发者工具&amp;平台、设计师工具&amp;平台、教学体系，以低成本的方式赋能给开发者和设计师，提升中后台产品的研发成本；</li>
<li>ISV 开放体系：打造了无线店铺的装修开放体系，系统化的将本地开发 IDE、云构建、安全&amp;性能检测、开发市场鉴权、发布上架，运行态安全方案等环节融合在一起，降低 ISV 开发者成本，同时为整个手淘开放生态，提供了基础能力；</li>
<li>图形化体系：追求在图形渲染上的极致能力，自主研发了直调 OpenGL ES 的图形渲染引擎，同时在上层提供的 JS-SDK 以及 bridge 上兼容了 Canvas 写法，让开发者快速享受到更高性能的渲染引擎；</li>
</ul>
<h3 id="客户端团队"><a href="#客户端团队" class="headerlink" title="客户端团队"></a>客户端团队</h3><p>我们主要做的项目有：</p>
<ul>
<li>无线终端动态化体系：基于自研的 Dinamic 模版技术方案，构建了模版开发、搭建、投放方案。作为无线开发基础设施，解决了手机淘宝包括首页、详情、交易、我的淘宝等众多基础产品的业务场景需求，有效平衡了高性能与灵活性的要求，充分提升了开发效率；</li>
<li>无线业务治理体系：通过服务接口治理与代码治理技术方案，有效感知基础产品服务能力的调用情况与流量分布，有效完成线上的实时报警与业务有效回归，同时有效推动产品迭代；</li>
</ul>
<h3 id="后端开发团队"><a href="#后端开发团队" class="headerlink" title="后端开发团队"></a>后端开发团队</h3><p>负责淘宝的基础交易链路和创新业务：</p>
<ul>
<li>你在手淘能用到的基础交易产品收藏夹、足迹、购物车、正向交易(下单、支付成功页、订单列表、订单详情；预售、大秒、拼团；)、逆向交易(退货、退款、上门取件)、服务平台、商品详情等业务都在我们团队； 这里有巨大的流量、高并发、大数据场景等你来挑战；</li>
<li>我们有很多创新的业务在孵化，虚拟充值业务：游戏、加油卡、苹果充值等你来玩；卡券、教育、租赁等行业创新业务持续孵化中； 这里有最前沿的业务玩法和思维碰撞，等你来创新；</li>
</ul>
<p>我们的技术涵盖大型分布式架构、大数据、实时计算、人工智能等等：</p>
<ul>
<li>支持双 11 交易 32w 峰值创建的世界记录的大型分布式架构如何设计，在这里你能找到答案；</li>
<li>海量的订单数据、人与商品关系数据、用户访问数据如何保存和实时分析，这里你能找打答案；</li>
<li>我们的工程技术如何灵活的去支持快速多变的游戏、加油卡、苹果充值、租赁等等创新业务，并快速上线，如何利用最前沿的工程技术快速支持丰富的业务，这里你能找到答案；</li>
<li>我们直面淘宝大量的消费者，致力于打造淘宝新零售生态的基础业务设施和创新产品，有大数据、有高流量、有丰富场景；</li>
</ul>
<h2 id="我们需要这样的你"><a href="#我们需要这样的你" class="headerlink" title="我们需要这样的你"></a>我们需要这样的你</h2><ul>
<li>在 2019.1.1 - 2019.12.31 之间毕业；</li>
<li>熟悉使用 git 工具，最好有自己的 github 仓库；</li>
<li>关注新事物、新技术，有较强的学习能力，喜欢挑战；</li>
<li>对你擅长的领域（前端、客户端、后端）具备一定的技能和经验；</li>
</ul>
<h2 id="快来投递"><a href="#快来投递" class="headerlink" title="快来投递"></a>快来投递</h2><p>当前通道投递截止到 4 月 14 日，通过此通道投递将进行提前面试、定向进入我们团队。如果错过后续投递将走集团统一分配，不定项分配，不保证进入我们团队。</p>
<p>此外内推成功之后你可能会收到完善简历的信息，请尽快补充简历以及相关详细信息。详实、完善的信息有利于面试官筛选进入下一轮面试哦！</p>
<p>联系方式：</p>
<p>方式一：发邮件（推荐）。</p>
<p>请将你的 <em>姓名、电话、学校学历、专业、简历</em> 等信息发送到 <a href="mailto:fed-campus-2018@list.alibaba-inc.com" target="_blank" rel="noopener">fed-campus-2018@list.alibaba-inc.com</a> 邮箱中。也可以 <a href="mailto:fed-campus-2018@list.alibaba-inc.com?subject=【你的名字】申请校招面试&amp;body=姓名：小李%0A电话：13344449999%0A学校学历：xx大学 本科%0A专业：计算机科学与技术" target="_blank" rel="noopener">点击这个链接唤起邮件 APP</a>。</p>
<p>方式二：提交表单。</p>
<p>请用手机扫码进入我们的 H5 招聘页面提交你的相关信息：</p>
<p><img src="https://img.alicdn.com/tfs/TB1hlZCa49YBuNjy0FfXXXIsVXa-380-378.jpg" alt></p>
<p>提交后可以分享到朋友圈让同学也来提交哦。</p>
<p><strong>注意：如有意向请尽快投递，我们将会尽快操作以免错失机会。</strong></p>
<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="工作地点在哪里？"><a href="#工作地点在哪里？" class="headerlink" title="工作地点在哪里？"></a>工作地点在哪里？</h3><p>杭州、北京。</p>
<h3 id="本次内推是否影响-2018-秋季校园招聘？"><a href="#本次内推是否影响-2018-秋季校园招聘？" class="headerlink" title="本次内推是否影响 2018 秋季校园招聘？"></a>本次内推是否影响 2018 秋季校园招聘？</h3><p>不影响</p>
<h3 id="本次内推是否和其他部门春季实习生内推冲突？"><a href="#本次内推是否和其他部门春季实习生内推冲突？" class="headerlink" title="本次内推是否和其他部门春季实习生内推冲突？"></a>本次内推是否和其他部门春季实习生内推冲突？</h3><p>冲突，只能内推一个部门。</p>
<h3 id="本次内推是否和春季实习生招聘自主报名冲突？"><a href="#本次内推是否和春季实习生招聘自主报名冲突？" class="headerlink" title="本次内推是否和春季实习生招聘自主报名冲突？"></a>本次内推是否和春季实习生招聘自主报名冲突？</h3><p>不冲突，内推面试失败，仍可在招聘官网报名，只不过流程更长，需要通过笔试后才有面试机会，而且不定项分配，不保证进入我们团队。</p>
<h3 id="录取后可以马上实习吗？"><a href="#录取后可以马上实习吗？" class="headerlink" title="录取后可以马上实习吗？"></a>录取后可以马上实习吗？</h3><p>内推并面试成功发下 offer 后，有时间就可以马上过来实习。</p>
<blockquote>
<p>题图：<a href="https://unsplash.com/" target="_blank" rel="noopener">https://unsplash.com/</a></p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://img.alicdn.com/tfs/TB106aubntYBeNjy1XdXXXXyVXa-900-500.jpg" alt="淘宝技术部 2018 实习生内部推荐启动啦"></p>
<h2 id="我们是谁？"><a href="#我]]>
    </summary>
    
      <category term="招聘" scheme="http://taobaofed.org/tags/%E6%8B%9B%E8%81%98/"/>
    
      <category term="团队生活" scheme="http://taobaofed.org/categories/%E5%9B%A2%E9%98%9F%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rax 系列教程（native 扫盲）]]></title>
    <link href="http://taobaofed.org/blog/2018/02/06/rax-native-guide/"/>
    <id>http://taobaofed.org/blog/2018/02/06/rax-native-guide/</id>
    <published>2018-02-06T11:28:12.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1nuoFXTtYBeNjy1XdXXXXyVXa-900-500.jpg" alt="Rax 系列教程（native 扫盲）"></p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>Rax 天生就是一个跨容器的解决方案，这让我们不必单独了解 iOS 和 安卓背后做了什么，让我们的开发变得很省心。但真实情况是我们的业务往往同时跑在 web 和 native 两端，web 我们轻车熟路是前端天生的优势，native 对很多人来说就会有些陌生，native 上出现的各种问题用 web 的路子去解释往往会解释不通。据 2017 年底粗略统计 Rax 的用户 70% 是前端同学，本文面向前端，简单介绍一下 Rax 背后的 native 端在做的一些事情。本文吸取了大量前人的经验，对于过深的 native 概念进行了剔除，以求前端同学更好理解，如果想更深入了解的同学可以参考下面附件内容。</p>
<h2 id="Rax-＝-RN-语法-Weex-能力"><a href="#Rax-＝-RN-语法-Weex-能力" class="headerlink" title="Rax ＝ RN 语法 + Weex 能力"></a>Rax ＝ RN 语法 + Weex 能力</h2><p>Rax 是一套基于 React 写法的 Weex 上层 DSL，很自然的我们就会拿来和 RN 进行对比。实际上 Rax 的设计上也是在尽量靠拢 RN。下面我们先来了解一下。</p>
<h3 id="Rax-与-React-Native"><a href="#Rax-与-React-Native" class="headerlink" title="Rax 与 React Native"></a>Rax 与 React Native</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RN: Learn once, write anywhere</span><br></pre></td></tr></table></figure>
<p>Rax 的使用方式和 RN 类似，RN 基于开源 JavaScript 库 React.js 来开发 iOS 和 Android 原生 App，在 JavaScript 中用 React 抽象操作系统原生的 UI 组件，代替 DOM 元素来渲染，比如以 View 取代 div，以 Image 替代 img 等（Rax 此处步调一致）。</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/14e53ead86ead4d3355813e935072df0742a2c95" alt="image | center"></p>
<p>一次学习，便可以编写 iOS 和 Android 两端的代码，这是 RN 的理念。与 RN 不同，Rax 在靠拢 RN 规范的同时，还做了另外一件事情就是跨端，让一次学习变成了一次编写。</p>
<p>作为背景了解可以了解 <a href="https://facebook.github.io/react-native/" target="_blank" rel="noopener">ReactNative</a> 官网，RN 的学习资料比较容易获取这里不再展开。</p>
<h3 id="Rax-与-Weex"><a href="#Rax-与-Weex" class="headerlink" title="Rax 与 Weex"></a>Rax 与 Weex</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Weex: write once run anywhere</span><br></pre></td></tr></table></figure>
<p>Rax 在 Native 端的背后实现则是 Weex，Weex 是一款轻量级的移动端跨平台动态性技术解决方案</p>
<p><img src="http://img1.tbcdn.cn/L1/461/1/dff0329b60fe0637fa286a58a2de4f41497407cf" alt="image | center"></p>
<p>（图引自 ppt《weex-前端》by 子宽/饮源）</p>
<p>流程如下</p>
<ul>
<li>开发者使用 Weex DSL 编程（Vue/Rax）<ul>
<li>历史上还有过 .we 框架，已经不推荐使用</li>
</ul>
</li>
<li>用 transformer 将代码转换为纯 JS 代码</li>
<li>客户端 JS 解析与 UI 绘制</li>
</ul>
<p>Server 端主要职责是 weex DSL 到 JS 的转换，以及 JS 的部署下发<br>Client 端则负责客户端的绘制部分，具体如下：</p>
<ul>
<li>JS framework 其实就是一个 JS 文件, Weex SDK 中的 main.js。framework 主要负责 JS 与 natvie 之间的交互。数据绑定、事件逻辑处理等。</li>
<li>Render Engine 由 Native 代码实现，主要负责界面渲染和少量的事件触发逻辑。所有的布局元素，都会在这一层转化为原生组件。Weex 当前支持内建组件包括 list、scroller、text、image、input 等</li>
<li>目前 V8 已经全部被 JSC 取代</li>
</ul>
<h3 id="framework"><a href="#framework" class="headerlink" title="framework"></a>framework</h3><p>(iOS 角度解析，弱化了部分纯客户端的概念)</p>
<p>SDK 初始化时比业务先注入 JS framework，如下</p>
<p><strong>Weex runtime 初始化</strong></p>
<ul>
<li>Native初始化（JS framework）initSDKEnvironment</li>
<li>JSContext 扩展属性，比如 <code>name</code>，<code>WXEnvironment</code> 等全局的 API</li>
<li>WXBridgeContext registerGlobalFunctions 注册 <code>Native module</code>，<code>component</code>等，给 JSContext 扩展 callback，全部转换成数字 id，每一个 module，component 等都有其对应的 id。</li>
<li>JSContext evaluateScript 执行 JS <code>framework.js</code> 代码</li>
</ul>
<p><strong>业务 bundle 初始化脉络研究</strong></p>
<ul>
<li>WXSDKInstance renderWithURL 注入业务 bundle url</li>
<li>WXBridgeContext callJSMethod 传入 @”createInstance”，以及组织参数args @[instance, temp, options ?: @{}, data]，data就是业务bundle JavaScript字符串</li>
<li>判断 frameworkLoadFinished 是否准备就绪，准备就绪调用@”createInstance”</li>
<li>JSContext globalObject invokeMethod 方法，获取之前初始化时JSContext的“全局对象”引用，类似浏览器的 “window” 对象，也就是执行weex-framework.js中的 <code>createInstance</code> 方法，接收的参数是@[instance, temp, options ?: @{}];</li>
<li>从 weex-framework.js 中的 createInstance 调用到了 Rax framework 的 <code>window api</code> 注入</li>
<li>Rax framework 初始化页面代码，返回全局的 window 环境，（未来使用 createInstanceContext 替换的场景将在后续 framework 的教程中解释）</li>
</ul>
<p>创建 UI 界面的计算是在 JavaScript 这边的，创建和销毁阶段都是由 Native 主动调起 JavaScript 的方法。这里先介绍一下 JSCore，JavaScriptCore 是封装了 JavaScript 和 Objective-C 桥接的 Objective-C API，可以做到 JavaScript 调用 Objective-C，或者 Objective-C 调用 JavaScript。</p>
<p>createInstance 最后 sendTasks 实际上是调用 Weex 仓库 runtime/config.js 的 sendTasks ，而这个方法传递给 callNative。callNative，是Native注册的block，这是JS framework 与 Native 连接脉络的最后一步。</p>
<h3 id="Weex-virtual-DOM"><a href="#Weex-virtual-DOM" class="headerlink" title="Weex virtual-DOM"></a>Weex virtual-DOM</h3><p>Weex 在 JS 端有一层 virtual-DOM 的设计，这一层设计一方面使得 Weex 能够通过 JS 控制 native 的视图层，另外也提供了一个相对中立的规范，供上层 JS 框架调用。</p>
<p><img src="http://img2.tbcdn.cn/L1/461/1/d3562f1fc42fc59767ff05edff11f6e691ad5c86" alt><br>(图片引自《Weex 中的 virtual-DOM 介绍》 by 勾股)</p>
<p>我们在 Weex 中所能感受到的各种视觉效果和交互效果，实际上都是通过这样的 virtual-DOM 结构进行分解和执行的。virtual-DOM 的设计很大程度上借鉴了 HTML DOM 的设计，不论从 API 还是 class，但做了一定的简化和取舍，主要包括以下几点：</p>
<ul>
<li>传统的 HTML DOM 分了很多种 nodeType，比如 Element、TextNode、Comment、CDATA、Entity、Attribute、Fragment … 等， Weex 只保留了 Element 和 Comment ，一个 Element 对应着 native 的一个 View，而 Comment 通常对 native 来说是无意义的，但是它可以帮助 JS 上层的框架用作一些特殊处理时的 placeholder。</li>
<li>传统的 HTML DOM 是既有 attribute 又有 property 的，property 里还包括 style、方法调用这样的特殊 property， Weex 只保留了 attributes，没有 properties ，但支持一个特殊的维度，就是样式 style。</li>
<li>传统的 HTML DOM 是支持同一个 Element 绑定多个事件的，从 JS 和 native 通信的角度，这样做是没有必要的， 所以 Weex 只提供了 DOM Level 0 的事件模型，也就是 onxxx=”fn”。 如果同一个 Element 需要在业务层绑定多个事件，可以在 virtual-DOM 上层再进行封装</li>
<li>传统的 HTML DOM 事件是存在捕获和冒泡阶段的， Weex 做了精简，没有支持冒泡或捕获事件 ，只有在 native 层的当前元素触发该事件才会 fireEvent 给 JS。<br>传统的 HTML DOM 针对每个页面有唯一且现成的 document、document.documentElement、document.body，但是在 Weex 中，由于每个页面需要的初始化 body 类型是有选择的，基本上分 scroller、div、list 这三种，根据页面不同的展示特征而定， 所以 Weex 页面的 document.body 是需要手动创建的，并且有机会制定其类型为 scroller、div、list 其中的一种。</li>
<li>Weex 不支持 XML 的 namespace 语法</li>
</ul>
<h2 id="Weex-与-Web-的天生不同"><a href="#Weex-与-Web-的天生不同" class="headerlink" title="Weex 与 Web 的天生不同"></a>Weex 与 Web 的天生不同</h2><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><p><strong>布局</strong></p>
<p>Flexbox 是 Weex 中默认且唯一的布局模型，不需要手动为元素添加 display: flex; 属性。传统 web 布局花样繁多，不过 Weex 上我们布局的方式有些局限，比如我们无法使用 float 布局，对于 absolute 布局最好我们也需要谨慎使用（长列表性能考虑）。（布局样式参考<a href="https://weex.apache.org/cn/references/common-style.html" target="_blank" rel="noopener">这里</a></p>
<p><strong>样式</strong></p>
<p>Weex 中样式使用限制包括</p>
<ul>
<li>写在组件 style 里的样式只能用在当前组（作用域默认是 scoped）</li>
<li>样式不能继承</li>
<li>文本样式只能作用于 Text 标签，如 fontSize</li>
<li>支持的样式属性有限，如不支持 z-index</li>
</ul>
<p>Weex 对于 CSS 的支持相比 Web 弱了很多，很多酷炫的 CSS 必杀技在 Weex 上是不太好施展拳脚的，所以在我们写样式之前最好能先读一读 Weex 的 <a href="http://weex.apache.org/cn/references/common-style.html" target="_blank" rel="noopener">通用样式</a> 和 <a href="http://weex.apache.org/cn/references/text-style.html" target="_blank" rel="noopener">文本样式</a></p>
<p><strong>单位</strong></p>
<p>Weex 中做元素的布局时需要先了解一下 Rax 在 Weex 上的单位，Weex 天生支持 wx 和 px</p>
<ul>
<li>rem:  Rax 中推荐单位，无单位默认也是 rem，rem 单位是将页面 750 等分计算的，同 Weex 中的 px 单位</li>
<li>wx：该单位是 Weex 特有的单位，它与像素无关</li>
<li>px &amp; 没有单位：对于没有单位或单位为 px 的尺寸，Weex 会乘上当前屏幕的宽和 750 的比值，以这种方式来进行适配不同分辨率的屏幕</li>
</ul>
<p><strong>霸道的 list cell</strong></p>
<p>除了 Web 和 Weex 的差异，在 iOS 和 Android 上同样存在细微的差异。Android list 中的 cell，无法展示内部超出的元素。如下图，我们如果要实现 图 1 的效果，如果直接用绝对定位飘出去，可能在安卓下会被 cell 截断得到图 2 的效果</p>
<p><img src="https://gw.alicdn.com/tfs/TB1cOnwk2DH8KJjy1XcXXcpdXXa-414-219.jpg" alt></p>
<h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>Web 页面天生是可以滚动的，Native 中却不是。于是 Native 中提供了滚动容器来解决。Rax 中的滚动容器有如下几个（对于列表的详细分析这里也不展开，只说 list native 原理部分）</p>
<ul>
<li>ScrollView 的 Weex 实现是 slider，支持垂直和水平的滚动</li>
<li>RecyclerView 的 Weex 实现是 list，可回收的长列表（此标签下面会举例展开细说）</li>
<li>ListView 是 RecyclerView 的上层包装，对标 RN 的能力</li>
<li>WaterFall 底层实现上也是 list 的一个扩展，在 api 能力上向 ListView 靠拢</li>
<li>TemplateList 的 Weex 实现是 recycler-list，是一个基于数据与模版的高性能长列表</li>
</ul>
<p><strong>可回收的长列表 RecyclerView</strong></p>
<p>Rax 的 RecyclerView 是一个高性能的可回收长列表，它的内部实现是 Weex 的 list 标签。Weex Android 的 List 的原生实现是 Android RecyclerView 组件，在 iOS 上则使用的是原生的 UITableView。它又一个重要特性就是可以回收非可视区域的 cell，并进行复用。</p>
<p>Android RecyclerView </p>
<p>在 Android 中，RecyclerView 提供了复用机制来减少内存开销、提升滑动效率，Weex 中 List 也暴露出相应的 API 支持 Cell 复用：设置相同 scopeValue 的 Cell 支持 ViewHolder 复用，这里的 ViewHolder 服用是只重复的数据类型复用，cell 内如果拥有相同的 children 结构，则该类型的 cell 可以复用，滑出可视区域的 cell 会被回收，在内部实现中不通 RecyclerView 的相同结构 cell 也有复用的策略。</p>
<p>iOS UITableView</p>
<p>UITableView 是一个以行数据概念实现的列表，每一行数据都是一个 UITableViewCell。<br>为了性能上更优，利用有限的结构动态切换其内容来尽可能减少资源占用，以达到 cell 复用。<br>UITableView内部有一个缓存池，初始化时使用 initWithStyle:(UITableViewCellStyle) reuseIdentifier:(NSString *) 方法指定一个可重用标识，就可以将这个 cell 放到缓存池。然后在使用时使用指定的标识去缓存池中取得对应的 cell 然后修改 cell 内容即可。以达到滚动时创建的 cell 地址是初始化时已经创建的。（详细不展开，原理在<a href="http://www.cnblogs.com/kenshincui/p/3931948.html" target="_blank" rel="noopener">这里</a>）</p>
<h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>Web 中我们不指定图片的宽高页面会自动撑开，Weex 中却不会，内部实现的不同导致我们渲染图片的时候必须传入宽高（图片默认高度为 0）。虽然我们在图片的 onLoad 事件中可以拿到宽高信息，但此时再设置宽高会产生页面的抖动。在做瀑布流布局时图片的宽高就更加必要了。</p>
<p>另外 Weex 中相比 Web 图片额外做了加载的优化，我们不用考虑 Weex 上的图片懒加载。</p>
<p>不能设置背景图，只能使用图片插入到文档中</p>
<p>针对 gif 图片的显示依赖客户端的图片库，手淘环境可以在 attribute 和 style 上设置 quality=’original’ 解决，这个属性主要是让客户端的图片库不去优化该图片（避免一些 cdn 优化策略在某些 Weex 图片上不适用）</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p>Weex 支持的事件类型有限，支持的事件类型见 <a href="https://weex.apache.org/cn/references/common-event.html" target="_blank" rel="noopener">通用事件</a>，且不区分事件的捕获阶段和冒泡阶段，相当于 DOM 0 级事件。Appear 事件，Page 事件都是和传统 Web 开发思路有所不同的。</p>
<h3 id="内建模块"><a href="#内建模块" class="headerlink" title="内建模块"></a>内建模块</h3><p>Weex 为我们提供了许多内建模块：<br>animation、WebSocket、picker、meta、clipboard、dom、modal、navigator、storage、stream、webview、globalEvent 等等。</p>
<p>这部分是区别于 Web 的一些功能，直接调用移动端设备能力，Rax 中使用内建模块方式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> dom = <span class="built_in">require</span>(<span class="string">'@weex-module/dom'</span>);</span><br><span class="line">dom.getComponentRect(<span class="string">'viewport'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.result, e.size);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在 Rax 项目的实际开发过程中有很多和传统 Web 开发是不同的。我们更多的了解一些背后的机制，会对我们排查问题有所帮助。文章有遗漏之处或者不准确的地方欢迎指出。</p>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/i-P1lmY_e1w" target="_blank" rel="noopener">https://unsplash.com/photos/i-P1lmY_e1w</a> By @Sergey Pesterev</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1nuoFXTtYBeNjy1XdXXXXyVXa-900-500.jpg" alt="Rax 系列教程（native 扫盲）"></p>
<h2 id="引子"><a href="#引子" cla]]>
    </summary>
    
      <category term="Weex" scheme="http://taobaofed.org/tags/Weex/"/>
    
      <category term="Rax" scheme="http://taobaofed.org/tags/Rax/"/>
    
      <category term="native" scheme="http://taobaofed.org/tags/native/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现一个 JavaScriptCore 的 debugger —— iOS 篇]]></title>
    <link href="http://taobaofed.org/blog/2018/01/23/implement-javascriptcore-debugger-ios/"/>
    <id>http://taobaofed.org/blog/2018/01/23/implement-javascriptcore-debugger-ios/</id>
    <published>2018-01-23T03:30:45.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1c7mhoh6I8KJjy0FgXXXXzVXa-900-500.jpg" alt="实现一个 JavaScriptCore 的 debugger —— iOS 篇"></p>
<p>JSC 的 debugger 是个神奇的东西，在网上资料甚少，几乎完全搜索不到，尤其是 iOS 上，OC 接口没有暴露任何 debugger 信息。</p>
<p>不过好在 JSC 是开源的，通过分析源代码可以找到 JSC::Debugger 这个抽象类，我们继承这个抽象类，然后实现掉虚函数，创建实例并且把它挂载到 global object 即可开启 debug 能力了。</p>
<p>思路是简单的，在 iOS 设备上，我们要面临的另一个问题是它的 JavaScriptCore 本身是以 Framework 的形式而非源代码形式提供的，所以我们只有公开的 OC 头文件和静态库文件。</p>
<p>所以要想使用 debugger，我们需要：</p>
<ol>
<li>编译时使用私有的头文件<ul>
<li>确保头文件的版本跟 framework 一致</li>
<li>确保编译选项跟 framework 一致</li>
</ul>
</li>
<li>链接时链接 framwork 中的方法</li>
</ol>
<p>如何解决呢？步骤如下：</p>
<ol>
<li>查看 framework 中的 JSC 版本</li>
<li>根据 JSC 版本，找到对应的源代码</li>
<li>构建 JSC 获取私有头文件</li>
<li>建立新项目，引入私有 JSC 头文件</li>
<li>调整宏和编译选项</li>
<li>编写代码</li>
</ol>
<h2 id="查看-framework-中的-JSC-版本"><a href="#查看-framework-中的-JSC-版本" class="headerlink" title="查看 framework 中的 JSC 版本"></a>查看 framework 中的 JSC 版本</h2><p>framework 是一个文件夹（在 XCode 中右键即可打开），可以从tbd 文件中找到系统中库的路径（一般是 /System/Library/Frameworks/JavaScriptCore.framework/ ），然后从 version.plist 中找到当前版本。</p>
<p>在我的 XCode9.2中，找到的版本是 604.4.7.1.3。</p>
<h2 id="下载源代码"><a href="#下载源代码" class="headerlink" title="下载源代码"></a>下载源代码</h2><p>在 <a href="https://svn.webkit.org/repository/webkit/tags" target="_blank" rel="noopener">https://svn.webkit.org/repository/webkit/tags</a> 可以找到对应的源代码。</p>
<p>注意一般 opensource.apple.com 中找不到对应版本。</p>
<p>我们并不需要整个 webkit 代码，所以只要下载 source 目录下的 bmalloc, WTF 和 JavaScriptCore 三个项目就够了。</p>
<h2 id="构建-JSC"><a href="#构建-JSC" class="headerlink" title="构建 JSC"></a>构建 JSC</h2><p>首先我们需要建立一个 workspace，然后把三个项目文件拖进 workspace。</p>
<p>依次构建 bmalloc、WTF 和 JavaScriptCore 三个项目即可。</p>
<p>如果配置正确，构建 JSC 应该不会遇到什么困难。</p>
<p>我们只需要构建好的头文件，所以不需要选择 iOS 设备，使用默认的 mac 作为目标就好了。</p>
<h2 id="建立新项目"><a href="#建立新项目" class="headerlink" title="建立新项目"></a>建立新项目</h2><p>接下来我们要建立一个 Debugger 项目，随便叫什么名字，选择 iOS 项目。</p>
<p>我们需要调整编译选项：</p>
<ul>
<li>other C++ flags: -std=c++14</li>
<li>enable C++ runtime Types: No</li>
<li>system header search path: $(PRODUCT_NAME)/</li>
<li><p>Processor Macros：（太多了，建议直接到项目文件源代码里修改）</p>
<p>  ENABLE_3D_TRANSFORMS,<br>  ENABLE_ACCELERATED_OVERFLOW_SCROLLING,<br>  ENABLE_APPLE_PAY,<br>  ENABLE_APPLE_PAY_SESSION_V3,<br>  ENABLE_ATTACHMENT_ELEMENT,<br>  ENABLE_AVF_CAPTIONS,<br>  ENABLE_CACHE_PARTITIONING,<br>  ENABLE_CANVAS_PATH,<br>  ENABLE_CANVAS_PROXY,<br>  ENABLE_CHANNEL_MESSAGING,<br>  ENABLE_CONTENT_FILTERING,<br>  ENABLE_CSS_ANIMATIONS_LEVEL_2,<br>  ENABLE_CSS_BOX_DECORATION_BREAK,<br>  ENABLE_CSS_COMPOSITING,<br>  ENABLE_CSS_DEVICE_ADAPTATION,<br>  ENABLE_CSS_IMAGE_ORIENTATION,<br>  ENABLE_CSS_IMAGE_RESOLUTION,<br>  ENABLE_CSS_REGIONS,<br>  ENABLE_CSS_SCROLL_SNAP,<br>  ENABLE_CSS_SELECTORS_LEVEL4,<br>  ENABLE_CSS_TRAILING_WORD,<br>  ENABLE_CSS3_TEXT,<br>  ENABLE_CURSOR_VISIBILITY,<br>  ENABLE_CUSTOM_SCHEME_HANDLER,<br>  ENABLE_DASHBOARD_SUPPORT,<br>  ENABLE_DATA_INTERACTION,<br>  ENABLE_DATA_TRANSFER_ITEMS,<br>  ENABLE_DATACUE_VALUE,<br>  ENABLE_DATALIST_ELEMENT,<br>  ENABLE_DEVICE_ORIENTATION,<br>  ENABLE_DRAG_SUPPORT,<br>  ENABLE_ENCRYPTED_MEDIA,<br>  ENABLE_FETCH_API,<br>  ENABLE_FILTERS_LEVEL_2,<br>  ENABLE_FTL_JIT,<br>  ENABLE_FULLSCREEN_API,<br>  ENABLE_GAMEPAD_DEPRECATED,<br>  ENABLE_GAMEPAD,<br>  ENABLE_GEOLOCATION,<br>  ENABLE_ICONDATABASE,<br>  ENABLE_INDEXED_DATABASE_IN_WORKERS,<br>  ENABLE_INDEXED_DATABASE,<br>  ENABLE_INPUT_TYPE_COLOR_POPOVER,<br>  ENABLE_INPUT_TYPE_COLOR,<br>  ENABLE_INPUT_TYPE_DATE,<br>  ENABLE_INPUT_TYPE_DATETIME_INCOMPLETE,<br>  ENABLE_INPUT_TYPE_DATETIMELOCAL,<br>  ENABLE_INPUT_TYPE_MONTH,<br>  ENABLE_INPUT_TYPE_TIME,<br>  ENABLE_INPUT_TYPE_WEEK,<br>  ENABLE_INTERSECTION_OBSERVER,<br>  ENABLE_INTL,<br>  ENABLE_IOS_GESTURE_EVENTS,<br>  ENABLE_IOS_TOUCH_EVENTS,<br>  ENABLE_JIT,<br>  ENABLE_KEYBOARD_KEY_ATTRIBUTE,<br>  ENABLE_KEYBOARD_CODE_ATTRIBUTE,<br>  ENABLE_LEGACY_CSS_VENDOR_PREFIXES,<br>  ENABLE_LEGACY_ENCRYPTED_MEDIA,<br>  ENABLE_LEGACY_VENDOR_PREFIXES,<br>  ENABLE_LETTERPRESS,<br>  ENABLE_LINK_PREFETCH,<br>  ENABLE_MAC_GESTURE_EVENTS,<br>  ENABLE_MATHML,<br>  ENABLE_MEDIA_CAPTURE,<br>  ENABLE_MEDIA_CONTROLS_SCRIPT,<br>  ENABLE_MEDIA_SESSION,<br>  ENABLE_MEDIA_SOURCE,<br>  ENABLE_MEDIA_STATISTICS,<br>  ENABLE_MEDIA_STREAM,<br>  ENABLE_METER_ELEMENT,<br>  ENABLE_MHTML,<br>  ENABLE_MOUSE_CURSOR_SCALE,<br>  ENABLE_NAVIGATOR_CONTENT_UTILS,<br>  ENABLE_NAVIGATOR_STANDALONE,<br>  ENABLE_NOTIFICATIONS,<br>  ENABLE_PDFKIT_PLUGIN,<br>  ENABLE_POINTER_LOCK,<br>  ENABLE_PROXIMITY_EVENTS,<br>  ENABLE_PUBLIC_SUFFIX_LIST,<br>  ENABLE_QUOTA,<br>  ENABLE_REMOTE_INSPECTOR,<br>  ENABLE_REQUEST_AUTOCOMPLETE,<br>  ENABLE_RESOLUTION_MEDIA_QUERY,<br>  ENABLE_RESOURCE_USAGE,<br>  ENABLE_RUBBER_BANDING,<br>  ENABLE_SERVICE_CONTROLS,<br>  ENABLE_SPEECH_SYNTHESIS,<br>  ENABLE_STREAMS_API,<br>  ENABLE_SUBTLE_CRYPTO,<br>  ENABLE_SVG_FONTS,<br>  ENABLE_TELEPHONE_NUMBER_DETECTION,<br>  ENABLE_TEXT_AUTOSIZING,<br>  ENABLE_TOUCH_EVENTS,<br>  ENABLE_TOUCH_ICON_LOADING,<br>  ENABLE_USERSELECT_ALL,<br>  ENABLE_VARIATION_FONTS,<br>  ENABLE_VIDEO_PRESENTATION_MODE,<br>  ENABLE_MAC_VIDEO_TOOLBOX,<br>  ENABLE_VIDEO_TRACK,<br>  ENABLE_VIDEO,<br>  ENABLE_VIEW_MODE_CSS_MEDIA,<br>  ENABLE_WEB_ANIMATIONS,<br>  ENABLE_WEB_AUDIO,<br>  ENABLE_WEB_RTC,<br>  ENABLE_WEB_SOCKETS,<br>  ENABLE_WEB_TIMING,<br>  ENABLE_WEBGL,<br>  ENABLE_WEBGL2,<br>  ENABLE_WEBGPU,<br>  ENABLE_WIRELESS_PLAYBACK_TARGET,<br>  ENABLE_XSLTFAST_JIT_PERMISSIONS</p>
</li>
</ul>
<p>然后我们打开构建好的 JSC 项目目标， 复制其中 PrivateHeaders 目录，到项目目录的 JavaScriptCore 目录。</p>
<p>再打开 WTF 项目目标， 复制目录下 /usr/local/include/wtf</p>
<p>接下来，我们需要对源代码做一下小修改，因为系统的 JSC 是在非 debug 模式下编译的，所以我们强行把头文件中跟 debug 相关的代码改成非 debug 模式:</p>
<p>JavaScriptCore/HandleStack.h</p>
<pre><code>所有 #ifdef NDEBUG
</code></pre><p>WTF/hashtable.h</p>
<pre><code>#ifdef NDEBUG
#define CHECK_HASHTABLE_ITERATORS 0
#define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 0
#else
#define CHECK_HASHTABLE_ITERATORS 0
#define CHECK_HASHTABLE_USE_AFTER_DESTRUCTION 0
#endif
</code></pre><h2 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h2><p>代码必须使用 .mm 文件。</p>
<p>我们需要在项目的 build phases 中加入 JavaScriptCore.framework。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;JavaScriptCore/JavaScriptCore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">"JavaScriptCore/HeapInlines.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"JavaScriptCore/HeapCellInlines.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"JavaScriptCore/APICast.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"JavaScriptCore/Debugger.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"JavaScriptCore/SourceProvider.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"JavaScriptCore/JSRunLoopTimer.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"JavaScriptCore/JSVirtualMachineInternal.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDebugger</span>:</span> <span class="keyword">public</span> JSC::Debugger &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyDebugger(JSC::VM&amp; vm) : JSC::Debugger::Debugger(vm)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~MyDebugger()&#123;</span><br><span class="line">        JSC::Debugger::~Debugger();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*virtual void recompileAllJSFunctions() &#123;</span></span><br><span class="line"><span class="comment">        //JSC::Debugger::recompileAllJSFunctions();</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">sourceParsed</span><span class="params">(JSC::ExecState* state, JSC::SourceProvider* sourceProvider, <span class="keyword">int</span> errorLineNumber, <span class="keyword">const</span> WTF::String&amp; errorMessage)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//StringView sourceString = sourceProvider-&gt;source();</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//NSLog(@"sourceParsed:%@", (NSString*)sourceString.toString());</span></span><br><span class="line">        NSLog(@<span class="string">"sourceParsed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleBreakpointHit</span><span class="params">(JSC::JSGlobalObject*, <span class="keyword">const</span> JSC::Breakpoint&amp;)</span> </span>&#123;</span><br><span class="line">        NSLog(@<span class="string">"handleBreakpointHit"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handleExceptionInBreakpointCondition</span><span class="params">(JSC::ExecState*, JSC::Exception*)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        NSLog(@<span class="string">"handleExceptionInBreakpointCondition"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">handlePause</span><span class="params">(JSC::JSGlobalObject* globalObject, ReasonForPause reason)</span> </span>&#123;</span><br><span class="line">        NSLog(@<span class="string">"handlePause"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">notifyDoneProcessingDebuggerEvents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        NSLog(@<span class="string">"notifyDoneProcessingDebuggerEvents"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JSContext *jsContext = [[JSContext alloc] init];</span><br><span class="line"></span><br><span class="line">JSGlobalContextRef globalContext = [jsContext JSGlobalContextRef];</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JSC::ExecState* es = toJS(globalContext);</span><br><span class="line">JSC::JSGlobalObject* globalObject = es-&gt;vmEntryGlobalObject();</span><br><span class="line"></span><br><span class="line">MyDebugger* debugger = <span class="keyword">new</span> MyDebugger(globalObject-&gt;vm());</span><br><span class="line">globalObject-&gt;setDebugger(<span class="keyword">static_cast</span>&lt;JSC::Debugger*&gt;(debugger));</span><br><span class="line">debugger-&gt;setPauseOnNextStatement(TRUE);</span><br><span class="line"></span><br><span class="line">globalObject-&gt;vm().heap.acquireAccess();</span><br><span class="line">debugger-&gt;activateBreakpoints();</span><br><span class="line">globalObject-&gt;vm().heap.releaseAccess();</span><br></pre></td></tr></table></figure>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[jsContext evaluateScript:<span class="string">@"debugger;"</span>];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/Sf5Q7Ljjf58" target="_blank" rel="noopener">https://unsplash.com/photos/Sf5Q7Ljjf58</a> By @Katerina Pavlickova</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1c7mhoh6I8KJjy0FgXXXXzVXa-900-500.jpg" alt="实现一个 JavaScriptCore 的 debugger —— iOS 篇"></p>
<p>JSC 的 ]]>
    </summary>
    
      <category term="javascriptcore" scheme="http://taobaofed.org/tags/javascriptcore/"/>
    
      <category term="debugger" scheme="http://taobaofed.org/tags/debugger/"/>
    
      <category term="无线开发" scheme="http://taobaofed.org/categories/%E6%97%A0%E7%BA%BF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Rax 系列教程（上手）]]></title>
    <link href="http://taobaofed.org/blog/2018/01/18/rax-in-action/"/>
    <id>http://taobaofed.org/blog/2018/01/18/rax-in-action/</id>
    <published>2018-01-18T08:30:44.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1IYdCnBHH8KJjy0FbXXcqlpXa-900-500.jpg" alt="Rax 系列教程（上手）"></p>
<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>这篇文章针对初学 Rax 的同学，主要介绍 Rax 是什么，开发体验的梳理，以及遇到 Rax 的开发问题如何寻求解决。本文配合 Rax 的 0.5 发布版本推出，结合新版 Rax 对于旧版的教程内容做出部分修正。</p>
<h2 id="1、什么是-Rax"><a href="#1、什么是-Rax" class="headerlink" title="1、什么是 Rax"></a>1、什么是 Rax</h2><p><img src="https://gw.alicdn.com/tfs/TB1CU6ofb_I8KJjy1XaXXbsxpXa-867-203.jpg" alt></p>
<p>Rax 是一个源自淘宝的开源项目 <a href="https://github.com/alibaba/rax" target="_blank" rel="noopener">https://github.com/alibaba/rax</a> 作为 Weex 的上层 DSL 在集团内有广泛的应用。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1vnaVfcrI8KJjy0FhXXbfnpXa-869-275.jpg" alt></p>
<p>除了跨容器、高性能、轻量等特点，Rax 是一个基于 React 写法的跨容器的 js 框架，你会用 React，那么你会很快上手 Rax。<br>当然与 React 也有部分区别，如下：</p>
<ul>
<li>没有 createClass() 方法</li>
<li>Rax setState() 是同步的, React setState 是异步的</li>
<li>findDOMNode() 方法可以接收字符串类型的 id</li>
<li>PropTypes 只是 React 的接口兼容</li>
</ul>
<p>下面是一个最简单的示例，在学习本文的过程中可以通过 <a href="https://alibaba.github.io/rax/playground" target="_blank" rel="noopener">Playground</a> 进行练习，体验 Rax 的功能。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1xFm0fm_I8KJjy0FoXXaFnVXa-692-345.jpg" alt></p>
<h2 id="2、基础知识储备"><a href="#2、基础知识储备" class="headerlink" title="2、基础知识储备"></a>2、基础知识储备</h2><p>If you use React, you already know how to use Rax.</p>
<h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>熟悉 React 的同学一定对 JSX 不陌生，Rax 的 DSL 语法是基于 React JSX 语法而创造。与 React 不同，在 Rax 中 JSX 是必选的，它不支持通过其它方式创建组件，所以学习 JSX 是使用 Rax 的必要基础。</p>
<p>JSX 是一个看起来很像 XML 的 JavaScript 语法扩展。 它只是一种语法糖。<br>它是类似 HTML 标签的表达式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;View style=&#123;styles.text&#125;&gt;</span><br><span class="line">    &lt;Text style=&#123;styles.title&#125;&gt;</span><br><span class="line">      hello</span><br><span class="line">    &lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>View&gt;</span><br></pre></td></tr></table></figure>
<p>JSX 只是 JavaScript 语法的一个语法映射。 JSX 表达式执行函数调用，我们可以看成他就是调用 createElement() 方法的快捷方式。 Babel 内置的支持 JSX 语法的编译。</p>
<p>扩展阅读：</p>
<ul>
<li><a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">React Displaying Data</a></li>
<li><a href="https://reactjs.org/docs/jsx-in-depth.html" target="_blank" rel="noopener">React JSX In Depth</a></li>
</ul>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>Rax 的生命周期与 React 中的概念是相同的</p>
<ul>
<li>渲染阶段: componentWillMount、render、componentDidMount</li>
<li>存在阶段: componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、componentDidUpdate</li>
</ul>
<p><img src="https://gw.alicdn.com/tfs/TB1f2REhZLJ8KJjy0FnXXcFDpXa-635-432.jpg_400x400.jpg" alt></p>
<p>推荐使用 ES6 类方式创建组件, 每个组件都需要有一个 render 方法，用来接收数据然后返回要显示在页面上的内容。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Text</span>&gt;</span>Hello &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展阅读</p>
<ul>
<li><a href="https://alibaba.github.io/rax/guide/component" target="_blank" rel="noopener">开发组件文档中对于生命周期的描述</a></li>
</ul>
<h3 id="通用事件"><a href="#通用事件" class="headerlink" title="通用事件"></a>通用事件</h3><p><strong> 点击事件 </strong> </p>
<p>对于简单的 Touch 事件，我们使用 Touchable 组件, 通过给它绑定 onPress 事件，来监听他的点击事件。移动设备中为了区分点击与长按操作，通常点击事件会有 300 毫秒的延迟。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Touchable onPress=&#123;() =&gt; <span class="built_in">console</span>.log(<span class="string">'pressed'</span>)&#125;&gt;</span><br><span class="line">  &lt;Text&gt;Touch&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>Touchable&gt;</span><br></pre></td></tr></table></figure>
<p><strong> 长按事件 </strong></p>
<p>weex 的 <code>&lt;input&gt;</code> 和 <code>&lt;switch&gt;</code> 组件目前不支持 click 事件，使用的时候需要注意。</p>
<p><strong> Appear </strong></p>
<p>Appear 可以让我们在元素出现的时候做一些事情，比如曝光埋点。在 Web 上 Rax 的 framework 同样提供了 Appear 事件用来抹平与 Weex 的差异。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;View onAppear=&#123;(ev) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'appear'</span>);</span><br><span class="line">&#125;&#125; onDisappear=&#123;(ev) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'disappear'</span>);</span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line">  &lt;Text&gt;Hello&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>View&gt;</span><br></pre></td></tr></table></figure>
<p>使用时需要注意，Appear 事件需要绑定在滚动容器内的元素上。</p>
<p><strong> 滚动事件 </strong></p>
<p>目前提供的滚动容器 ScrollView、RecyclerView、ListView、WaterFall 均支持一下滚动事件与属性</p>
<ul>
<li>onScroll：滚动实时触发事件</li>
<li>onEndReachedThreshold：滚动区域还剩 loadmoreoffset 的长度时触发</li>
<li>onEndReached：滚动到容器底部触发事件</li>
</ul>
<p><strong> 输入事件 </strong></p>
<p>TextInput 是唤起用户输入的基础组件。当定义 multiline 输入多行文字时其功能相当于 textarea。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextInput</span><br><span class="line">  placeholder=<span class="string">"Enter text to see events"</span></span><br><span class="line">  autoFocus multiline</span><br><span class="line">  onFocus=&#123;() =&gt; <span class="built_in">console</span>.log(<span class="string">'onFocus'</span>)&#125;</span><br><span class="line">  onBlur=&#123;() =&gt; <span class="built_in">console</span>.log(<span class="string">'onBlur'</span>)&#125;</span><br><span class="line">  onInput=&#123;() =&gt; <span class="built_in">console</span>.log(<span class="string">'onInput'</span>)&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<p><strong> 复杂手势 </strong></p>
<p>与 React Native 中的 PanResponder 相同的手势支持外，Rax 还提供了 Weex 上性能表现更好的 binding 手势支持（未来开源）。</p>
<p><strong> Page 事件 </strong></p>
<p>Weex 通过 viewappear 和 viewdisappear 事件提供了简单的页面状态管理能力，需要注意的是目前该事件 Web 不支持。</p>
<p>viewappear 事件会在页面就要显示或配置的任何页面动画被执行前触发，例如，当调用 navigator 模块的 push 方法时，该事件将会在打开新页面时被触发。viewdisappear 事件会在页面就要关闭时被触发。</p>
<p>与组件的 appear 和 disappear 事件不同的是，viewappear 和 viewdisappear 事件关注的是整个页面的状态，所以它们必须绑定到页面的根元素上</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> weexDocument = <span class="keyword">typeof</span> __weex_document__ === <span class="string">'object'</span> ?</span><br><span class="line">      __weex_document__ : <span class="keyword">typeof</span> <span class="built_in">document</span> === <span class="string">'object'</span> ?</span><br><span class="line">        <span class="built_in">document</span> : &#123;&#125;;</span><br><span class="line"><span class="keyword">if</span> (isWeex &amp;&amp; weexDocument &amp;&amp; weexDocument.body) &#123;</span><br><span class="line">  setNativeProps(findDOMNode(weexDocument.body), &#123;</span><br><span class="line">    style: &#123;<span class="attr">backgroundColor</span>: <span class="string">'yellow'</span>&#125;,</span><br><span class="line">    onViewAppear: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'onviewappear'</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">    onViewDisAppear: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'onviewdisappear'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展阅读</p>
<ul>
<li><a href="https://alibaba.github.io/rax/guide/event-handle" target="_blank" rel="noopener">Rax 中的事件</a></li>
<li><a href="http://weex.apache.org/cn/references/common-event.html" target="_blank" rel="noopener">Weex 中的事件</a></li>
</ul>
<h3 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h3><p>在书写 Rax 页面样式之前需要知道几件事情</p>
<ul>
<li>Rax 无单位与 rem 单位等价</li>
<li>页面宽度默认是 750rem，各端兼容</li>
<li>为了与 Weex 有一致的效果，我们推荐 Flexbox</li>
</ul>
<p>Rax 样式支持行内样式与 className</p>
<p><strong> 行内 </strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">'./foo.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&#123;styles.container_title&#125;</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong> className </strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'./foo.css'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">"container"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">"container_title"</span>&gt;</span>hello world<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>扩展阅读</p>
<ul>
<li><a href="https://alibaba.github.io/rax/guide/style" target="_blank" rel="noopener">Flexbox 和样式</a></li>
<li><a href="https://weex.apache.org/cn/references/common-style.html" target="_blank" rel="noopener">Weex 通用样式</a></li>
<li><a href="https://weex.apache.org/cn/references/text-style.html" target="_blank" rel="noopener">Weex 文本样式</a></li>
</ul>
<h2 id="3、Rax-的-Driver"><a href="#3、Rax-的-Driver" class="headerlink" title="3、Rax 的 Driver"></a>3、Rax 的 Driver</h2><p>不同场景的 Driver 让 Rax 在不同的运行环境下都有一个良好的表现，在 Weex 和 Browser 上的表现是我们平时业务上最关心的，除此之外 Rax 有更多的尝试</p>
<h3 id="Driver-weex"><a href="#Driver-weex" class="headerlink" title="Driver-weex"></a>Driver-weex</h3><ul>
<li>Device 相关，抹平与 web 的差异</li>
<li>setRem（基准值的设定（getDeviceWidth/getViewportWidth））</li>
<li>部分样式处理（transformPropsAttrsToStyle）</li>
<li>w3cElements 能力的提供<ul>
<li>span p img button video textarea nav footer aside main h1 h2 h3 …</li>
</ul>
</li>
</ul>
<h3 id="Driver-browser"><a href="#Driver-browser" class="headerlink" title="Driver-browser"></a>Driver-browser</h3><ul>
<li>Device 相关，抹平与 Weex 的差异</li>
<li>flex 布局相关<ul>
<li>抹平不同浏览器之间的差异（webkit 前缀的支持）</li>
</ul>
</li>
</ul>
<h3 id="Driver-server"><a href="#Driver-server" class="headerlink" title="Driver-server"></a>Driver-server</h3><ul>
<li>服务端渲染的基础方法支持</li>
</ul>
<h3 id="Driver-webgl"><a href="#Driver-webgl" class="headerlink" title="Driver-webgl"></a>Driver-webgl</h3><ul>
<li>一套标签化的 3d 场景描述<ul>
<li>carmeras control core geometries lights materials objects(line mesh points scene) scenes…</li>
</ul>
</li>
<li>three 的上层包装</li>
</ul>
<p><img style="width: 200px" src="https://gw.alicdn.com/tfs/TB1ZwVgh26H8KJjy0FjXXaXepXa-382-672.gif"></p>
<h2 id="4、Rax-的-framework"><a href="#4、Rax-的-framework" class="headerlink" title="4、Rax 的 framework"></a>4、Rax 的 framework</h2><p>Write Once, Run everywhere!</p>
<p>Native 和 Web 天生就有很多差异，为了让开发者有更好的体验，大部分的差异是不需要让开发者去关心的。因此 Native 端我们模拟出了大量 Web 端的标准全局 API，Web 端同样为了模拟 Native 的特性做了很多支持。</p>
<h3 id="weex-rax-framework"><a href="#weex-rax-framework" class="headerlink" title="weex-rax-framework"></a>weex-rax-framework</h3><ul>
<li>全局的 window 变量（全局方法的注册）</li>
<li>跨页面实例的 emitter 通信与页面内通信 (addEventListener)</li>
<li>location, Response, Request, XMLHttpRequest, URL, URLSearchParams, FontFace, WebSocket, Event, CustomEvent, matchMedia, setTimeout, setInterval, requestAnimationFrame…</li>
<li><strong>weex_define</strong>, <strong>weex_require</strong>, <strong>weex_downgrade</strong>, <strong>weex_env</strong>, <strong>weex_code</strong>, <strong>weex_options</strong>, <strong>weex_data</strong>, <strong>weex_config</strong> …</li>
</ul>
<h3 id="web-rax-frmework"><a href="#web-rax-frmework" class="headerlink" title="web-rax-frmework"></a>web-rax-frmework</h3><ul>
<li>Object.assign Object.entries Object.values…</li>
<li>Array.from </li>
<li>Number.isNaN</li>
<li>appear 模拟，抹平 weex 之间的差异</li>
<li>defaule builtin modules</li>
</ul>
<h2 id="5、上层体系"><a href="#5、上层体系" class="headerlink" title="5、上层体系"></a>5、上层体系</h2><h3 id="环境-API"><a href="#环境-API" class="headerlink" title="环境 API"></a>环境 API</h3><p>Rax Framework 参照 W3C 规范，提供了以下在 Weex 和 Web 环境一致的全局 API，例如你可以在 Weex 的页面这样使用全局的 postMessage</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">addEventListener(<span class="string">'message'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'this data is'</span>, e.data);</span><br><span class="line">&#125;);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.postMessage(<span class="string">'&#123;hello:1&#125;'</span>, <span class="string">'*'</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p>（全局 API 的可用环境为 Weex 版本 &gt;=0.9.5 可用，对应手淘版本 &gt;= 6.4.0 可用，低于该版的设备建议可以考虑降级 h5）</p>
<h3 id="通用组件"><a href="#通用组件" class="headerlink" title="通用组件"></a>通用组件</h3><p><img src="https://gw.alicdn.com/tfs/TB1XrNQh2DH8KJjy1XcXXcpdXXa-419-379.jpg" alt></p>
<p>Rax 的通用组件主要的工作就是对表 Weex 的基础标签，在保证功能完备的基础上抹平 Web 的实现。<br>基础组件的 API 设计是遵照 RN 的思路。举个例子，Weex 为我们提供了通用的 click 事件，但是对标 RN 的规范，我们还是推荐开发者使用 Touchable 标签的 press 实现点击。Rax 作为开源项目与社区接轨也是为了能够更好的与社区融合，我们也可以更方便的吸纳社区的力量。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1C_pzh4rI8KJjy0FpXXb5hVXa-838-385.jpg" alt></p>
<p>基础的组件可以组成复杂的组件或者模块，上面的 tabheader 就是个例子。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1Lzglh_nI8KJjy0FfXXcdoVXa-868-330.jpg" alt></p>
<p>无论什么类型的页面我们都可以通过组件进行拼装，随着业务需求的发展，我们还会遇到很多新点子，很多新的挑战。我们鼓励开发者可以提炼出更多通用的功能或者组件贡献给 Rax。</p>
<p><img src="https://gw.alicdn.com/tfs/TB19PE1OVXXXXcsaXXXXXXXXXXX-1020-699.jpg" alt></p>
<p>想了解更多 Rax 组件能力，可以参考 Rax 的<a href="https://alibaba.github.io/rax/" target="_blank" rel="noopener">官网</a>和<a href="https://github.com/alibaba/rax/tree/master/packages" target="_blank" rel="noopener">github</a></p>
<h2 id="6、开发环境"><a href="#6、开发环境" class="headerlink" title="6、开发环境"></a>6、开发环境</h2><h3 id="rax-cli"><a href="#rax-cli" class="headerlink" title="rax-cli"></a>rax-cli</h3><ul>
<li>cli 命令面向开源用户，不依赖阿里内部的工具以及环境</li>
<li>项目同时构建出 web 与 weex bundle</li>
</ul>
<p>环境安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install rax-cli -g</span><br></pre></td></tr></table></figure>
<p>项目初始化</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rax init YourProjectName</span><br></pre></td></tr></table></figure>
<p>页面预览</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd YourProjectName</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>
<p><img src="https://gw.alicdn.com/tfs/TB1FYG8h8TH8KJjy0FiXXcRsXXa-826-382.jpg" alt></p>
<p>查看运行的 Rax 的 bundle 源码会发现首行有一题条这样的注释</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// &#123;&quot;framework&quot; : &quot;Rax&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>bundle 如果缺少该 framework 声明将会有 framework 提供的 API 缺失问题。</p>
<p><em>小技巧：上面的 weex bundle 也可以这样访问 <a href="http://h5Page地址.html?_wx_tpl:http://weexBundle地址.js" target="_blank" rel="noopener">http://h5Page地址.html?_wx_tpl:http://weexBundle地址.js</a></em></p>
<p><img src="https://gw.alicdn.com/tfs/TB1orW8h8TH8KJjy0FiXXcRsXXa-873-360.jpg" alt></p>
<p>cli 工具创建的目录结构较为简单，适合开发者进行上层定制</p>
<h2 id="7、调试环境"><a href="#7、调试环境" class="headerlink" title="7、调试环境"></a>7、调试环境</h2><p>###调试环境###</p>
<p>使用 cli 工具本地起一个调试环境，生成如下形式的页面地址：<br><a href="http://your_page_.html?_wx_tpl=http://your_page_bundle.js" target="_blank" rel="noopener">http://your_page_.html?_wx_tpl=http://your_page_bundle.js</a></p>
<p>在浏览器环境直接访问该地址，可以得到 Web 页面；通过 Weex Playground 访问，则会返回相应的 Weex 页面。</p>
<p>###调试工具###</p>
<p>1、 weex-toolkit（本地调试）</p>
<p>我们使用 <a href="https://weex.apache.org/cn/guide/tools/toolkit.html" target="_blank" rel="noopener">weex-toolkit</a> 来进行调试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tnpm install -g weex-toolkit</span><br><span class="line">weex debug -l</span><br></pre></td></tr></table></figure>
<p>扩展阅读</p>
<ul>
<li><a href="https://alibaba.github.io/rax/guide/weex-rax-debug" target="_blank" rel="noopener">Rax 项目调试</a></li>
</ul>
<h2 id="8、发布"><a href="#8、发布" class="headerlink" title="8、发布"></a>8、发布</h2><h3 id="发布注意事项"><a href="#发布注意事项" class="headerlink" title="发布注意事项"></a>发布注意事项</h3><ul>
<li>业务发布前，必须在以下环境完成测试<ul>
<li>Weex(Android/iOS) 未降级的客户端版本</li>
<li>Web(Android/iOS) 未降级和已降级的客户端版本</li>
<li>有外投多个客户端的业务需要在每个客户端做以上回归</li>
</ul>
</li>
<li>手淘版本无法做到全量覆盖，如业务依赖某个手淘版本，必须<ul>
<li>在该手淘环境和线上环境都完成测试</li>
<li>明确发布先后顺序</li>
<li>明确在老版本手淘下访问的兼容方案</li>
</ul>
</li>
<li>离线包无法做到全量更新，如业务使用离线包，必须<ul>
<li>明确改动不会对未覆盖到版本造成影响（如果接口的不兼容变更）</li>
<li>紧急问题的修复采用【强制更新+推新包+全网络】的策略</li>
</ul>
</li>
<li>使用内置组件的业务应提前做好充足的降级的预案<ul>
<li>内置组件 bundle 降级完整 bundle 规则</li>
<li>Weex bundle 降级 h5 规则</li>
</ul>
</li>
<li>业务发布后，必须再次验证以上环境</li>
</ul>
<h2 id="9、完整的例子"><a href="#9、完整的例子" class="headerlink" title="9、完整的例子"></a>9、完整的例子</h2><p>我知道怎么写一个 hello world，但对于如何写一个项目可能还有些无从下手，我们能找到一些成品的例子作为参考。Rax 官网提供了大量的 demo 和 模版，帮助新上手的同学进行学习。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1.AIfh3DD8KJjy0FdXXcjvXXa-834-378.jpg" alt></p>
<p>以下页面例子可以参考</p>
<ul>
<li><a href="https://github.com/alibaba/rax/tree/master/packages/template-buy" target="_blank" rel="noopener">淘宝下单页</a></li>
<li><a href="https://github.com/alibaba/rax/tree/master/packages/template-chat" target="_blank" rel="noopener">即时通信类页面</a></li>
<li><a href="https://github.com/alibaba/rax/tree/master/packages/template-retail" target="_blank" rel="noopener">零售通的应用主页</a></li>
<li><a href="https://github.com/alibaba/rax/tree/master/packages/template-taobao" target="_blank" rel="noopener">淘宝首页</a></li>
<li><a href="https://github.com/alibaba/rax/tree/master/packages/template-zhihu" target="_blank" rel="noopener">问答类列表页</a></li>
</ul>
<p>（以上内容是关于 Rax 上手的一些内容，Rax 的其他教程敬请期待～）</p>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/8u5JvXfp4uw" target="_blank" rel="noopener">https://unsplash.com/photos/8u5JvXfp4uw</a> By @rawpixel.com</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1IYdCnBHH8KJjy0FbXXcqlpXa-900-500.jpg" alt="Rax 系列教程（上手）"></p>
<h2 id="引子"><a href="#引子" class="hea]]>
    </summary>
    
      <category term="Rax" scheme="http://taobaofed.org/tags/Rax/"/>
    
      <category term="Web开发" scheme="http://taobaofed.org/categories/Web%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[构筑未来数据网 - Pandora.js 的信息通路]]></title>
    <link href="http://taobaofed.org/blog/2018/01/12/pandora-information-channel/"/>
    <id>http://taobaofed.org/blog/2018/01/12/pandora-information-channel/</id>
    <published>2018-01-12T05:05:26.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1rRShmBfH8KJjy1XbXXbLdXXa-900-500.jpg" alt="构筑未来数据网 - Pandora.js 的信息通路"></p>
<p>上一篇我们介绍了 Pandora.js 度量体系中的 Metrics，通过 Metrics 我们能将应用运行中的数据生成出来，但是有时候我们不仅仅需要这些指标数据，更可能需要信息数据。</p>
<blockquote>
<p>这里的指标数据表示数字值，为了和信息数据（字符串）做区分。</p>
</blockquote>
<p>所谓的信息数据是什么？</p>
<p>在 Pandora.js 中，我们定义为应用的信息聚合，这里分为静态信息和动态信息两种类型，举个例子，应用的应用名，应用启动路径，应用的配置，应用的模块版本这些都是固定的静态信息，而进程列表，接口参数这些就是属于动态信息，当然，这些信息也包括我们上一篇文章提到的 Metrics 信息。</p>
<p>Pandora.js 通过 EndPoint 机制，将这些信息统一暴露出来，通过 Restful 接口，让用户或者外部的调度系统使用。</p>
<p>目前 Pandora.js 内置一些信息接口，包括：</p>
<ul>
<li>健康检查的信息</li>
<li>进程的信息</li>
<li>Daemon 的信息</li>
<li>Node.js 运行时的信息</li>
<li>当前 Metrics 指标结果的信息</li>
<li>链路监控的信息</li>
<li>最近的错误日志的信息</li>
<li>等等。。。</li>
</ul>
<h2 id="如何运作"><a href="#如何运作" class="headerlink" title="如何运作"></a>如何运作</h2><p>所有的接口目前都有在 <a href="http://www.midwayjs.org/pandora/zh-cn/monitor/resource.html" target="_blank" rel="noopener">文档中</a> 提及，这里就不在多加叙述输出的内容，不然就太多余了，我们希望在这里能看到更多细节和运转方式的内容。</p>
<p>放一张数据结构图，这里可以很清楚的看到结构的分布。</p>
<p><img src="https://img.alicdn.com/tfs/TB1zrBUmsLJ8KJjy0FnXXcFDpXa-853-583.png" alt></p>
<p>Pandora.js 把信息通路的机制划分为两部分，monitor 端和其他进程端，monitor 端处于业务进程之外，和其他进程通过  IPC 进行通信数据交互，以保持稳定和隔离。</p>
<p>Pandora.js 内置了最基础的 IPC 服务，通过简单的方式就可以进行数据传输，这里不做过多说明，这里就当已经完成了，如果有兴趣，可以参考代码，我们的关注点还是在数据怎么进行交互的部分。</p>
<h2 id="基础数据格式"><a href="#基础数据格式" class="headerlink" title="基础数据格式"></a>基础数据格式</h2><p>数据格式是所有数据传输的基础，虽然除了 Metrics 我们并没有限定输出什么格式，但是在一定程度上进行约束有助于可读性和扩展性的提升。</p>
<p>对于大多数 JavaScript 信息结构来说，JSON 是最容易被解析和扩展的格式，所以我们在考虑格式的时候第一就选择了 JSON 格式。</p>
<p>以基础信息为例，很容易理解。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"appName"</span>: <span class="string">"hello-world"</span>,</span><br><span class="line">  <span class="attr">"baseDir"</span>: <span class="string">"/home/admin/hello-world"</span>,</span><br><span class="line">  <span class="attr">"nodeVesion"</span>: <span class="string">"v8.3.9"</span>,</span><br><span class="line">  <span class="attr">"nodePath"</span>: <span class="string">"/home/admin/hello-world/node_modules/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这样仅仅是单一的一个维度，每个进程，每个应用<code>至少需要两个维度</code>，基础的信息以及信息的作用域，恰好在 JavaScript 中对象扩展非常容易，只需要简单加一个 key 就行，在这种情况下，把基础结构变化一下就得出了最简单的结构。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"app"</span>: &#123;</span><br><span class="line">    <span class="attr">"appName"</span>: <span class="string">"hello-world"</span>,</span><br><span class="line">    <span class="attr">"baseDir"</span>: <span class="string">"/home/admin/hello-world"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"node"</span>: &#123;</span><br><span class="line">  	<span class="attr">"nodeVesion"</span>: <span class="string">"v8.3.9"</span>,</span><br><span class="line">    <span class="attr">"nodePath"</span>: <span class="string">"/home/admin/hello-world/node_modules/"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就至少有 <code>app</code> 和 <code>node</code> 两个维度了，也方便后期做展示和筛选。</p>
<p>但是单靠规范，其实并不能有效的执行起来，所以基于这些我们制定了 <code>builder</code> 机制，通过传入的 builder 对象来格式化暴露的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invoke</span>(<span class="params">args, builder</span>) </span>&#123;</span><br><span class="line">  builder.withDetail(<span class="string">"app"</span>, &#123;&#125;)</span><br><span class="line">   .withDetail(<span class="string">"node"</span>, &#123;&#125;);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// other code</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> builder.getDetails();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本上 invoke 这个函数就是客户端最核心的数据采集方法了。</p>
<h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2><p>在 Pandora.js 的设计中，我们参考了 <code>spring-boot</code> 的命名习惯，将数据披露的客户端称为 <code>Indicator</code>，每个 Indicator 都会连接到对应的服务端 <code>EndPoint</code> 中，这其中是多对一的关系。</p>
<p><img src="https://img.alicdn.com/tfs/TB1mRZtmlfH8KJjy1XbXXbLdXXa-462-199.png" alt></p>
<p>这样形成的树状结构，可以有效的将数据聚合到一起。</p>
<p>那他们是怎么关联的呢？</p>
<p>很简单，我们使用的是 <code>IPC 广播</code>，在初始化的时候，Indicator 会广播自己初始化的信息，接受到的 EndPoint 就会注册到自己名下，将客户端的信息保存起来。</p>
<p><img src="https://img.alicdn.com/tfs/TB1eJipmDnI8KJjy0FfXXcdoVXa-410-246.png" alt></p>
<p>这个时候又会有一个问题，EndPoint 怎么知道哪个 Indicator 是我名下的？</p>
<p>这个时候就引出了 group（分组）的概念。</p>
<p>每个 EndPoint 都有一个 <code>group</code> 的字段，通过这个字段，我们确定唯一的 EndPoint ，以及该 EndPoint 下所属的 Indicator。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthEndPoint</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  private group = <span class="string">'health'</span>;</span><br><span class="line"></span><br><span class="line">  registerIndicator() &#123;</span><br><span class="line">  	<span class="keyword">if</span> (<span class="keyword">this</span>.group !== data.group) &#123;</span><br><span class="line">        <span class="comment">// 不匹配则忽略</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 把配置回写给所有 indicator</span></span><br><span class="line">    reply(<span class="keyword">this</span>.config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> indicatorProxy = <span class="keyword">new</span> IndicatorProxy(client);</span><br><span class="line">    <span class="comment">// 构建指标</span></span><br><span class="line">    indicatorProxy.buildIndicator(data);</span><br><span class="line">    <span class="keyword">this</span>.indicators.push(indicatorProxy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HealthIndicator</span> </span>&#123;</span><br><span class="line">  private group = <span class="string">'health'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显，当两边的 group 相等的时候，通路就完成了。</p>
<p>当然，实际情况还要更复杂一些，比如需要考虑多个同名 Indicator 的情况，这个时候我们会定义是否是单例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (data.type === <span class="string">'singleton'</span>) &#123;</span><br><span class="line">  <span class="comment">// 单例下，每个应用只允许一个实例存在</span></span><br><span class="line">  <span class="keyword">let</span> indicators = <span class="keyword">this</span>.indicators.filter(<span class="function">(<span class="params">indicator: IndicatorProxy</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> indicator.match(data.appName, data.indicatorName);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (indicators.length) &#123;</span><br><span class="line">    <span class="keyword">this</span>.debug(<span class="string">'indicator type singleton='</span> + data.appName, data.indicatorName);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分组、端聚合、远程调用，这就是 Pandora.js 整个数据披露生态的三个核心关键词。</p>
<h2 id="逆向通路"><a href="#逆向通路" class="headerlink" title="逆向通路"></a>逆向通路</h2><p>实际使用过程中，我们发现，单一的靠远端调用获取信息不一定能满足需求，只能完成类似</p>
<ul>
<li>获取应用信息</li>
<li>获取进程信息</li>
<li>业务状态</li>
<li>端口检查</li>
</ul>
<p>这些已经存在的或者实时性不高的数据的获取，但是还有一类像链路调用，错误日志等这些数据，因为数据量大，实时性高，如果使用 invoke 这样的调用方式，势必会增加复杂度或者额外的性能开销。</p>
<p>通过大量的实践，我们觉得这类数据有一个共同特点，除了数据量大之外，数据都是横跨多个进程，这个时候就有两种方案来解决。</p>
<p>第一种是将数据缓存在客户端，每次调用 invoke 的时候，从客户端缓存拿数据聚合，这样的好处是原有代码结构比较统一，但是多端缓存可能会影响稳定性和数据的一致性。</p>
<p>第二种是将数据缓存在服务端（EndPoint 端），客户端就不是被动调用，而是主动上报了。</p>
<p>权衡之下，我们考虑的是第二种方案，<code>逆向通路</code>就上场了。</p>
<p>所谓的逆向通路，就是客户端采集数据时，先主动上报给服务端缓存，这样服务端拿数据的时候可以直接从缓存中拿取，就不存在数据不一致，或者后期需要聚合的问题，而且缓存的大小可以统一在服务端控制。</p>
<p>为此，我们实现了一个 <a href="http://www.midwayjs.org/pandora/api-reference/metrics/classes/duplexindicator.html" target="_blank" rel="noopener">DuplexIndicator</a> 以及配套的 <a href="http://www.midwayjs.org/pandora/api-reference/metrics/classes/duplexendpoint.html" target="_blank" rel="noopener">DuplexEndPoint</a>，还有加了缓存的 <a href="http://www.midwayjs.org/pandora/api-reference/metrics/classes/cacheduplexendpoint.html" target="_blank" rel="noopener">CacheDuplexEndPoint</a>。</p>
<p>逆向通路增加了一个 <code>report()</code> 方法，可以主动进行上报，这样错误日志和其他内部这类场景的信息就可以这样上报啦。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuplexIndicator</span> <span class="keyword">extends</span> <span class="title">Indicator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  transferType = <span class="string">'duplex'</span>;</span><br><span class="line"></span><br><span class="line">  messengerClient;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ... 省略部分代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 发送上行消息</span></span><br><span class="line"><span class="comment">   * @param data</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  report(data: any) &#123;</span><br><span class="line">    <span class="keyword">this</span>.messengerClient.report(<span class="keyword">this</span>.getClientUplinkKey(), data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DuplexEndPoint</span> <span class="keyword">extends</span> <span class="title">EndPoint</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 登记指标</span></span><br><span class="line"><span class="comment">   * @param data</span></span><br><span class="line"><span class="comment">   * @param reply</span></span><br><span class="line"><span class="comment">   * @param client</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  protected registerIndicator(data, reply, client) &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.group !== data.group) &#123;</span><br><span class="line">      <span class="comment">// 不匹配则忽略</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略部分代码</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构建上行通路</span></span><br><span class="line">    indicatorProxy.buildUplink(<span class="keyword">this</span>.processReporter.bind(<span class="keyword">this</span>));</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  abstract processReporter(data, reply?);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，只需要在恰当的时候，执行客户端的 <code>report</code> 方法即可，而服务端则通过覆盖 <code>processReporter</code> 对传输过来的数据进行相应的处理，比如写入缓存，这里可以查看 <a href="https://github.com/midwayjs/pandora/blob/master/packages/metrics/src/indicator/impl/ErrorIndicator.ts" target="_blank" rel="noopener">Error 采集的源码</a> 来理解。</p>
<h2 id="并没有结束"><a href="#并没有结束" class="headerlink" title="并没有结束"></a>并没有结束</h2><p>在所有的信息传递中，Metrics 是属于比较特殊的一种，他的数据传输方式虽然是基于 IPC 但是有一些不同，受限于篇幅我们留到下期再介绍。</p>
<p>除此之外，下期我们还将介绍对外的接口设计部分，尽情期待。</p>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/RkJF2BMrLJc" target="_blank" rel="noopener">https://unsplash.com/photos/RkJF2BMrLJc</a> By @William Bout</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1rRShmBfH8KJjy1XbXXbLdXXa-900-500.jpg" alt="构筑未来数据网 - Pandora.js 的信息通路"></p>
<p>上一篇我们介绍了 Pandora.js]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="Pandora.js" scheme="http://taobaofed.org/tags/Pandora-js/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[跨越时代的度量衡 - Pandora.js 的 Metrics 介绍]]></title>
    <link href="http://taobaofed.org/blog/2018/01/05/pandora-metrics/"/>
    <id>http://taobaofed.org/blog/2018/01/05/pandora-metrics/</id>
    <published>2018-01-05T03:14:24.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1UpNqlBfH8KJjy1XbXXbLdXXa-900-500.jpg" alt="跨越时代的度量衡 - Pandora.js 的 Metrics 介绍"></p>
<p>自秦始皇统一六国，天下归一，推行“一法度衡石丈尺，车同轨 ，书同文”，颁发统一度量衡诏书，制定了一套严格的管理制度，天底下的度量衡就变成了一套。而如今程序世界也是天下分崩离析，不同编程语言各占一隅，不过即使语法不同，但是分分合合，思路终归一致，想要度量代码的心情依旧是一样的。</p>
<h2 id="度量的作用"><a href="#度量的作用" class="headerlink" title="度量的作用"></a>度量的作用</h2><p>很多同学表示怀疑，为什么要度量？</p>
<p>其实回答很简单，度量就像是身体健康的检查器，就像体检给的报告，没有这份报告，你是不是很担心自己的身体有没有出问题，要是好几年没体检，恐怕焦虑症都要犯了。</p>
<p>平常我们所说的监控报警，其实就是度量的一种具体应用和泛化，其实还有更大更广泛作用，比如：</p>
<ul>
<li>当你上线了一个应用，你怎么知道应用是健康的？</li>
<li>当你发布了一个新功能，你怎么知道这个功能对线上有哪些影响，怎么去评估呢？</li>
<li>当你升级了一个包版本，你怎么知道他是稳定的呢？</li>
</ul>
<p>一切的一切，尽在度量上。</p>
<p>Pandora.js 的度量体系参考了 spring-boot 的命名习惯，以及结合了阿里内部的 alimetrics 体系，加上业界的 opentracing 链路追踪模型，形成了一整套可检查，可度量，可追踪的完整方案。</p>
<p>我们今天来细说 Pandora.js 其中的一种度量机制，这不仅是 Node.js 的度量，也是程序通用的度量 - Metrics。</p>
<h2 id="Metric-的命名"><a href="#Metric-的命名" class="headerlink" title="Metric 的命名"></a>Metric 的命名</h2><p>Metric 的目标是可自我描述，所以在命名上会尽可能的根据业务场景来命名。</p>
<p>在参考了业界的<a href="http://metrics20.org/" target="_blank" rel="noopener">metrics规范</a>，以及结合了阿里集团内使用场景之后，我们使用了基础的 MetricName 对象格式做为 Metric 的名字。</p>
<blockquote>
<p>Metrics 是复数形式，目前这些度量在业界口头表述都可能叫 Metrics ，而实际在代码中对特定的单个指标叫 Metric，而普通的非特定单数形式继续沿用 Metrics 的表述 。</p>
</blockquote>
<p><img src="http://git.cn-hangzhou.oss.aliyun-inc.com/uploads/middleware-container/ali-metrics/bdb57406d27a096835e90be1b204f69f/image.png" alt></p>
<p>MetricName 大体分为两部分，key 和 tags。</p>
<p>key 代表着一个具体的项，比如有一个 metrics 指标是某个 HTTP 接口，那么这个指标的 key 就可能是 <code>application.http.request.path</code>，通过 <code>.</code> 将命令进一步的缩小，每个公司可以有自己不同的规范，根据部门、产品、功能来进行划分，尽量做到 key 可描述，可扩展，所有的单词用下划线<code>&#39;_&#39;</code>连接，字母采用小写形式。</p>
<p>tags 代表着一个指标的不同分类，它和 key 加起来唯一指定了一个 Metric。tags 是一个对象 <code>{}</code>，通过不同的 kv 对来描述详情，比如区分不同请求的来源，继续以 HTTP 接口来举例，<code>{&quot;source&quot;:&quot;shanghai&quot;}</code> 和 <code>{&quot;source&quot;: &quot;hangzhou&quot;}</code> 这样就是不同的 tags，结合 key，就用来表示不同的 Metric 了。</p>
<p>这样的好处就是 tags 可以无限扩展，不会影响到 key，同时，在后续的存储中，同一个 key 可以进行查询筛选，保证数据一致性和连贯性。</p>
<p>具体的实例我们将在之后的实例中介绍。</p>
<h2 id="对外的数据格式"><a href="#对外的数据格式" class="headerlink" title="对外的数据格式"></a>对外的数据格式</h2><p>除了定义 Metric 的名字之外，我们还需要考虑对外输出的格式，既然是 Node 体系，我们首先考虑的自然是 JSON 结构的格式，便于阅读以及数据格式化存储。</p>
<p>基于 MetricName，我们将名字和值定义了成了<a href="http://www.midwayjs.org/pandora/api-reference/metrics/classes/metricobject.html" target="_blank" rel="noopener">通用的 MetricObject 格式</a>。</p>
<p>一个标准的输出格式大概如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"metric"</span>: <span class="string">"sys.cpu.nice"</span>,</span><br><span class="line">    <span class="attr">"timestamp"</span>: <span class="number">1346846400</span>,</span><br><span class="line">    <span class="attr">"value"</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"COUNTER"</span>,</span><br><span class="line">    <span class="attr">"level"</span>: <span class="string">"CRITICAL"</span>,</span><br><span class="line">    <span class="attr">"tags"</span>: &#123;</span><br><span class="line">        <span class="attr">"host"</span>: <span class="string">"web01"</span>,</span><br><span class="line">        <span class="attr">"dc"</span>: <span class="string">"lga"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 MetricName 类似，包含一些常用信息，包括 key，value，时间戳，tags 等。</p>
<p>最终这个数据格式会被内置的 Reporter 体系输出到不同的对外接口中，包括文本文件，HTTP 接口等等，这样外部系统根据这样的内容进行存储，计算，分发，来进行最后的监控，可视化工作，这个不在我们这个体系内，暂时不做过多的介绍了。</p>
<h2 id="Metrics-的类型"><a href="#Metrics-的类型" class="headerlink" title="Metrics 的类型"></a>Metrics 的类型</h2><p>Metric 除了有名字，还有类型，目前最常用的就是瞬时值和计数器，此外还有其他的一些。</p>
<p>在了解业界实践并结合集团内部的实践基础上，我们抽象出以下几种度量场景：</p>
<ul>
<li>累加型度量：对指标的数据进行累加，反映的是数据随着时间单调递增的关系，应用接受到的 HTTP 请求的总次数</li>
<li>瞬态型度量：表示指标在当前时间点的瞬时情况，反映的是数据随着时间上下波动的关系，如系统的load，内存使用率，堆信息等</li>
<li>变化速率度量：表示指标在某个时间段内变化的速率，反映的是数据随时间的增长快慢关系，如某个接口的 QPS</li>
<li>数据分布度量：表示某一些指标在某个时间段内的分布情况，反映的是数据随时间的统计学分布关系，如某段时间内，某个接口的 RT 的最大，最小，平均值，方差，95% 分位数等</li>
</ul>
<p>基于这些场景，结合业界的 Metrics 实现，我们目前提供四种最基础的指标，即:</p>
<ul>
<li>Gauge 瞬态的度量指标</li>
<li>Counter 累加计数型指标</li>
<li>Histogram 分布度量指标</li>
<li>Meter 速率度量指标</li>
</ul>
<blockquote>
<p>目前最常用的是 Gauge 瞬态值以及 Counter 累加值，80% 的场景都可以覆盖</p>
</blockquote>
<p>这样在不同的场景下，我们都可以找到相应的 Metric 类型了。在某些场景下，我们还做了额外的一些指标类型（在阿里内部还有两种聚合的类型，等机会开源）</p>
<h2 id="Metrics-数据生产"><a href="#Metrics-数据生产" class="headerlink" title="Metrics 数据生产"></a>Metrics 数据生产</h2><blockquote>
<p> 目前 Pandora.js 全部使用 TypeScript 来编写，有些代码必须带类型定义。</p>
<p>所有的 Metric 类型都继承与 <a href="http://www.midwayjs.org/pandora/api-reference/metrics/interfaces/metric.html" target="_blank" rel="noopener">Metric 接口</a></p>
</blockquote>
<h3 id="瞬态型度量"><a href="#瞬态型度量" class="headerlink" title="瞬态型度量"></a>瞬态型度量</h3><p>大部分的度量都从瞬态值 Gauge 介绍起，因为它最简单，最直观的表示数据的真实情况，也不涉及时间间隔的问题。</p>
<p>Gauge 只包含一个 <code>getValue</code> 方法，只需要实现这个方法即可，比如，你想要知道当前进程的 CPU 使用情况，就可以一句话解决。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;BaseGauge&gt; &#123;</span><br><span class="line">  getValue() &#123;</span><br><span class="line">  	<span class="keyword">const</span> startUsage = process.cpuUsage();</span><br><span class="line">    <span class="keyword">return</span> startUsage.user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，所有的 Metrics 最终输出的一定是数字形式，这样才可度量，如果你希望输出的是字符串类的信息，我们有另一套输出体系，这将在之后的文章介绍。</p>
</blockquote>
<h3 id="累加型度量"><a href="#累加型度量" class="headerlink" title="累加型度量"></a>累加型度量</h3><p>Counter 是第二个介绍的类型，计数器和 Gauge 不太一样，它是累加型，适用于记录调用总量等类型的数据，比如某个接口的调用次数。</p>
<p>如下图是计数器的继承接口和实现类。</p>
<p><img src="https://img.alicdn.com/tfs/TB1OkX3ldrJ8KJjSspaXXXuKpXa-780-732.png" alt></p>
<p>除了基础的 <code>BaseCounter</code> 实现之外，我们提供了 <code>BucketCounter</code> 分桶计数器。</p>
<p>分桶计数的原理是定义一个时间间隔，将一段时间按照时间间隔分割为几个桶，每个桶保存当前时间间隔的计数。</p>
<p>比如时间间隔为 5s ，桶的总数为 10 个，那么 0~5s 为一个桶，5~10s 为下一个，以此类推。当计数的执行的时间为 2s 时，那么将在第一桶中累加，如果为 7s 时，那么将在第二个桶累加，非常容易理解。</p>
<p>在实际场景中，因为内存限制，不宜保存过多，桶的量会有限制，采用环形队列存储同时避免数据的挪动。</p>
<p>举个常用例子，记录 Koa 服务的请求数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际使用需要从 MetricsClient 拿到 BucketCounter</span></span><br><span class="line"><span class="keyword">let</span> counter = <span class="keyword">new</span> BucketCounter();</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 累加 1 counter.inc(1);</span></span><br><span class="line">  counter.inc();</span><br><span class="line">  <span class="keyword">await</span> next()</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="分布度量"><a href="#分布度量" class="headerlink" title="分布度量"></a>分布度量</h3><p>第三个介绍的是 Histogram，直方分布指标，Pandora.js 包含一个基础实现类 <code>BaseHistogram</code>， 通过它可以用于统计某个接口的响应时间，可以展示 50%, 70%, 90% 的请求响应时间落在哪个区间内，通过这些你可以计算出 <a href="https://en.wikipedia.org/wiki/Apdex" target="_blank" rel="noopener">Apdex</a>。</p>
<blockquote>
<p>这边的分布暂时只考虑单机分布，在集群维度上不能这样计算。</p>
</blockquote>
<p>对于分布计算，核心就是维护一个数据集 <a href="http://www.midwayjs.org/pandora/api-reference/metrics/enums/reservoirtype.html" target="_blank" rel="noopener">Reservoir</a> ，数据集用来提供数据存储以及获取当前快照的能力。这其中最重要的就是数据更新的策略，目前 Pandora.js 只实现了随机采样（UniformReservoir）和 指数衰减随机采样（ExponentiallyDecayingReservoir）的实现，由于随机采样并不能很好的表现权重问题，默认的是指数衰减随机采样，其他的采样算法没有实现，有兴趣的同学可以补充。</p>
<p>举个常用例子，记录 Koa 服务的成功比率，采用随机采样算法，间隔 1s，2个分桶，展示获取了平均数等信息。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际使用需要从 MetricsClient 拿到 BaseHistogram</span></span><br><span class="line"><span class="keyword">let</span> histogram = <span class="keyword">new</span> BaseHistogram(ReservoirType.UNIFORM, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span> (ctx, next) =&gt; &#123;</span><br><span class="line">  histogram.update(<span class="number">10</span>);</span><br><span class="line">  histogram.update(<span class="number">20</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// other biz</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// let snapshot = histogram.getSnapshot();</span></span><br><span class="line"><span class="comment">// expect(snapshot.getMean()).to.equal(15);</span></span><br><span class="line"><span class="comment">// expect(snapshot.getMax()).to.equal(20);</span></span><br><span class="line"><span class="comment">// expect(snapshot.getMin()).to.equal(10);</span></span><br><span class="line"><span class="comment">// expect(snapshot.getMedian()).to.equal(15);</span></span><br></pre></td></tr></table></figure>
<h3 id="变化速率度量"><a href="#变化速率度量" class="headerlink" title="变化速率度量"></a>变化速率度量</h3><p>第四个介绍的是 Meter，是一种用于度量一段时间内吞吐率的计量器。例如，一分钟内，五分钟内，十五分钟内的qps指标。</p>
<p>这里要指出，变化的速率，我们一般情况下会关心两个地方，一个是瞬时爆发，超出平常正常值非常高的这样的波动变化，另一个是一段时间内的趋势，从平均的角度来看整体度量的一种方式，这种方式会将高低点进行平均来看。</p>
<p>前一种在  Metrics 中使用  Rate 的概念，只记录事件的累计总次数，有外部系统来通过前后两次采集，来计算瞬时速率，这里我们称之为<code>Rate</code>。</p>
<p>在 rate 的计算中，我们认为数据的增长是<code>线性</code>的。其计算方式为：rate = (v2 - v1) / (t2 - t1)，其中时间的单位是 s。</p>
<p>这样的好处是，通过调整采集频率，可以支持任意时间间隔的瞬时速率计算。但缺点是，当两次采样之间系统重启的时候，会计算出负数，同时会有一部分数据丢失。</p>
<p>后一种通过指数移动加权平均(Exponential Weighted Moving Average, EWMA）来计算。</p>
<p>针对速率型度量指标，我们提供了 1 分钟(m1)，5 分钟(m5)，15分钟的EWMA(m15)，分别用于反映距离当前时间点 1 分钟，5 分钟，15 分钟的速率变化。</p>
<p>其具体的计算方法，和 Linux 系统中 load1, load5, load15 的计算方法完全一致。即，每 5 秒钟统计一次瞬时速率，并应用于如下的递推公式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EWMA(t) = EWMA(t-1) + alpha * (instantRate - EWMA(t-1))</span><br></pre></td></tr></table></figure>
<p>其中 alpha 取值范围为 0~1, 称为衰减系数，该系数越大，则距离当前的时间点越老的数据权重衰减的越快。</p>
<p>举个常用例子，记录 Koa 某个路由的调用比率。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际使用需要从 MetricsClient 拿到 BaseMeter</span></span><br><span class="line"><span class="keyword">let</span> meter = <span class="keyword">new</span> BaseMeter();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/home'</span>, <span class="keyword">async</span> (ctx) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 接口调用埋点</span></span><br><span class="line">  meter.mark(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// meter.getMeanRate(); 总数除以时间</span></span><br><span class="line"><span class="comment">// meter.getOneMinuteRate(); // 一分钟的 EWMA</span></span><br></pre></td></tr></table></figure>
<h2 id="本文最后"><a href="#本文最后" class="headerlink" title="本文最后"></a>本文最后</h2><p>以上只是 Pandora.js 的度量体系的一部分，结合了阿里自己的  Metrics 体系，只能管中窥豹，简单的介绍一下几种最基本的度量指标类型，通过这本的度量器，我们可以将数据从业务代码中产生出来。</p>
<p>不过这仅仅是数据生成，除此之外，数据采集和加工也非常的重要，下一篇我们将会讲到，Pandora.js 的数据采集和加工部分。</p>
<blockquote>
<p>Pandora.js 项目地址：<a href="https://github.com/midwayjs/pandora" target="_blank" rel="noopener">https://github.com/midwayjs/pandora</a> 欢迎社会各界前来 Star ~</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1UpNqlBfH8KJjy1XbXXbLdXXa-900-500.jpg" alt="跨越时代的度量衡 - Pandora.js 的 Metrics 介绍"></p>
<p>自秦始皇统一六国，天下]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="Pandora.js" scheme="http://taobaofed.org/tags/Pandora-js/"/>
    
      <category term="Metrics" scheme="http://taobaofed.org/tags/Metrics/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让进程间通信更容易 - Pandora.js 的 IPC-Hub]]></title>
    <link href="http://taobaofed.org/blog/2017/12/21/pandora-ipc/"/>
    <id>http://taobaofed.org/blog/2017/12/21/pandora-ipc/</id>
    <published>2017-12-21T03:35:12.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1GSQ3jf6H8KJjy0FjXXaXepXa-900-500.jpg" alt="让进程间通信更容易 - Pandora.js 的 IPC-Hub"></p>
<p>我们前面的两篇介绍了怎么定义多个进程，怎么利用进程这一资源。我们在淘宝业务中也是这样实践的，有一个问题也越发明显，进程间如何通信呢？</p>
<p>起初我们有一个比较简单的 IPC 实现，通过 Domain Socket 进行通信。也是传统的 C/S 架构的，两个进程间进行比较基础的消息通信（比较类似 <a href="https://www.npmjs.com/package/node-ipc" target="_blank" rel="noopener">Node-IPC</a> 这个包）。</p>
<p>不过实在是太基础了，时不时地在想：</p>
<blockquote>
<p>在同一台计算机上的同一个语言，为什么要搞得这么痛苦？是 Node.js 太弱了吗？<br>我要有线程的话，需要活的这么累吗？</p>
</blockquote>
<p>之前的大致样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在进程 A</span></span><br><span class="line"><span class="keyword">const</span> ipcServer = createServer(<span class="string">'/path/of/domain/socket/file'</span>);</span><br><span class="line">ipcServer.on(<span class="string">'request_resource'</span>, (client) =&gt; &#123;</span><br><span class="line">  client.send(<span class="string">'dispatch_resource'</span>, &#123; ...resource &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在进程 B</span></span><br><span class="line"><span class="keyword">const</span> ipcClient = createClient(<span class="string">'/path/of/domain/socket/file'</span>);</span><br><span class="line">ipcClient.on(<span class="string">'dispatch_resource'</span>, (resource) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Got resource'</span>, resource);</span><br><span class="line">&#125;);</span><br><span class="line">ipcClient.send(<span class="string">'request_resource'</span>);</span><br></pre></td></tr></table></figure>
<p>都是一些简单消息传递，只有 <code>send()</code>、<code>boardcast()</code> 这样简单的元语。想做点什么，难度可想而知。</p>
<p>我们在 Pandora.js 中系统化地解决了这个痛点，就是接下来要介绍的 IPC-Hub。</p>
<h2 id="进程间通信-IPC-Hub"><a href="#进程间通信-IPC-Hub" class="headerlink" title="进程间通信 IPC-Hub"></a>进程间通信 IPC-Hub</h2><p>经过一些思考和讨论，最简洁的莫过是：</p>
<blockquote>
<p>我发布一个对象，这台计算机上的哪个 Node.js 进程都能调用。<br>这个对象上的方法我也不用额外地修饰，发布出去其他进程就能调用，就像调用一个普通对象上的方法一样。</p>
</blockquote>
<p>你只需要用 Pandora.js 启动应用，下面这些能力都是标配的。</p>
<h3 id="简洁的进程间对象代理"><a href="#简洁的进程间对象代理" class="headerlink" title="简洁的进程间对象代理"></a>简洁的进程间对象代理</h3><p>经过努力，我们提出了『简洁的进程间对象代理』，看下面的例子会清楚得多：</p>
<p>在 PID 为 1 的进程中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;publishObject&#125; = <span class="built_in">require</span>(<span class="string">'pandora'</span>);</span><br><span class="line"><span class="keyword">const</span> processInfo = &#123;</span><br><span class="line">  <span class="keyword">async</span> getPid() &#123;</span><br><span class="line">    <span class="keyword">return</span> process.pid; <span class="comment">// 假定 PID 是 1</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 发布 processInfo 在 IPCHub 中，并命名为 processInfo</span></span><br><span class="line"><span class="keyword">await</span> publishObject(<span class="string">'processInfo'</span>, processInfo);</span><br></pre></td></tr></table></figure>
<p>在 PID 为 2 的进程中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;getProxy&#125; = <span class="built_in">require</span>(<span class="string">'pandora'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得 processInfo 的代理对象</span></span><br><span class="line"><span class="keyword">const</span> processInfo = <span class="keyword">await</span> getProxy(<span class="string">'processInfo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 getPid() 方法，当然这里需要增加 await，</span></span><br><span class="line"><span class="comment">// 每个代理过来的方法都会变成 async 形式。</span></span><br><span class="line"><span class="comment">// 不过好在 await 一个非 async 的方法也不会出错，</span></span><br><span class="line"><span class="comment">// 所以一般业务逻辑都可以良好的兼容原始对象和代理对象。</span></span><br><span class="line"><span class="keyword">const</span> pid = <span class="keyword">await</span> processInfo.getPid();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会打印 PID 为 1 的进程的 PID： 1</span></span><br><span class="line"><span class="built_in">console</span>.log(pid);</span><br></pre></td></tr></table></figure>
<p>强大到，就连 Node.js 内置的对象都可以！</p>
<blockquote>
<p>—— 作者语：虽然没什么实际用处。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程 A</span></span><br><span class="line"><span class="keyword">const</span> &#123;publishObject&#125; = <span class="built_in">require</span>(<span class="string">'pandora'</span>);</span><br><span class="line">publishObject(<span class="string">'math'</span>, <span class="built_in">Math</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 进程 B</span></span><br><span class="line"><span class="keyword">const</span> &#123;getProxy&#125; = <span class="built_in">require</span>(<span class="string">'pandora'</span>);</span><br><span class="line"><span class="keyword">const</span> mathProxy = getProxy(<span class="string">'math'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将会打印 4</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">await</span> mathProxy.pow(<span class="number">2</span>, <span class="number">2</span>));</span><br></pre></td></tr></table></figure>
<h3 id="Service-发布到-IPC-Hub"><a href="#Service-发布到-IPC-Hub" class="headerlink" title="Service 发布到 IPC-Hub"></a>Service 发布到 IPC-Hub</h3><p>上一篇介绍到了 Service，正是可以利用的绝佳材料，可以很方便的发布到 IPC-Hub 中：</p>
<p><code>procfile.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">pandora</span>) </span>&#123;</span><br><span class="line">  pandora</span><br><span class="line">    .service(<span class="string">'serviceName'</span>, <span class="string">'./serviceImpl.js'</span>)</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 直接把这个 Service 发布到 IPC-Hub 中去</span></span><br><span class="line">	<span class="comment">// ，当然名字就叫 serviceName 啦~</span></span><br><span class="line">    .publish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="一个向任务进程投递网页截图任务的例子"><a href="#一个向任务进程投递网页截图任务的例子" class="headerlink" title="一个向任务进程投递网页截图任务的例子"></a>一个向任务进程投递网页截图任务的例子</h2><p>为什么我们要把一些任务隔离进程？因为有些任务计算量大（比如大规模的定时任务）、或者不稳定因素太多（比如集成了不可靠的库），希望隔离于提供基础 Web 服务的进程组。</p>
<p>我们下面的例子中将介绍：</p>
<blockquote>
<p>Web 服务收到用户的请求后，直接将任务通过 IPC-Hub 传递给任务进程，任务进程完成后再返回用户。</p>
</blockquote>
<p>我们其中用到了 <a href="https://github.com/GoogleChrome/puppeteer" target="_blank" rel="noopener">GoogleChrome/puppeteer</a>，一个 Chrome Headless 的 Node.js Lib。</p>
<h3 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h3><p>下面讲到的例子在：<a href="https://github.com/midwayjs/pandora-example/tree/master/pageSnapshot" target="_blank" rel="noopener">https://github.com/midwayjs/pandora-example/tree/master/pageSnapshot</a> 。</p>
<p><strong>我们先将 procfile.js 写好：</strong></p>
<p>下面最重要的是 <code>service(&#39;pageSnapshot&#39;, &#39;./services/PageSnapshot&#39;).publish()</code>，表示将 pageSnapshot 这个 Service 发布到 IPC-Hub 中去，任何进程都可以调用了~</p>
<p><code>procfile.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">pandora</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/** </span></span><br><span class="line"><span class="comment">    重要前提:</span></span><br><span class="line"><span class="comment">    Pandora.js 中已经默认包含 worker 和 background 的进程定义</span></span><br><span class="line"><span class="comment">    ，只要往里面注册 Service 就能激活。</span></span><br><span class="line"><span class="comment">      pandora.process('worker').scale(pandora.dev ? 1: 'auto');</span></span><br><span class="line"><span class="comment">      pandora.process('background').scale(1);</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调整后台任务进程（background）的内存限制</span></span><br><span class="line">  pandora</span><br><span class="line">    .process(<span class="string">'background'</span>)</span><br><span class="line">    .argv([<span class="string">'--max-old-space-size=512'</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将截图服务放到 background 进程</span></span><br><span class="line">  pandora</span><br><span class="line">    .service(<span class="string">'pageSnapshot'</span>, <span class="string">'./services/PageSnapshot'</span>)</span><br><span class="line">    .process(<span class="string">'background'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** 重要：表示发布到 IPC-Hub 中</span></span><br><span class="line">    .publish();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将 Web 服务放到 worker 进程</span></span><br><span class="line">  pandora</span><br><span class="line">    .service(<span class="string">'web'</span>, <span class="string">'./services/Web'</span>)</span><br><span class="line">    .process(<span class="string">'worker'</span>)</span><br><span class="line">    .config(&#123;</span><br><span class="line">      <span class="comment">// 配置监听端口号</span></span><br><span class="line">      port: <span class="number">5511</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>然后实现截图的 PageSnapshot <code>./services/PageSnapshot</code></strong></p>
<p><code>services/PageSnapshot.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">'puppeteer'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">PageSnapshot</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param ctx - 构造时会传递一个上下文对象，这个具体可以参考：</span></span><br><span class="line"><span class="comment">   * http://www.midwayjs.org/pandora/api-reference/pandora/classes/servicecontextaccessor.html</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>(ctx) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准的日志对象</span></span><br><span class="line">    <span class="keyword">this</span>.logger = ctx.logger;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 标准的启动接口：</span></span><br><span class="line"><span class="comment">   * http://www.midwayjs.org/pandora/api-reference/pandora/interfaces/service.html#start</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> start() &#123;</span><br><span class="line">    <span class="comment">// 启动一个 Headless Chrome</span></span><br><span class="line">    <span class="keyword">this</span>.browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动完毕</span></span><br><span class="line">    <span class="keyword">this</span>.logger.info(<span class="string">'Service PageSnapshot Started'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 标准的停止接口：</span></span><br><span class="line"><span class="comment">   * http://www.midwayjs.org/pandora/api-reference/pandora/interfaces/service.html#stop</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> stop() &#123;</span><br><span class="line">    <span class="comment">// 关闭 Headless Chrome</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.browser.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动完毕</span></span><br><span class="line">    <span class="keyword">this</span>.logger.info(<span class="string">'Service PageSnapshot Stopped'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> take(url) &#123;</span><br><span class="line">    <span class="comment">// 新建一个页面</span></span><br><span class="line">    <span class="keyword">const</span> page = <span class="keyword">await</span> <span class="keyword">this</span>.browser.newPage();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 跳转到目标地址</span></span><br><span class="line">    <span class="keyword">await</span> page.goto(url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 截图</span></span><br><span class="line">    <span class="keyword">const</span> buf = <span class="keyword">await</span> page.screenshot(&#123;<span class="attr">type</span>: <span class="string">'jpeg'</span>, <span class="attr">quality</span>: <span class="number">60</span>&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭页面</span></span><br><span class="line">    <span class="keyword">await</span> page.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 现在 IPC Hub 不能直接传递 Buffer，需要 base64。</span></span><br><span class="line">      base64: buf.toString(<span class="string">'base64'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>然后实现前台 Web 服务 <code>./services/Web</code></strong></p>
<p>下面的服务继承了一个基础类 <a href="https://github.com/midwayjs/pandora-example/blob/master/pageSnapshot/services/SimpleHTTP.js" target="_blank" rel="noopener">SimpleHTTP</a>，这里就不再引出了，基本上就是封装了一个 HTTP Server 上线下线逻辑。</p>
<p>下面的重点是获得 <code>pageSnapshot</code> 对象代理那里。</p>
<p><code>services/Web.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> querystring = <span class="built_in">require</span>(<span class="string">'querystring'</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">'url'</span>);</span><br><span class="line"><span class="keyword">const</span> SimpleHTTP = <span class="built_in">require</span>(<span class="string">'./SimpleHTTP'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Web</span> <span class="keyword">extends</span> <span class="title">SimpleHTTP</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param ctx - 构造时会传递一个上下文对象，这个具体可以参考：</span></span><br><span class="line"><span class="comment">   * http://www.midwayjs.org/pandora/api-reference/pandora/classes/servicecontextaccessor.html</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>(ctx) &#123;</span><br><span class="line">    <span class="keyword">super</span>(ctx);</span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现父类要求的接口，处理 HTTP 请求</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> onRequest(req, res) &#123;</span><br><span class="line">    <span class="comment">// 标准的日志对象，父类中通过 this.logger = ctx.logger 获得</span></span><br><span class="line">    <span class="keyword">this</span>.logger.info(<span class="string">'Got a request url: '</span> + req.url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 query 中获得 method 和 params</span></span><br><span class="line">    <span class="keyword">const</span> query = querystring.parse(url.parse(req.url).query);</span><br><span class="line">    <span class="keyword">const</span> targetUrl = query.url;</span><br><span class="line">    <span class="keyword">if</span>(!targetUrl) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Query [url] is required'</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// *** 重点：获得 pageSnapshot 对象代理</span></span><br><span class="line">    <span class="comment">// getProxy，在 serviceContext 中同样有暴露</span></span><br><span class="line">    <span class="keyword">const</span> pageSnapshot = <span class="keyword">await</span> <span class="keyword">this</span>.ctx.getProxy(<span class="string">'pageSnapshot'</span>, &#123;</span><br><span class="line">      <span class="comment">// 默认 5 秒超时，截取网页，还是需要加大点超时时间</span></span><br><span class="line">      timeout: <span class="number">10</span> * <span class="number">1000</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用截图。</span></span><br><span class="line">    <span class="comment">// 现在 IPC Hub 不能直接传递 Buffer，需要 base64。</span></span><br><span class="line">    <span class="keyword">const</span> snapshot = <span class="keyword">await</span> pageSnapshot.take(targetUrl);</span><br><span class="line">    <span class="keyword">const</span> jpg = <span class="keyword">new</span> Buffer(snapshot.base64, <span class="string">'base64'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回给客户端</span></span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'image/jpeg'</span>&#125;);</span><br><span class="line">    res.end(jpg);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实现父类要求的接口，提供 TCP 端口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getPort() &#123;</span><br><span class="line">    <span class="comment">// 通过配置获取</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.ctx.config.port;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="启动一个试试看"><a href="#启动一个试试看" class="headerlink" title="启动一个试试看"></a>启动一个试试看</h3><p>可以直接 Clone 例子试试看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ pandora dev <span class="comment"># 本地前台启动项目</span></span><br><span class="line">2017-12-20 21:49:51,318 INFO 94498 [serviceName: web, processName: worker] Service Web Listens On http://127.0.0.1:5511</span><br><span class="line">2017-12-20 21:49:51,320 INFO 94496 Process [name = worker, pid = 94498] Started successfully!</span><br><span class="line">2017-12-20 21:49:51,877 INFO 94499 [serviceName: pageSnapshot, processName: background] Service PageSnapshot Started</span><br><span class="line">2017-12-20 21:49:51,879 INFO 94496 Process [name = background, pid = 94499] Started successfully!</span><br><span class="line">** Application start successful. **</span><br></pre></td></tr></table></figure>
<p>可以看到 background 和 worker 进程都已经启动了。</p>
<p><strong>浏览器访问看看</strong></p>
<p>访问 <code>http://127.0.0.1:5511/?url=https://www.taobao.com/</code> 看看。</p>
<p><img src="https://gw.alicdn.com/tfs/TB1RGMEjcrI8KJjy0FhXXbfnpXa-1978-1690.png" alt="taobao | center"></p>
<p>嗯，已经可以用了。</p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>这样 Pandora.js 的进程间通信能力就介绍完了，和进程模型相关的能力基本介绍完毕了。</p>
<p>下周开始介绍业务度量能力啦~ 比如 Metrics、全链路 Trace 等，大家敬请期待。</p>
<p>最后，不要忘了给点个 Star 喔~</p>
<p><a href="https://github.com/midwayjs/pandora/" target="_blank" rel="noopener">https://github.com/midwayjs/pandora/</a></p>
<p>最后的最后，我们招人。我们有超过一半的淘宝前台访问在 Node.js 上，也有做开源 Node.js 软件的机会，挑战不小，当然回报也不小。</p>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/kRLXoi3Dtqs" target="_blank" rel="noopener">https://unsplash.com/photos/kRLXoi3Dtqs</a> By @Ian Simmonds</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB1GSQ3jf6H8KJjy0FjXXaXepXa-900-500.jpg" alt="让进程间通信更容易 - Pandora.js 的 IPC-Hub"></p>
<p>我们前面的两篇介绍了怎么定]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="Pandora.js" scheme="http://taobaofed.org/tags/Pandora-js/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Pandora.js 的 Service 机制]]></title>
    <link href="http://taobaofed.org/blog/2017/12/19/pandora-service/"/>
    <id>http://taobaofed.org/blog/2017/12/19/pandora-service/</id>
    <published>2017-12-19T08:19:29.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB17ocZiY_I8KJjy1XaXXbsxpXa-900-500.jpg" alt="Pandora.js 的 Service 机制"></p>
<blockquote>
<p>这篇依然是介绍 Pandora.js 的系列文章之一<br>项目地址：<a href="https://github.com/midwayjs/pandora" target="_blank" rel="noopener">https://github.com/midwayjs/pandora</a> 欢迎社会各界前来 Star ~</p>
</blockquote>
<p>本章主要介绍我们的 Service 机制，是 Pandora.js 对于进程编排的一种高级机制。</p>
<blockquote>
<p>Q：为什么要有这种机制？<br>A：因为进程是昂贵的，我们需要有一种机制可以管理进程内的启停。</p>
</blockquote>
<h2 id="Service-解决什么问题？"><a href="#Service-解决什么问题？" class="headerlink" title="Service 解决什么问题？"></a>Service 解决什么问题？</h2><p><strong>我们希望，Service 能做一些应用流程之外的事情，比如：</strong></p>
<ol>
<li>基础的中间件管理（比如 etcd）</li>
<li>需要标准上下线流程的服务，比如 RPC Provider</li>
<li>需要和应用隔离的一些服务，启动停止时同步文件等等</li>
</ol>
<p>通过一定的规范体系，把常用的，需要内聚的程序逻辑放到一起，我们就把这些逻辑称为 “Service”。</p>
<p>如果程序本身的逻辑之外，我们还需要考虑和 Pandora.js 整体，进程编排逻辑，应用的启动生命周期相关联，我们还考虑了其他方面的东西。</p>
<p>当然有一些基本原则：</p>
<ul>
<li>接口简单易用，便于实现</li>
<li>把启动流程尽量统一化</li>
</ul>
<p>除了上面两条之外，还有一些其他的原则，简述如下：</p>
<ol>
<li><strong>异步启动：</strong> 无法让进程异步的启动，如果应用启动需要几秒，没办法知道什么时候才算启动好了。<ul>
<li>我们之前的做法是定时轮询 HTTP 接口是否暴露，相当地 Tricky。</li>
</ul>
</li>
<li><strong>异步停止：</strong> 关闭全靠 kill (也许还要 -9)，RPC 、Web 服务也不好做平滑下线。<ul>
<li>我们经常因为这个问题，在发布新版时收到一些接口调用超时的错误报警。</li>
</ul>
</li>
<li><strong>进程是昂贵的：</strong> 一个进程一个入口文件不能结构复用宝贵的进程。<ul>
<li>当然直接在入口文件里直接 require，或者像 egg 的 plugin 机制都能解决这个问题。不过依然不够通用，分层也不够清晰。</li>
</ul>
</li>
</ol>
<p><strong>最终确定了，Service 主要提供了如下的能力：</strong></p>
<ol>
<li>标准的 <code>async start()</code> 接口</li>
<li>标准的 <code>async stop()</code> 接口</li>
<li>结构化的日志管理、配置能力</li>
<li>进程内的启动顺序（依赖关系）管理</li>
</ol>
<h2 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h2><p>Service 主要分为两个部分：</p>
<ol>
<li><code>procfile.js</code> 中的链式定义语法</li>
<li>实现 Service 的接口约束</li>
</ol>
<h3 id="接下来通过一个自发现的-RPC-Provider-来介绍"><a href="#接下来通过一个自发现的-RPC-Provider-来介绍" class="headerlink" title="接下来通过一个自发现的 RPC Provider 来介绍"></a>接下来通过一个自发现的 RPC Provider 来介绍</h3><p>下面的例子在：<a href="https://github.com/midwayjs/pandora-example/tree/master/rpc" target="_blank" rel="noopener">https://github.com/midwayjs/pandora-example/tree/master/rpc</a></p>
<p><strong>我们先编写一个 <code>procfile.js</code>：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">pandora</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Part 1 : 基础 Service</span></span><br><span class="line"><span class="comment">   * Etcd 是所有进程都要有的基础 Service</span></span><br><span class="line"><span class="comment">   * 使用 weak-all 分配到全部启动了的进程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  pandora</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义 Service 的名字叫 etcd</span></span><br><span class="line">    .service(<span class="string">'etcd'</span>, <span class="string">'./services/Etcd'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// weak-all 表示这个 service 不激活任何进程</span></span><br><span class="line">    <span class="comment">// 但是会分配到激活了的进程中去，比如下面被 tryRpc 激活的了的 rpc 进程</span></span><br><span class="line">    .process(<span class="string">'weak-all'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置 etcd 的地址</span></span><br><span class="line">    .config(&#123;</span><br><span class="line">      host: <span class="string">'http://localhost:2379'</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Part 2 : RPC 进程</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  pandora</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 定义一个进程专门发布 RPC</span></span><br><span class="line">    .process(<span class="string">'rpc'</span>)</span><br><span class="line">    .scale(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 向 rpc 进程注入一个 叫 tryRpc 的 RPC Provider</span></span><br><span class="line">  pandora</span><br><span class="line">    .service(<span class="string">'tryRpc'</span>, <span class="string">'./services/TryRpc'</span>)</span><br><span class="line">    .process(<span class="string">'rpc'</span>)</span><br><span class="line">    .config(&#123;</span><br><span class="line">      port: <span class="number">5222</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>我们先把最基础的中间件 etcd <code>services/Etcd.js</code> 实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> NodeEtcd = <span class="built_in">require</span>(<span class="string">'node-etcd'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 简单继承 NodeEtcd 即可</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="class"><span class="keyword">class</span> <span class="title">Etcd</span> <span class="keyword">extends</span> <span class="title">NodeEtcd</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(ctx) &#123;</span><br><span class="line">    <span class="comment">// 从 ctx 中获得配置，传给父类构造</span></span><br><span class="line">    <span class="keyword">super</span>(ctx.config.host);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>然后我们再来编写 RPC Provider 的实现 <code>services/TryRpc.js</code> ：</strong></p>
<p><em>主要关注里面的 <code>async start()</code> 和 <code>async stop()</code></em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;promisify&#125; = <span class="built_in">require</span>(<span class="string">'util'</span>);</span><br><span class="line"><span class="keyword">const</span> jayson = <span class="built_in">require</span>(<span class="string">'jayson/promise'</span>);</span><br><span class="line"><span class="keyword">const</span> uuid = <span class="built_in">require</span>(<span class="string">'uuid'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 实现一个服务自发现的 Provider</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TryRpc</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * @param ctx 构造时会传递一个上下文对象，这个具体可以参考：</span></span><br><span class="line"><span class="comment">   *   http://www.midwayjs.org/pandora/api-reference/pandora/classes/servicecontextaccessor.html</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">constructor</span>(ctx) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成个 UUID 作这个 Provider 的标识好了</span></span><br><span class="line">    <span class="keyword">this</span>.uuid = uuid.v4();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 标准的 Logger 对象</span></span><br><span class="line">    <span class="comment">//   http://www.midwayjs.org/pandora/api-reference/pandora/classes/servicecontextaccessor.html#logger</span></span><br><span class="line">    <span class="keyword">this</span>.logger = ctx.logger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从 config 里拿 RPC 监听的地址</span></span><br><span class="line">    <span class="keyword">this</span>.port = ctx.config.port;</span><br><span class="line">    <span class="keyword">this</span>.host = ctx.config.host || <span class="string">'127.0.0.1'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从依赖里获得 etcd</span></span><br><span class="line">    <span class="comment">//   http://www.midwayjs.org/pandora/api-reference/pandora/classes/servicecontextaccessor.html#getdependency</span></span><br><span class="line">    <span class="keyword">this</span>.etcd = ctx.getDependency(<span class="string">'etcd'</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到自己在 etcd 上的 key</span></span><br><span class="line">    <span class="keyword">this</span>.etcdKey = <span class="string">'/JSONRPC/'</span> + <span class="keyword">this</span>.uuid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到自己在 etcd 上的 Value</span></span><br><span class="line">    <span class="keyword">this</span>.etcdValue = <span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">      uuid: <span class="keyword">this</span>.uuid,</span><br><span class="line">      hostname: <span class="keyword">this</span>.host,</span><br><span class="line">      port: <span class="keyword">this</span>.port</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过 jayson 创建一个 RPC 服务</span></span><br><span class="line">    <span class="keyword">this</span>.server = jayson.server(<span class="keyword">this</span>.getRpcMethods());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们通过 jayson 的 http 界面暴露服务</span></span><br><span class="line">    <span class="keyword">this</span>.http = <span class="keyword">this</span>.server.http();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获得 RPC 中暴露的方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  getRpcMethods() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="keyword">async</span> add(args) &#123;</span><br><span class="line">        <span class="keyword">return</span> args[<span class="number">0</span>] + args[<span class="number">1</span>];</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="keyword">async</span> mul(args) &#123;</span><br><span class="line">        <span class="keyword">return</span> args[<span class="number">0</span>] * args[<span class="number">1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 标准的启动接口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> start() &#123;</span><br><span class="line">    <span class="comment">// 将我们的 RPC 的 HTTP 界面进行监听</span></span><br><span class="line">    <span class="keyword">await</span> promisify(<span class="keyword">this</span>.http.listen).call(<span class="keyword">this</span>.http, <span class="keyword">this</span>.port, <span class="keyword">this</span>.host);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 etcd 中暴露，并且定时心跳</span></span><br><span class="line">    <span class="keyword">await</span> <span class="keyword">this</span>.startHeartbeat();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动完成</span></span><br><span class="line">    <span class="keyword">this</span>.logger.info(<span class="string">'Service JSON RPC Listens On http://'</span> + <span class="keyword">this</span>.host + <span class="string">':'</span> + <span class="keyword">this</span>.port);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 标准的停止接口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> stop() &#123;</span><br><span class="line">    <span class="comment">// 清除心跳定时器</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.timer) &#123;</span><br><span class="line">      clearInterval(<span class="keyword">this</span>.timer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把自己从 etcd 上删除，等于下线</span></span><br><span class="line">    <span class="keyword">await</span> promisify(<span class="keyword">this</span>.etcd.del).call(<span class="keyword">this</span>.etcd, <span class="keyword">this</span>.etcdKey);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 等待所有的 RPC 调用都结束，否则会出现客户端调用超时</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已经从 etcd 上下线，并且所有存量 RPC 调用也已经完成</span></span><br><span class="line">    <span class="comment">// 关闭 HTTP 监听</span></span><br><span class="line">    <span class="keyword">await</span> promisify(<span class="keyword">this</span>.http.close).call(<span class="keyword">this</span>.http);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下线完成</span></span><br><span class="line">    <span class="keyword">this</span>.logger.info(<span class="string">'Service JSON RPC Stopped'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 开始向 etcd 注册，并开始心跳</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> startHeartbeat() &#123;</span><br><span class="line">    <span class="keyword">const</span> interval = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="keyword">this</span>.etcdValue;</span><br><span class="line">    <span class="keyword">const</span> once = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> promisify(<span class="keyword">this</span>.etcd.set).call(<span class="keyword">this</span>.etcd, <span class="keyword">this</span>.etcdKey, value, &#123;<span class="attr">ttl</span>: interval * <span class="number">2</span>&#125;)</span><br><span class="line">        .catch(<span class="keyword">this</span>.logger.error.bind(<span class="keyword">this</span>.logger));</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">await</span> once();</span><br><span class="line">    <span class="keyword">this</span>.timer = setInterval(once, interval * <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记依赖，在 TC39 Stage 2 中可以使用 static dependencies 代替</span></span><br><span class="line">TryRpc.dependencies = [<span class="string">'etcd'</span>];</span><br><span class="line"><span class="built_in">module</span>.exports = TryRpc;</span><br></pre></td></tr></table></figure>
<p><strong>本地启动一个试试看</strong></p>
<p>首先我们启动本地的 etcd （当然你得先安装 etcd， Mac 的话直接 <code>brew install etcd</code>）</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ etcd <span class="comment"># 启动 etcd</span></span><br><span class="line">2017-12-19 14:09:20.292891 I | etcdmain: etcd Version: 3.2.11</span><br><span class="line">2017-12-19 14:09:20.293013 I | etcdmain: Git SHA: GitNotFound</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>将这三个文件放到同一目录下（目录叫 tryPandora），然后运行 <code>pandora dev</code>，我们就可以前台启动这个应用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ pandora dev <span class="comment"># 本地前台启动</span></span><br><span class="line">2017-12-19 14:25:16,619 INFO 42977 [serviceName: tryRpc, processName: rpc] Service JSON RPC Listens On http://127.0.0.1:5222</span><br><span class="line">2017-12-19 14:25:16,621 INFO 42975 Process [name = rpc, pid = 42977] Started successfully!</span><br><span class="line">Application start successful.</span><br></pre></td></tr></table></figure>
<p>我们看到 <code>Service JSON RPC Listens On http://127.0.0.1:5222</code>，RPC Provider 已经成功监听。而 <strong><code>Application start successful.</code></strong> 的提示永远在其之后。</p>
<p><strong>然后我们查看 etcd 中的注册情况</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:2379/v2/keys/JSONRPC</span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"get"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/JSONRPC"</span>,<span class="string">"dir"</span>:<span class="literal">true</span>,<span class="string">"nodes"</span>:[&#123;<span class="string">"key"</span>:<span class="string">"/JSONRPC/5a32f5ab-f423-4b3c-b661-4a12e8ece5b2"</span>,<span class="string">"value"</span>:<span class="string">"&#123;\"uuid\":\"5a32f5ab-f423-4b3c-b661-4a12e8ece5b2\",\"hostname\":\"127.0.0.1\",\"port\":5222&#125;"</span>,<span class="string">"expiration"</span>:<span class="string">"2017-12-19T06:29:46.648936363Z"</span>,<span class="string">"ttl"</span>:59,<span class="string">"modifiedIndex"</span>:11,<span class="string">"createdIndex"</span>:11&#125;],<span class="string">"modifiedIndex"</span>:4,<span class="string">"createdIndex"</span>:4&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>看上去已经发布到 etcd 中了。</p>
<p><strong>停止应用看看</strong></p>
<p>我们按 <code>Ctrl + C</code> 停止应用，我们可以看到同样有 <code>Service JSON RPC Stopped</code> 的输出，表示 RPC 已经成功取消监听了，而进程的退出的提示永远在其之后（比如 <code>Process [name = rpc, pid = 13357] Exit with code 0 and signal null</code>）。</p>
<p>这时应该：</p>
<ol>
<li>所有的存量 RPC 已经结束</li>
<li>已从 etcd 中下线</li>
</ol>
<p>然后再看看 etcd 中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ curl http://127.0.0.1:2379/v2/keys/JSONRPC</span><br><span class="line">&#123;<span class="string">"action"</span>:<span class="string">"get"</span>,<span class="string">"node"</span>:&#123;<span class="string">"key"</span>:<span class="string">"/JSONRPC"</span>,<span class="string">"dir"</span>:<span class="literal">true</span>,<span class="string">"modifiedIndex"</span>:4,<span class="string">"createdIndex"</span>:4&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>看上去也已经从 etcd 中下线。</p>
<h3 id="实现个然并卵的消费端"><a href="#实现个然并卵的消费端" class="headerlink" title="实现个然并卵的消费端"></a>实现个然并卵的消费端</h3><p>我们实现一个 HTTP Server，作为一个 RPC 的消费端，通过 etcd 发现 RPC 服务并进行调用。</p>
<blockquote>
<p>浏览器 -&gt; HTTP Server -&gt; etcd -&gt; RPC Provider</p>
</blockquote>
<p>那我们在 <code>procfile.js</code> 中加入一个 web 进程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Part 3 : 测试用的 Web 进程</span></span><br><span class="line"><span class="comment"> * 一个测试进程，本不应该存在的，为了方便例子演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 定义一个进程专门发布 Web 服务</span></span><br><span class="line">pandora</span><br><span class="line">  .process(<span class="string">'web'</span>)</span><br><span class="line">  .scale(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向 rpc 进程注入一个 叫 tryWeb 的 Web 实现 Service</span></span><br><span class="line">pandora</span><br><span class="line">  .service(<span class="string">'tryWeb'</span>, <span class="string">'./services/TryWeb'</span>)</span><br><span class="line">  .process(<span class="string">'web'</span>)</span><br><span class="line">  .config(&#123;</span><br><span class="line">    port: <span class="number">5555</span></span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>然后我们的消费端是一个 HTTP 服务 <code>services/TryWeb.js</code>：</p>
<p>太长了就不直接贴代码了，<a href="https://github.com/midwayjs/pandora-example/blob/master/rpc/services/TryWeb.js" target="_blank" rel="noopener">https://github.com/midwayjs/pandora-example/blob/master/rpc/services/TryWeb.js</a></p>
<p>里面的核心通过是 etcd 获得客户端地址：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过 etcd 获得 RPC 客户端</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">async</span> getRpcClient() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// etcd 中获得全部可用 nodes</span></span><br><span class="line">  <span class="keyword">const</span> etcdRes = <span class="keyword">await</span> promisify(<span class="keyword">this</span>.etcd.get).call(<span class="keyword">this</span>.etcd, <span class="string">'/JSONRPC/'</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;);</span><br><span class="line">  <span class="keyword">const</span> nodes = etcdRes.node.nodes;</span><br><span class="line">  <span class="keyword">if</span>(!nodes || !nodes.length) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Cannot found provider'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 随机取一个（虽然我们例子中，怎么样都只有一个）</span></span><br><span class="line">  <span class="keyword">const</span> randomInt = getRandomInt(<span class="number">0</span>, nodes.length - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> pickedNode = nodes[randomInt];</span><br><span class="line">  <span class="keyword">const</span> node = <span class="built_in">JSON</span>.parse(pickedNode.value);</span><br><span class="line">  <span class="keyword">this</span>.logger.info(<span class="string">'total got nodes: '</span> + nodes.length);</span><br><span class="line">  <span class="keyword">this</span>.logger.info(<span class="string">'use node: '</span> + pickedNode.value);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建 client</span></span><br><span class="line">  <span class="keyword">const</span> client = jayson.client.http(&#123;</span><br><span class="line">    hostname: node.hostname,</span><br><span class="line">    port: node.port</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再用浏览器访问：</p>
<blockquote>
<p><a href="http://127.0.0.1:5555/?method=add&amp;params=%5B1,5%5D" target="_blank" rel="noopener">http://127.0.0.1:5555/?method=add&amp;params=[1,5]</a><br>{“jsonrpc”:”2.0”,”id”:”30a7767a-1173-41f3-be22-94376d9409f1”,”result”:6}</p>
</blockquote>
<p>这是一个简单的消费端例子，虽然是在一个应用里通过 etcd 服务发现了自己，感觉没什么用处。</p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>这样 Pandora.js 的 Service 模型就介绍完毕了，下一篇介绍进程间通信。进程模型介绍完之后开始介绍业务度量的能力，比如 Metrics、全链路 Trace 等，大家敬请期待。</p>
<p>最后，不要忘了给点个 Star 喔~</p>
<p><a href="https://github.com/midwayjs/pandora/" target="_blank" rel="noopener">https://github.com/midwayjs/pandora/</a></p>
<p>最后的最后，我们招人。我们有超过一半的淘宝前台访问在 Node.js 上，也有做开源 Node.js 软件的机会，挑战不小，当然回报也不小。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB17ocZiY_I8KJjy1XaXXbsxpXa-900-500.jpg" alt="Pandora.js 的 Service 机制"></p>
<blockquote>
<p>这篇依然是介绍 P]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="Pandora.js" scheme="http://taobaofed.org/tags/Pandora-js/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[管理 Node.js 进程从未如此优雅]]></title>
    <link href="http://taobaofed.org/blog/2017/12/13/pandora/"/>
    <id>http://taobaofed.org/blog/2017/12/13/pandora/</id>
    <published>2017-12-13T11:19:30.000Z</published>
    <updated>2019-03-19T09:18:13.000Z</updated>
    <content type="html"><![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB198F2ifDH8KJjy1XcXXcpdXXa-900-500.jpg" alt="管理 Node.js 进程从未如此优雅"></p>
<p>说到 Node.js 的进程模型，脑子里第一个闪现的可能是 Cluster 模块，亦或是 Master / Worker 进程模型，在长期的使用过程中，我们逐渐发现，这样在应用的开发早晚会有局限性，除了不够优雅之外，每次增减进程或者自定义进程都会产生不可预知的问题。</p>
<p>在一些特定的场景下，我们甚至在 Master 下面加入了一个 Agent 进程用来运行一些中间件 SDK 。在这些修修补补的过程中，传统的进程间通信，数据交换都变的困难，甚至 Worker 到 Agent 之间通信都无法很优雅的进行。</p>
<p>除了一些内存共享的通信场景， 也出现了 Worker 进程跑一些定时任务占用时间过长，导致 Web 接口超时等问题（或者系统容量降低）。更有甚者，把定时任务放到 Agent 中去执行，直接拖挂了基础的中间件服务，导致应用全盘崩溃。</p>
<p>就像下图：</p>
<p><img src="https://img.alicdn.com/tfs/TB1KKVkhvDH8KJjy1XcXXcpdXXa-1842-1170.png" alt="img | center"></p>
<p>虽然说影响可用性是一方面，但毕竟上面说到的情况也属于软件质量问题，通过充分的测试也可以避免，比较可怕的是进程模型和框架越绑越深。如果你想发布 RPC 服务、做一些任务处理，可能在复杂的进程模型下也没法做到了，只能让 Node.js 做一些 Web Server 的事情，在一定程度上给 Node.js 应用设置了限，不容易进化和发展。</p>
<p>这也是我们开发 Pandora.js 最直接的原因。</p>
<h2 id="procfile-js"><a href="#procfile-js" class="headerlink" title="procfile.js"></a>procfile.js</h2><p>面对这样的窘迫，从去年春节前后我们就开始准备做一些事情了，当然期间也走了一些弯路，在讨论了多次之后将大部分的场景都理顺了。</p>
<p>首先， 我们提出了一个进程结构定义文件，我们管它叫 <code>procfile.js</code>。</p>
<p>看到 <code>procfile</code> 这个词有些朋友可能熟悉，这是 Heroku （一个云服务商）进程定义文件的名字。我们也已经忘记是谁提出来要叫 <code>procfile.js</code> 的了，但是我们觉得这个名字还不错，毕竟 <code>procfile</code> 是 Process File 的一种现有简写（我们就不用自己造词了，省了一桩麻烦事）。</p>
<p>当然把进程交给 Pandora.js 管理，不只是帮你创建进程这么简单，更是：</p>
<blockquote>
<p>Pandora.js 会守护创建出来的进程。</p>
<p>小到自动重启、切割日志文件、重启次数计数。</p>
<p>大到 30 多项 Metrics 指标采集、自动的全链路 Trace 追踪、对接现有 APM （比如 Open-Falcon）等等。</p>
</blockquote>
<p>不过我们今天大致讲讲进程相关的设计思考，怎么安装、怎么启动还请到我们 GitHub 中查看文档~</p>
<p>还有其他部分比如监控、Metrics、Trace 等也要未来再讲啦~</p>
<p>BTW</p>
<blockquote>
<p>项目地址：<a href="https://github.com/midwayjs/pandora" target="_blank" rel="noopener">https://github.com/midwayjs/pandora</a> ，大家觉得好也去给点个 Star ~~</p>
</blockquote>
<h2 id="简单的-procfile-js-例子"><a href="#简单的-procfile-js-例子" class="headerlink" title="简单的 procfile.js 例子"></a>简单的 procfile.js 例子</h2><p>如果要定义一个进程，大致样例是这样的：</p>
<p><code>procfile.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// procfile.js 是一个普通的 Node.js 模块，必须导出一个 function</span></span><br><span class="line"><span class="comment">// function(pandora) 的第一个参数是 pandora，这个对象用于定义我们的进程结构</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">pandora</span>) </span>&#123;</span><br><span class="line">  pandora</span><br><span class="line">    <span class="comment">// 定义一个进程，名字叫 processA</span></span><br><span class="line">    .process(<span class="string">'processA'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 scale 大于 1 ，将使用 Node.js 的 Cluster 模块自动产生进程组</span></span><br><span class="line">    .scale(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Node.js 参数</span></span><br><span class="line">    .argv([<span class="string">'--expose-gc'</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义进程环境变量，创建出来的进程中可以通过 process.env 获得</span></span><br><span class="line">    .env(&#123;</span><br><span class="line">      ENV_VAR1: <span class="string">'VALUE_OF_ENV_VAR1'</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 启动顺序</span></span><br><span class="line">	.order(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 这个进程的入口文件地址</span></span><br><span class="line">	.entry(<span class="string">'./app.js'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    pandora</span></span><br><span class="line"><span class="comment">     .process('processB');</span></span><br><span class="line"><span class="comment">    pandora</span></span><br><span class="line"><span class="comment">     .process('processC');</span></span><br><span class="line"><span class="comment">    pandora</span></span><br><span class="line"><span class="comment">     .process('processD');</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    and so on so on....</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面简单的定义了一个入口是 <code>./app.js</code> 的进程叫 processA，这基本和 <code>node ./app.js</code> 一样。</p>
<p>针对这种场景，我们还提供了另一个更简单的方式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">pandora</span>) </span>&#123;</span><br><span class="line">  pandora.fork(<span class="string">'processA'</span>, <span class="string">'./app.js'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="进程伸缩-Scalable"><a href="#进程伸缩-Scalable" class="headerlink" title="进程伸缩 - Scalable"></a>进程伸缩 - Scalable</h2><p>大家上面看到了，procfile.js 中定义进程伸缩主要依靠下面的定义：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pandora.process(‘processX’).scale(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<p>上面这个定义的意思是，将名为 processX 的进程扩展 5 份。</p>
<p>Scale 这个值在 Pandora.js 中很重要，用户并不需要指定哪个进程，需要用 Cluster 模块进行伸缩（使用 Master / Worker 模型），哪个进程直接启动。</p>
<p>都是 Pandora.js 根据 Scale 这个值自动决定的。</p>
<p>下图可能更容易理解：</p>
<p><img src="https://img.alicdn.com/tfs/TB1zC45hr_I8KJjy1XaXXbsxpXa-1768-916.png" alt="img | center"></p>
<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><p>这篇只是介绍了进程定义的一部分能力，还有更多在未来分享喔。这只是我们开始 Pandora.js 之旅的第一部分。</p>
<p>接下来关于如何守护进程、如何监控应用、如何追踪链路、迷人的 Dashboard、如何与现有 APM 结合（比如 Open-Falcon）都会是一篇篇的干货。大家敬请期待！</p>
<p>最后，不要忘了给点个 Star 喔~</p>
<p><a href="https://github.com/midwayjs/pandora" target="_blank" rel="noopener">https://github.com/midwayjs/pandora</a></p>
<p>最后的最后，我们招人。我们有超过一半的淘宝前台访问在 Node.js 上，也有做开源 Node.js 软件的机会，挑战不小，当然回报也不小。</p>
<blockquote>
<p>题图：<a href="https://unsplash.com/photos/F9o7u-CnDJk" target="_blank" rel="noopener">https://unsplash.com/photos/F9o7u-CnDJk</a> By @Tony Webster</p>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p><img src="https://gw.alicdn.com/tfs/TB198F2ifDH8KJjy1XcXXcpdXXa-900-500.jpg" alt="管理 Node.js 进程从未如此优雅"></p>
<p>说到 Node.js 的进程模型，脑子里第一个闪现的]]>
    </summary>
    
      <category term="Node.js" scheme="http://taobaofed.org/tags/Node-js/"/>
    
      <category term="Pandora" scheme="http://taobaofed.org/tags/Pandora/"/>
    
      <category term="应用管理" scheme="http://taobaofed.org/tags/%E5%BA%94%E7%94%A8%E7%AE%A1%E7%90%86/"/>
    
      <category term="Node.js" scheme="http://taobaofed.org/categories/Node-js/"/>
    
  </entry>
  
</feed>
